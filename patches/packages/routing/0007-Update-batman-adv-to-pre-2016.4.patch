From: Sven Eckelmann <sven@narfation.org>
Date: Fri, 23 Sep 2016 14:19:18 +0200
Subject: Update batman-adv to pre-2016.4

diff --git a/batctl/patches/0002-batctl-netlink-add-routing_algo-query.patch b/batctl/patches/0002-batctl-netlink-add-routing_algo-query.patch
new file mode 100644
index 0000000..bce4f61
--- /dev/null
+++ b/batctl/patches/0002-batctl-netlink-add-routing_algo-query.patch
@@ -0,0 +1,38 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:35 +0200
+Subject: [PATCH] batctl: netlink: add routing_algo query
+
+BATADV_CMD_GET_ROUTING_ALGOS is used to get the list of supported routing
+algorithms.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Reduce the number of changes to
+BATADV_CMD_GET_ROUTING_ALGOS, fix includes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 0fbf6fd..7afce44 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -73,6 +73,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_MESH_INFO: Query basic information about batman-adv device
+  * @BATADV_CMD_TP_METER: Start a tp meter session
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
++ * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -81,6 +82,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_MESH_INFO,
+ 	BATADV_CMD_TP_METER,
+ 	BATADV_CMD_TP_METER_CANCEL,
++	BATADV_CMD_GET_ROUTING_ALGOS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0003-batctl-netlink-hardif-query.patch b/batctl/patches/0003-batctl-netlink-hardif-query.patch
new file mode 100644
index 0000000..4ea56aa
--- /dev/null
+++ b/batctl/patches/0003-batctl-netlink-hardif-query.patch
@@ -0,0 +1,54 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:36 +0200
+Subject: [PATCH] batctl: netlink: hardif query
+
+BATADV_CMD_GET_HARDIFS will return the list of hardifs (including index,
+name and MAC address) of all hardifs for a given softif.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Reduce the number of changes to
+BATADV_CMD_GET_HARDIFS, add policy for attributes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 7afce44..8abcbca 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -40,6 +40,7 @@
+  * @BATADV_ATTR_TPMETER_BYTES: amount of acked bytes during run
+  * @BATADV_ATTR_TPMETER_COOKIE: session cookie to match tp_meter session
+  * @BATADV_ATTR_PAD: attribute used for padding for 64-bit alignment
++ * @BATADV_ATTR_ACTIVE: Flag indicating if the hard interface is active
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -60,6 +61,7 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TPMETER_BYTES,
+ 	BATADV_ATTR_TPMETER_COOKIE,
+ 	BATADV_ATTR_PAD,
++	BATADV_ATTR_ACTIVE,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -74,6 +76,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_TP_METER: Start a tp meter session
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
+  * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
++ * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -83,6 +86,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_TP_METER,
+ 	BATADV_CMD_TP_METER_CANCEL,
+ 	BATADV_CMD_GET_ROUTING_ALGOS,
++	BATADV_CMD_GET_HARDIFS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0004-batctl-netlink-add-translation-table-query.patch b/batctl/patches/0004-batctl-netlink-add-translation-table-query.patch
new file mode 100644
index 0000000..977b4eb
--- /dev/null
+++ b/batctl/patches/0004-batctl-netlink-add-translation-table-query.patch
@@ -0,0 +1,165 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:37 +0200
+Subject: [PATCH] batctl: netlink: add translation table query
+
+This adds the commands BATADV_CMD_GET_TRANSTABLE_LOCAL and
+BATADV_CMD_GET_TRANSTABLE_GLOBAL, which correspond to the transtable_local
+and transtable_global debugfs files.
+
+The batadv_tt_client_flags enum is moved to the UAPI to expose it as part
+of the netlink API.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: add policy for attributes, fix includes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+[sw@simonwunderlich.de: fix VID attributes content]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 56 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ packet.h     | 36 ------------------------------------
+ 2 files changed, 56 insertions(+), 36 deletions(-)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 8abcbca..1168d05 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -23,6 +23,42 @@
+ #define BATADV_NL_MCAST_GROUP_TPMETER	"tpmeter"
+ 
+ /**
++ * enum batadv_tt_client_flags - TT client specific flags
++ * @BATADV_TT_CLIENT_DEL: the client has to be deleted from the table
++ * @BATADV_TT_CLIENT_ROAM: the client roamed to/from another node and the new
++ *  update telling its new real location has not been received/sent yet
++ * @BATADV_TT_CLIENT_WIFI: this client is connected through a wifi interface.
++ *  This information is used by the "AP Isolation" feature
++ * @BATADV_TT_CLIENT_ISOLA: this client is considered "isolated". This
++ *  information is used by the Extended Isolation feature
++ * @BATADV_TT_CLIENT_NOPURGE: this client should never be removed from the table
++ * @BATADV_TT_CLIENT_NEW: this client has been added to the local table but has
++ *  not been announced yet
++ * @BATADV_TT_CLIENT_PENDING: this client is marked for removal but it is kept
++ *  in the table for one more originator interval for consistency purposes
++ * @BATADV_TT_CLIENT_TEMP: this global client has been detected to be part of
++ *  the network but no nnode has already announced it
++ *
++ * Bits from 0 to 7 are called _remote flags_ because they are sent on the wire.
++ * Bits from 8 to 15 are called _local flags_ because they are used for local
++ * computations only.
++ *
++ * Bits from 4 to 7 - a subset of remote flags - are ensured to be in sync with
++ * the other nodes in the network. To achieve this goal these flags are included
++ * in the TT CRC computation.
++ */
++enum batadv_tt_client_flags {
++	BATADV_TT_CLIENT_DEL     = (1 << 0),
++	BATADV_TT_CLIENT_ROAM    = (1 << 1),
++	BATADV_TT_CLIENT_WIFI    = (1 << 4),
++	BATADV_TT_CLIENT_ISOLA	 = (1 << 5),
++	BATADV_TT_CLIENT_NOPURGE = (1 << 8),
++	BATADV_TT_CLIENT_NEW     = (1 << 9),
++	BATADV_TT_CLIENT_PENDING = (1 << 10),
++	BATADV_TT_CLIENT_TEMP	 = (1 << 11),
++};
++
++/**
+  * enum batadv_nl_attrs - batman-adv netlink attributes
+  *
+  * @BATADV_ATTR_UNSPEC: unspecified attribute to catch errors
+@@ -41,6 +77,14 @@
+  * @BATADV_ATTR_TPMETER_COOKIE: session cookie to match tp_meter session
+  * @BATADV_ATTR_PAD: attribute used for padding for 64-bit alignment
+  * @BATADV_ATTR_ACTIVE: Flag indicating if the hard interface is active
++ * @BATADV_ATTR_TT_ADDRESS: Client MAC address
++ * @BATADV_ATTR_TT_TTVN: Translation table version
++ * @BATADV_ATTR_TT_LAST_TTVN: Previous translation table version
++ * @BATADV_ATTR_TT_CRC32: CRC32 over translation table
++ * @BATADV_ATTR_TT_VID: VLAN ID
++ * @BATADV_ATTR_TT_FLAGS: Translation table client flags
++ * @BATADV_ATTR_FLAG_BEST: Flags indicating entry is the best
++ * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -62,6 +106,14 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TPMETER_COOKIE,
+ 	BATADV_ATTR_PAD,
+ 	BATADV_ATTR_ACTIVE,
++	BATADV_ATTR_TT_ADDRESS,
++	BATADV_ATTR_TT_TTVN,
++	BATADV_ATTR_TT_LAST_TTVN,
++	BATADV_ATTR_TT_CRC32,
++	BATADV_ATTR_TT_VID,
++	BATADV_ATTR_TT_FLAGS,
++	BATADV_ATTR_FLAG_BEST,
++	BATADV_ATTR_LAST_SEEN_MSECS,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -77,6 +129,8 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
+  * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
+  * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
++ * @BATADV_CMD_GET_TRANSTABLE_LOCAL: Query list of local translations
++ * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -87,6 +141,8 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_TP_METER_CANCEL,
+ 	BATADV_CMD_GET_ROUTING_ALGOS,
+ 	BATADV_CMD_GET_HARDIFS,
++	BATADV_CMD_GET_TRANSTABLE_LOCAL,
++	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/packet.h b/packet.h
+index 6b011ff..6afc0b8 100644
+--- a/packet.h
++++ b/packet.h
+@@ -129,42 +129,6 @@ enum batadv_tt_data_flags {
+ };
+ 
+ /**
+- * enum batadv_tt_client_flags - TT client specific flags
+- * @BATADV_TT_CLIENT_DEL: the client has to be deleted from the table
+- * @BATADV_TT_CLIENT_ROAM: the client roamed to/from another node and the new
+- *  update telling its new real location has not been received/sent yet
+- * @BATADV_TT_CLIENT_WIFI: this client is connected through a wifi interface.
+- *  This information is used by the "AP Isolation" feature
+- * @BATADV_TT_CLIENT_ISOLA: this client is considered "isolated". This
+- *  information is used by the Extended Isolation feature
+- * @BATADV_TT_CLIENT_NOPURGE: this client should never be removed from the table
+- * @BATADV_TT_CLIENT_NEW: this client has been added to the local table but has
+- *  not been announced yet
+- * @BATADV_TT_CLIENT_PENDING: this client is marked for removal but it is kept
+- *  in the table for one more originator interval for consistency purposes
+- * @BATADV_TT_CLIENT_TEMP: this global client has been detected to be part of
+- *  the network but no nnode has already announced it
+- *
+- * Bits from 0 to 7 are called _remote flags_ because they are sent on the wire.
+- * Bits from 8 to 15 are called _local flags_ because they are used for local
+- * computations only.
+- *
+- * Bits from 4 to 7 - a subset of remote flags - are ensured to be in sync with
+- * the other nodes in the network. To achieve this goal these flags are included
+- * in the TT CRC computation.
+- */
+-enum batadv_tt_client_flags {
+-	BATADV_TT_CLIENT_DEL     = BIT(0),
+-	BATADV_TT_CLIENT_ROAM    = BIT(1),
+-	BATADV_TT_CLIENT_WIFI    = BIT(4),
+-	BATADV_TT_CLIENT_ISOLA	 = BIT(5),
+-	BATADV_TT_CLIENT_NOPURGE = BIT(8),
+-	BATADV_TT_CLIENT_NEW     = BIT(9),
+-	BATADV_TT_CLIENT_PENDING = BIT(10),
+-	BATADV_TT_CLIENT_TEMP	 = BIT(11),
+-};
+-
+-/**
+  * enum batadv_vlan_flags - flags for the four MSB of any vlan ID field
+  * @BATADV_VLAN_HAS_TAG: whether the field contains a valid vlan tag or not
+  */
diff --git a/batctl/patches/0005-batctl-netlink-add-originator-and-neighbor-table-que.patch b/batctl/patches/0005-batctl-netlink-add-originator-and-neighbor-table-que.patch
new file mode 100644
index 0000000..ee6326b
--- /dev/null
+++ b/batctl/patches/0005-batctl-netlink-add-originator-and-neighbor-table-que.patch
@@ -0,0 +1,40 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:39 +0200
+Subject: [PATCH] batctl: netlink: add originator and neighbor table queries
+
+Add BATADV_CMD_GET_ORIGINATORS and BATADV_CMD_GET_NEIGHBORS commands,
+using handlers bat_orig_dump and bat_neigh_dump in batadv_algo_ops. Will
+always return -EOPNOTSUPP for now, as no implementations exist yet.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Rewrite based on new algo_ops structures]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 1168d05..3f7a415 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -131,6 +131,8 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
+  * @BATADV_CMD_GET_TRANSTABLE_LOCAL: Query list of local translations
+  * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
++ * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
++ * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -143,6 +145,8 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_HARDIFS,
+ 	BATADV_CMD_GET_TRANSTABLE_LOCAL,
+ 	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++	BATADV_CMD_GET_ORIGINATORS,
++	BATADV_CMD_GET_NEIGHBORS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0006-batctl-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump-imp.patch b/batctl/patches/0006-batctl-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump-imp.patch
new file mode 100644
index 0000000..f8fdb7f
--- /dev/null
+++ b/batctl/patches/0006-batctl-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump-imp.patch
@@ -0,0 +1,37 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:40 +0200
+Subject: [PATCH] batctl: add B.A.T.M.A.N. IV bat_{orig, neigh}_dump implementations
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Fix function parameter alignments,
+add policy for attributes, fix includes, fix algo_ops integration]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 3f7a415..ba2359a 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -85,6 +85,8 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_TT_FLAGS: Translation table client flags
+  * @BATADV_ATTR_FLAG_BEST: Flags indicating entry is the best
+  * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
++ * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
++ * @BATADV_ATTR_TQ: TQ to neighbour
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -114,6 +116,8 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TT_FLAGS,
+ 	BATADV_ATTR_FLAG_BEST,
+ 	BATADV_ATTR_LAST_SEEN_MSECS,
++	BATADV_ATTR_NEIGH_ADDRESS,
++	BATADV_ATTR_TQ,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
diff --git a/batctl/patches/0007-batctl-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-impl.patch b/batctl/patches/0007-batctl-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-impl.patch
new file mode 100644
index 0000000..0e07afd
--- /dev/null
+++ b/batctl/patches/0007-batctl-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-impl.patch
@@ -0,0 +1,36 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:41 +0200
+Subject: [PATCH] batctl: add B.A.T.M.A.N. V bat_{orig, neigh}_dump implementations
+
+Dump the algo V originators and neighbours.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Fix includes, fix algo_ops integration]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index ba2359a..2e2747f 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -87,6 +87,7 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
+  * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
+  * @BATADV_ATTR_TQ: TQ to neighbour
++ * @BATADV_ATTR_THROUGHPUT: Estimated throughput to Neighbour
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -118,6 +119,7 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_LAST_SEEN_MSECS,
+ 	BATADV_ATTR_NEIGH_ADDRESS,
+ 	BATADV_ATTR_TQ,
++	BATADV_ATTR_THROUGHPUT,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
diff --git a/batctl/patches/0008-batctl-netlink-add-gateway-table-queries.patch b/batctl/patches/0008-batctl-netlink-add-gateway-table-queries.patch
new file mode 100644
index 0000000..2a86a13
--- /dev/null
+++ b/batctl/patches/0008-batctl-netlink-add-gateway-table-queries.patch
@@ -0,0 +1,54 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 3 Jul 2016 13:31:42 +0200
+Subject: [PATCH] batctl: netlink: add gateway table queries
+
+Add BATADV_CMD_GET_GATEWAYS commands, using handlers bat_gw_dump in
+batadv_algo_ops. Will always return -EOPNOTSUPP for now, as no
+implementations exist yet.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 2e2747f..a13fc09 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -88,6 +88,9 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
+  * @BATADV_ATTR_TQ: TQ to neighbour
+  * @BATADV_ATTR_THROUGHPUT: Estimated throughput to Neighbour
++ * @BATADV_ATTR_BANDWIDTH_UP: Reported uplink bandwidth
++ * @BATADV_ATTR_BANDWIDTH_DOWN: Reported downlink bandwidth
++ * @BATADV_ATTR_ROUTER: Gateway router MAC address
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -120,6 +123,9 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_NEIGH_ADDRESS,
+ 	BATADV_ATTR_TQ,
+ 	BATADV_ATTR_THROUGHPUT,
++	BATADV_ATTR_BANDWIDTH_UP,
++	BATADV_ATTR_BANDWIDTH_DOWN,
++	BATADV_ATTR_ROUTER,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -139,6 +145,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
+  * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
++ * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -153,6 +160,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
+ 	BATADV_CMD_GET_ORIGINATORS,
+ 	BATADV_CMD_GET_NEIGHBORS,
++	BATADV_CMD_GET_GATEWAYS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0009-batctl-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netlink.patch b/batctl/patches/0009-batctl-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netlink.patch
new file mode 100644
index 0000000..14bb8b0
--- /dev/null
+++ b/batctl/patches/0009-batctl-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netlink.patch
@@ -0,0 +1,61 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:45 +0200
+Subject: [PATCH] batctl: add B.A.T.M.A.N. Dump BLA claims via netlink
+
+Dump the list of bridge loop avoidance claims via the netlink socket.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: add policy for attributes, fix includes, fix
+soft_iface reference leak]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+[sw@simonwunderlich.de: fix kerneldoc, fix error reporting]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index a13fc09..96b37ab 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -91,6 +91,11 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_BANDWIDTH_UP: Reported uplink bandwidth
+  * @BATADV_ATTR_BANDWIDTH_DOWN: Reported downlink bandwidth
+  * @BATADV_ATTR_ROUTER: Gateway router MAC address
++ * @BATADV_ATTR_BLA_OWN: Flag indicating own originator
++ * @BATADV_ATTR_BLA_ADDRESS: Bridge loop avoidance claim MAC address
++ * @BATADV_ATTR_BLA_VID: BLA VLAN ID
++ * @BATADV_ATTR_BLA_BACKBONE: BLA gateway originator MAC address
++ * @BATADV_ATTR_BLA_CRC: BLA CRC
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -126,6 +131,11 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_BANDWIDTH_UP,
+ 	BATADV_ATTR_BANDWIDTH_DOWN,
+ 	BATADV_ATTR_ROUTER,
++	BATADV_ATTR_BLA_OWN,
++	BATADV_ATTR_BLA_ADDRESS,
++	BATADV_ATTR_BLA_VID,
++	BATADV_ATTR_BLA_BACKBONE,
++	BATADV_ATTR_BLA_CRC,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -146,6 +156,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
++ * @BATADV_CMD_GET_BLA_CLAIM: Query list of bridge loop avoidance claims
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -161,6 +172,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_ORIGINATORS,
+ 	BATADV_CMD_GET_NEIGHBORS,
+ 	BATADV_CMD_GET_GATEWAYS,
++	BATADV_CMD_GET_BLA_CLAIM,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0010-batctl-add-backbone-table-netlink-support.patch b/batctl/patches/0010-batctl-add-backbone-table-netlink-support.patch
new file mode 100644
index 0000000..e438899
--- /dev/null
+++ b/batctl/patches/0010-batctl-add-backbone-table-netlink-support.patch
@@ -0,0 +1,33 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Sun, 3 Jul 2016 13:31:47 +0200
+Subject: [PATCH] batctl: add backbone table netlink support
+
+Dump the list of bridge loop avoidance backbones via the netlink socket.
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ batman_adv.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/batman_adv.h b/batman_adv.h
+index 96b37ab..734fe83 100644
+--- a/batman_adv.h
++++ b/batman_adv.h
+@@ -157,6 +157,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
+  * @BATADV_CMD_GET_BLA_CLAIM: Query list of bridge loop avoidance claims
++ * @BATADV_CMD_GET_BLA_BACKBONE: Query list of bridge loop avoidance backbones
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -173,6 +174,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_NEIGHBORS,
+ 	BATADV_CMD_GET_GATEWAYS,
+ 	BATADV_CMD_GET_BLA_CLAIM,
++	BATADV_CMD_GET_BLA_BACKBONE,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
diff --git a/batctl/patches/0011-batctl-Use-netlink-to-replace-some-of-debugfs.patch b/batctl/patches/0011-batctl-Use-netlink-to-replace-some-of-debugfs.patch
new file mode 100644
index 0000000..47c19b7
--- /dev/null
+++ b/batctl/patches/0011-batctl-Use-netlink-to-replace-some-of-debugfs.patch
@@ -0,0 +1,1323 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Mon, 18 Jul 2016 12:12:01 +0200
+Subject: [PATCH] batctl: Use netlink to replace some of debugfs
+
+The kernel has gained support for exporting some information via
+netlink.  Use this when available, rather than debugfs.
+
+If netlink is not available, or the information is not yet available
+via netlink, batctl will fall back to debugfs.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Add missing local TTVN in transtable_global, add
+missing local group id to claim table, fix use-after-free of algo_name, fix
+alignment of the originator entries]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+[sw@simonwunderlich.de: fix claimtable output format, fix name of mandatory
+claim table attributes, fix printing of VIDs]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ debug.c     |   22 +-
+ debug.h     |    4 +-
+ functions.c |   11 +
+ functions.h |    2 +
+ netlink.c   | 1069 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
+ netlink.h   |   18 +-
+ 6 files changed, 1121 insertions(+), 5 deletions(-)
+
+diff --git a/debug.c b/debug.c
+index 5b280cb..46f03da 100644
+--- a/debug.c
++++ b/debug.c
+@@ -23,10 +23,12 @@
+ #include <unistd.h>
+ #include <stdio.h>
+ #include <stdlib.h>
++#include <errno.h>
+ 
+ #include "debug.h"
+ #include "debugfs.h"
+ #include "functions.h"
++#include "netlink.h"
+ #include "sys.h"
+ 
+ const struct debug_table_data batctl_debug_tables[BATCTL_TABLE_NUM] = {
+@@ -35,36 +37,42 @@ const struct debug_table_data batctl_debug_tables[BATCTL_TABLE_NUM] = {
+ 		.opt_short = "n",
+ 		.debugfs_name = "neighbors",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_neighbors,
+ 	},
+ 	{
+ 		.opt_long = "originators",
+ 		.opt_short = "o",
+ 		.debugfs_name = "originators",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_originators,
+ 	},
+ 	{
+ 		.opt_long = "gateways",
+ 		.opt_short = "gwl",
+ 		.debugfs_name = "gateways",
+ 		.header_lines = 1,
++		.netlink_fn = netlink_print_gateways,
+ 	},
+ 	{
+ 		.opt_long = "translocal",
+ 		.opt_short = "tl",
+ 		.debugfs_name = "transtable_local",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_translocal,
+ 	},
+ 	{
+ 		.opt_long = "transglobal",
+ 		.opt_short = "tg",
+ 		.debugfs_name = "transtable_global",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_transglobal,
+ 	},
+ 	{
+ 		.opt_long = "claimtable",
+ 		.opt_short = "cl",
+ 		.debugfs_name = "bla_claim_table",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_bla_claim,
+ 	},
+ 	{
+ 		.opt_long = "backbonetable",
+@@ -121,7 +129,7 @@ int handle_debug_table(char *mesh_iface, int debug_table, int argc, char **argv)
+ 	char *orig_iface = NULL;
+ 	float orig_timeout = 0.0f;
+ 	float watch_interval = 1;
+-	opterr = 0;
++	int err;
+ 
+ 	while ((optchar = getopt(argc, argv, "hnw:t:Humi:")) != -1) {
+ 		switch (optchar) {
+@@ -222,16 +230,26 @@ int handle_debug_table(char *mesh_iface, int debug_table, int argc, char **argv)
+ 		return EXIT_FAILURE;
+ 	}
+ 
++	if (batctl_debug_tables[debug_table].netlink_fn) {
++		err = batctl_debug_tables[debug_table].netlink_fn(
++			mesh_iface, orig_iface, read_opt, orig_timeout,
++			watch_interval);
++		if (err != -EOPNOTSUPP)
++			return err;
++	}
++
+ 	if (orig_iface)
+ 		debugfs_make_path(DEBUG_BATIF_PATH_FMT "/", orig_iface, full_path, sizeof(full_path));
+ 	else
+ 		debugfs_make_path(DEBUG_BATIF_PATH_FMT "/", mesh_iface, full_path, sizeof(full_path));
++
+ 	return read_file(full_path, (char *)batctl_debug_tables[debug_table].debugfs_name,
+ 			 read_opt, orig_timeout, watch_interval,
+ 			 batctl_debug_tables[debug_table].header_lines);
+ }
+ 
+-int print_routing_algos(void) {
++int debug_print_routing_algos(void)
++{
+ 	char full_path[MAX_PATH+1];
+ 	char *debugfs_mnt;
+ 
+diff --git a/debug.h b/debug.h
+index 46e8c3c..1c9374a 100644
+--- a/debug.h
++++ b/debug.h
+@@ -49,13 +49,15 @@ struct debug_table_data {
+        const char opt_short[OPT_SHORT_MAX_LEN];
+        const char debugfs_name[DEBUG_TABLE_PATH_MAX_LEN];
+        size_t header_lines;
++       int (*netlink_fn)(char *mesh_iface, char *hard_iface, int read_opt,
++			 float orig_timeout, float watch_interval);
+ };
+ 
+ extern const struct debug_table_data batctl_debug_tables[BATCTL_TABLE_NUM];
+ 
+ int handle_debug_table(char *mesh_iface, int debug_table, int argc, char **argv);
+ int log_print(char *mesh_iface, int argc, char **argv);
+-int print_routing_algos(void);
++int debug_print_routing_algos(void);
+ int print_vis_info(char *mesh_iface);
+ 
+ #endif
+diff --git a/functions.c b/functions.c
+index 97a6dbd..5b76062 100644
+--- a/functions.c
++++ b/functions.c
+@@ -52,6 +52,7 @@
+ #include "sys.h"
+ #include "debug.h"
+ #include "debugfs.h"
++#include "netlink.h"
+ 
+ static struct timeval start_time;
+ static char *host_name;
+@@ -850,3 +851,13 @@ err:
+ 
+ 	return arg.vid;
+ }
++
++int print_routing_algos(void)
++{
++	int err;
++
++	err = netlink_print_routing_algos();
++	if (err == -EOPNOTSUPP)
++		err = debug_print_routing_algos();
++	return err;
++}
+diff --git a/functions.h b/functions.h
+index d0b05b9..2d29d52 100644
+--- a/functions.h
++++ b/functions.h
+@@ -44,6 +44,7 @@ struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac);
+ struct ether_addr *resolve_mac(const char *asc);
+ int vlan_get_link(const char *ifname, char **parent);
+ 
++int print_routing_algos(void);
+ extern char *line_ptr;
+ 
+ enum {
+@@ -59,6 +60,7 @@ enum {
+ 	SKIP_HEADER = 0x100,
+ 	UNICAST_ONLY = 0x200,
+ 	MULTICAST_ONLY = 0x400,
++	PARSE_ONLY = 0x800,
+ };
+ 
+ #endif
+diff --git a/netlink.c b/netlink.c
+index 365cda1..b87964a 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -1,7 +1,7 @@
+ /*
+  * Copyright (C) 2009-2016  B.A.T.M.A.N. contributors:
+  *
+- * Marek Lindner <mareklindner@neomailbox.ch>
++ * Marek Lindner <mareklindner@neomailbox.ch>, Andrew Lunn <andrew@lunn.ch>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of version 2 of the GNU General Public
+@@ -22,9 +22,33 @@
+ #include "netlink.h"
+ #include "main.h"
+ 
++#include <stdio.h>
++#include <string.h>
++#include <unistd.h>
++#include <errno.h>
+ #include <net/ethernet.h>
++#include <net/if.h>
++#include <netlink/netlink.h>
++#include <netlink/genl/genl.h>
++#include <netlink/genl/ctrl.h>
++#include <netinet/in.h>
++#include <arpa/inet.h>
+ 
++#include "bat-hosts.h"
+ #include "batman_adv.h"
++#include "netlink.h"
++#include "functions.h"
++#include "main.h"
++#include "packet.h"
++
++#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
++
++struct print_opts {
++	int read_opt;
++	float orig_timeout;
++	float watch_interval;
++	uint8_t nl_cmd;
++};
+ 
+ struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_VERSION]		= { .type = NLA_STRING },
+@@ -49,4 +73,1047 @@ struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_TPMETER_BYTES]	= { .type = NLA_U64 },
+ 	[BATADV_ATTR_TPMETER_COOKIE]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_PAD]		= { .type = NLA_UNSPEC },
++	[BATADV_ATTR_ACTIVE]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_TT_ADDRESS]	= { .type = NLA_UNSPEC,
++					    .minlen = ETH_ALEN,
++					    .maxlen = ETH_ALEN },
++	[BATADV_ATTR_TT_TTVN]		= { .type = NLA_U8 },
++	[BATADV_ATTR_TT_LAST_TTVN]	= { .type = NLA_U8 },
++	[BATADV_ATTR_TT_CRC32]		= { .type = NLA_U32 },
++	[BATADV_ATTR_TT_VID]		= { .type = NLA_U16 },
++	[BATADV_ATTR_TT_FLAGS]		= { .type = NLA_U32 },
++	[BATADV_ATTR_FLAG_BEST]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_LAST_SEEN_MSECS]	= { .type = NLA_U32 },
++	[BATADV_ATTR_NEIGH_ADDRESS]	= { .type = NLA_UNSPEC,
++					    .minlen = ETH_ALEN,
++					    .maxlen = ETH_ALEN },
++	[BATADV_ATTR_TQ]		= { .type = NLA_U8 },
++	[BATADV_ATTR_THROUGHPUT]	= { .type = NLA_U32 },
++	[BATADV_ATTR_BANDWIDTH_UP]	= { .type = NLA_U32 },
++	[BATADV_ATTR_BANDWIDTH_DOWN]	= { .type = NLA_U32 },
++	[BATADV_ATTR_ROUTER]		= { .type = NLA_UNSPEC,
++					    .minlen = ETH_ALEN,
++					    .maxlen = ETH_ALEN },
++	[BATADV_ATTR_BLA_OWN]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_BLA_ADDRESS]	= { .type = NLA_UNSPEC,
++					    .minlen = ETH_ALEN,
++					    .maxlen = ETH_ALEN },
++	[BATADV_ATTR_BLA_VID]		= { .type = NLA_U16 },
++	[BATADV_ATTR_BLA_BACKBONE]	= { .type = NLA_UNSPEC,
++					    .minlen = ETH_ALEN,
++					    .maxlen = ETH_ALEN },
++	[BATADV_ATTR_BLA_CRC]		= { .type = NLA_U16 },
+ };
++
++static int last_err;
++static char algo_name_buf[256] = "";
++
++static int missing_mandatory_attrs(struct nlattr *attrs[],
++				   const int mandatory[], int num)
++{
++	int i;
++
++	for (i = 0; i < num; i++)
++		if (!attrs[mandatory[i]])
++			return -EINVAL;
++
++	return 0;
++}
++
++static int print_error(struct sockaddr_nl *nla __unused,
++		       struct nlmsgerr *nlerr,
++		       void *arg __unused)
++{
++	if (nlerr->error != -EOPNOTSUPP)
++		fprintf(stderr, "Error received: %s\n",
++			strerror(-nlerr->error));
++
++	last_err = -nlerr->error;
++
++	return NL_STOP;
++}
++
++static int stop_callback(struct nl_msg *msg, void *arg __unused)
++{
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	int *error = nlmsg_data(nlh);
++
++	if (*error)
++		fprintf(stderr, "Error received: %s\n", strerror(-*error));
++
++	return NL_STOP;
++}
++
++static const int info_mandatory[] = {
++	BATADV_ATTR_MESH_IFINDEX,
++	BATADV_ATTR_MESH_IFNAME,
++};
++
++static const int info_hard_mandatory[] = {
++	BATADV_ATTR_VERSION,
++	BATADV_ATTR_ALGO_NAME,
++	BATADV_ATTR_HARD_IFNAME,
++	BATADV_ATTR_HARD_ADDRESS,
++};
++
++static int info_callback(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct print_opts *opts = arg;
++	const uint8_t *primary_mac;
++	struct genlmsghdr *ghdr;
++	const uint8_t *mesh_mac;
++	const char *primary_if;
++	const char *mesh_name;
++	const char *version;
++	char *extra_info = NULL;
++	uint8_t ttvn = 0;
++	uint16_t bla_group_id = 0;
++	const char *algo_name;
++	int ret;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_MESH_INFO)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, info_mandatory,
++				    ARRAY_SIZE(info_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	mesh_name = nla_get_string(attrs[BATADV_ATTR_MESH_IFNAME]);
++	mesh_mac = nla_data(attrs[BATADV_ATTR_MESH_ADDRESS]);
++
++	if (attrs[BATADV_ATTR_HARD_IFNAME]) {
++		if (missing_mandatory_attrs(attrs, info_hard_mandatory,
++					    ARRAY_SIZE(info_hard_mandatory))) {
++			fputs("Missing attributes from kernel\n",
++			      stderr);
++			exit(1);
++		}
++
++		version = nla_get_string(attrs[BATADV_ATTR_VERSION]);
++		algo_name = nla_get_string(attrs[BATADV_ATTR_ALGO_NAME]);
++		primary_if = nla_get_string(attrs[BATADV_ATTR_HARD_IFNAME]);
++		primary_mac = nla_data(attrs[BATADV_ATTR_HARD_ADDRESS]);
++
++		snprintf(algo_name_buf, sizeof(algo_name_buf), "%s", algo_name);
++
++		if (attrs[BATADV_ATTR_TT_TTVN])
++			ttvn = nla_get_u8(attrs[BATADV_ATTR_TT_TTVN]);
++
++		if (attrs[BATADV_ATTR_BLA_CRC])
++			bla_group_id = nla_get_u16(attrs[BATADV_ATTR_BLA_CRC]);
++
++		if (!(opts->read_opt & PARSE_ONLY)) {
++			switch (opts->nl_cmd) {
++			case BATADV_CMD_GET_TRANSTABLE_LOCAL:
++				ret = asprintf(&extra_info, ", TTVN: %u", ttvn);
++				if (ret < 0)
++					extra_info = NULL;
++				break;
++			case BATADV_CMD_GET_BLA_CLAIM:
++				ret = asprintf(&extra_info, ", group id: 0x%04x",
++					       bla_group_id);
++				if (ret < 0)
++					extra_info = NULL;
++				break;
++			default:
++				extra_info = strdup("");
++				break;
++			}
++
++			printf("[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%02x:%02x:%02x:%02x:%02x:%02x (%s/%02x:%02x:%02x:%02x:%02x:%02x %s)%s]\n",
++			       version, primary_if,
++			       primary_mac[0], primary_mac[1], primary_mac[2],
++			       primary_mac[3], primary_mac[4], primary_mac[5],
++			       mesh_name,
++			       mesh_mac[0], mesh_mac[1], mesh_mac[2],
++			       mesh_mac[3], mesh_mac[4], mesh_mac[5],
++			       algo_name, extra_info);
++
++			if (extra_info)
++				free(extra_info);
++		}
++	} else {
++		if (!(opts->read_opt & PARSE_ONLY))
++			printf("BATMAN mesh %s disabled\n", mesh_name);
++	}
++
++	return NL_STOP;
++}
++
++static void netlink_print_info(int ifindex, uint8_t nl_cmd, int read_opt)
++{
++	struct nl_sock *sock;
++	struct nl_msg *msg;
++	struct nl_cb *cb;
++	int family;
++	struct print_opts opts = {
++		.read_opt = read_opt,
++		.nl_cmd = nl_cmd,
++	};
++
++	sock = nl_socket_alloc();
++	genl_connect(sock);
++
++	family = genl_ctrl_resolve(sock, BATADV_NL_NAME);
++	if (family < 0)
++		return;
++
++	msg = nlmsg_alloc();
++	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, 0,
++		    BATADV_CMD_GET_MESH_INFO, 1);
++
++	nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, ifindex);
++
++	nl_send_auto_complete(sock, msg);
++
++	nlmsg_free(msg);
++
++	cb = nl_cb_alloc(NL_CB_DEFAULT);
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, info_callback, &opts);
++	nl_cb_err(cb, NL_CB_CUSTOM, print_error, NULL);
++
++	nl_recvmsgs(sock, cb);
++
++	nl_socket_free(sock);
++}
++
++static const int routing_algos_mandatory[] = {
++	BATADV_ATTR_ALGO_NAME,
++};
++
++static int routing_algos_callback(struct nl_msg *msg, void *arg __unused)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct genlmsghdr *ghdr;
++	const char *algo_name;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_ROUTING_ALGOS)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, routing_algos_mandatory,
++				    ARRAY_SIZE(routing_algos_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	algo_name = nla_get_string(attrs[BATADV_ATTR_ALGO_NAME]);
++
++	printf(" * %s\n", algo_name);
++
++	return NL_OK;
++}
++
++int netlink_print_routing_algos(void)
++{
++	struct nl_sock *sock;
++	struct nl_msg *msg;
++	struct nl_cb *cb;
++	int family;
++
++	sock = nl_socket_alloc();
++	genl_connect(sock);
++
++	family = genl_ctrl_resolve(sock, BATADV_NL_NAME);
++	if (family < 0)
++		return -EOPNOTSUPP;
++
++	msg = nlmsg_alloc();
++	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_DUMP,
++		    BATADV_CMD_GET_ROUTING_ALGOS, 1);
++
++	nl_send_auto_complete(sock, msg);
++
++	nlmsg_free(msg);
++
++	cb = nl_cb_alloc(NL_CB_DEFAULT);
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, routing_algos_callback,
++		  NULL);
++	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, stop_callback, NULL);
++	nl_cb_err(cb, NL_CB_CUSTOM, print_error, NULL);
++
++	printf("Available routing algorithms:\n");
++
++	nl_recvmsgs(sock, cb);
++
++	nl_socket_free(sock);
++
++	return 0;
++}
++
++static const int originators_mandatory[] = {
++	BATADV_ATTR_ORIG_ADDRESS,
++	BATADV_ATTR_NEIGH_ADDRESS,
++	BATADV_ATTR_HARD_IFINDEX,
++	BATADV_ATTR_LAST_SEEN_MSECS,
++};
++
++static int originators_callback(struct nl_msg *msg, void *arg)
++{
++	unsigned throughput_mbits, throughput_kbits;
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	int last_seen_msecs, last_seen_secs;
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	char ifname[IF_NAMESIZE];
++	float last_seen;
++	uint8_t *neigh;
++	uint8_t *orig;
++	char c = ' ';
++	uint8_t tq;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_ORIGINATORS)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, originators_mandatory,
++				       ARRAY_SIZE(originators_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
++	neigh = nla_data(attrs[BATADV_ATTR_NEIGH_ADDRESS]);
++
++	if (!if_indextoname(nla_get_u32(attrs[BATADV_ATTR_HARD_IFINDEX]),
++			    ifname))
++		ifname[0] = '\0';
++
++	if (attrs[BATADV_ATTR_FLAG_BEST])
++		c = '*';
++
++	last_seen_msecs = nla_get_u32(attrs[BATADV_ATTR_LAST_SEEN_MSECS]);
++	last_seen = (float)last_seen_msecs / 1000.0;
++	last_seen_secs = last_seen_msecs / 1000;
++	last_seen_msecs = last_seen_msecs % 1000;
++
++	/* skip timed out originators */
++	if (opts->read_opt & NO_OLD_ORIGS)
++		if (last_seen > opts->orig_timeout)
++			return NL_OK;
++
++	if (attrs[BATADV_ATTR_THROUGHPUT]) {
++		throughput_kbits = nla_get_u32(attrs[BATADV_ATTR_THROUGHPUT]);
++		throughput_mbits = throughput_kbits / 1000;
++		throughput_kbits = throughput_kbits % 1000;
++
++		if (!(opts->read_opt & USE_BAT_HOSTS)) {
++			printf(" %c %02x:%02x:%02x:%02x:%02x:%02x %4i.%03is (%9u.%1u) %02x:%02x:%02x:%02x:%02x:%02x [%10s]\n",
++			       c,
++			       orig[0], orig[1], orig[2],
++			       orig[3], orig[4], orig[5],
++			       last_seen_secs, last_seen_msecs,
++			       throughput_mbits, throughput_kbits / 100,
++			       neigh[0], neigh[1], neigh[2],
++			       neigh[3], neigh[4], neigh[5],
++			       ifname);
++		} else {
++			bat_host = bat_hosts_find_by_mac((char *)orig);
++			if (bat_host)
++				printf(" %c %17s ", c, bat_host->name);
++			else
++				printf(" %c %02x:%02x:%02x:%02x:%02x:%02x ",
++				       c,
++				       orig[0], orig[1], orig[2],
++				       orig[3], orig[4], orig[5]);
++			printf("%4i.%03is (%9u.%1u) ",
++			       last_seen_secs, last_seen_msecs,
++			       throughput_mbits, throughput_kbits / 100);
++			bat_host = bat_hosts_find_by_mac((char *)neigh);
++			if (bat_host)
++				printf(" %c %17s ", c, bat_host->name);
++			else
++				printf(" %02x:%02x:%02x:%02x:%02x:%02x ",
++				       neigh[0], neigh[1], neigh[2],
++				       neigh[3], neigh[4], neigh[5]);
++			printf("[%10s]\n", ifname);
++		}
++	}
++	if (attrs[BATADV_ATTR_TQ]) {
++		tq = nla_get_u8(attrs[BATADV_ATTR_TQ]);
++
++		if (!(opts->read_opt & USE_BAT_HOSTS)) {
++			printf(" %c %02x:%02x:%02x:%02x:%02x:%02x %4i.%03is   (%3i) %02x:%02x:%02x:%02x:%02x:%02x [%10s]\n",
++			       c,
++			       orig[0], orig[1], orig[2],
++			       orig[3], orig[4], orig[5],
++			       last_seen_secs, last_seen_msecs, tq,
++			       neigh[0], neigh[1], neigh[2],
++			       neigh[3], neigh[4], neigh[5],
++			       ifname);
++		} else {
++			bat_host = bat_hosts_find_by_mac((char *)orig);
++			if (bat_host)
++				printf(" %c %17s ", c, bat_host->name);
++			else
++				printf(" %c %02x:%02x:%02x:%02x:%02x:%02x ",
++				       c,
++				       orig[0], orig[1], orig[2],
++				       orig[3], orig[4], orig[5]);
++			printf("%4i.%03is   (%3i) ",
++			       last_seen_secs, last_seen_msecs, tq);
++			bat_host = bat_hosts_find_by_mac((char *)neigh);
++			if (bat_host)
++				printf("%17s ", bat_host->name);
++			else
++				printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++				       neigh[0], neigh[1], neigh[2],
++				       neigh[3], neigh[4], neigh[5]);
++			printf("[%10s]\n", ifname);
++		}
++	}
++
++	return NL_OK;
++}
++
++static const int neighbors_mandatory[] = {
++	BATADV_ATTR_NEIGH_ADDRESS,
++	BATADV_ATTR_HARD_IFINDEX,
++	BATADV_ATTR_LAST_SEEN_MSECS,
++};
++
++static int neighbors_callback(struct nl_msg *msg, void *arg)
++{
++	unsigned throughput_mbits, throughput_kbits;
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	int last_seen_msecs, last_seen_secs;
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	char ifname[IF_NAMESIZE];
++	struct genlmsghdr *ghdr;
++	uint8_t *neigh;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_NEIGHBORS)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, neighbors_mandatory,
++				    ARRAY_SIZE(neighbors_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	neigh = nla_data(attrs[BATADV_ATTR_NEIGH_ADDRESS]);
++	bat_host = bat_hosts_find_by_mac((char *)neigh);
++
++	if (!if_indextoname(nla_get_u32(attrs[BATADV_ATTR_HARD_IFINDEX]),
++			    ifname))
++		ifname[0] = '\0';
++
++	last_seen_msecs = nla_get_u32(attrs[BATADV_ATTR_LAST_SEEN_MSECS]);
++	last_seen_secs = last_seen_msecs / 1000;
++	last_seen_msecs = last_seen_msecs % 1000;
++
++	if (attrs[BATADV_ATTR_THROUGHPUT]) {
++		throughput_kbits = nla_get_u32(attrs[BATADV_ATTR_THROUGHPUT]);
++		throughput_mbits = throughput_kbits / 1000;
++		throughput_kbits = throughput_kbits % 1000;
++
++		if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++			printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++			       neigh[0], neigh[1], neigh[2],
++			       neigh[3], neigh[4], neigh[5]);
++		else
++			printf("%17s ", bat_host->name);
++
++		printf("%4i.%03is (%9u.%1u) [%10s]\n",
++		       last_seen_secs, last_seen_msecs,
++		       throughput_mbits, throughput_kbits / 100,
++		       ifname);
++	} else {
++		printf("   %10s	  ", ifname);
++
++		if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++			printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++			       neigh[0], neigh[1], neigh[2],
++			       neigh[3], neigh[4], neigh[5]);
++		else
++			printf("%17s ", bat_host->name);
++
++		printf("%4i.%03is\n", last_seen_secs, last_seen_msecs);
++	}
++
++	return NL_OK;
++}
++
++static const int transglobal_mandatory[] = {
++	BATADV_ATTR_TT_ADDRESS,
++	BATADV_ATTR_ORIG_ADDRESS,
++	BATADV_ATTR_TT_VID,
++	BATADV_ATTR_TT_TTVN,
++	BATADV_ATTR_TT_LAST_TTVN,
++	BATADV_ATTR_TT_CRC32,
++	BATADV_ATTR_TT_FLAGS,
++};
++
++static int transglobal_callback(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	char c, r, w, i, t;
++	uint8_t last_ttvn;
++	uint32_t crc32;
++	uint32_t flags;
++	uint8_t *addr;
++	uint8_t *orig;
++	uint8_t ttvn;
++	int16_t vid;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_TRANSTABLE_GLOBAL)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, transglobal_mandatory,
++				    ARRAY_SIZE(transglobal_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	addr = nla_data(attrs[BATADV_ATTR_TT_ADDRESS]);
++	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
++	vid = nla_get_u16(attrs[BATADV_ATTR_TT_VID]);
++	ttvn = nla_get_u8(attrs[BATADV_ATTR_TT_TTVN]);
++	last_ttvn = nla_get_u8(attrs[BATADV_ATTR_TT_LAST_TTVN]);
++	crc32 = nla_get_u32(attrs[BATADV_ATTR_TT_CRC32]);
++	flags = nla_get_u32(attrs[BATADV_ATTR_TT_FLAGS]);
++
++	if (opts->read_opt & MULTICAST_ONLY && !(addr[0] & 0x01))
++		return NL_OK;
++
++	if (opts->read_opt & UNICAST_ONLY && (addr[0] & 0x01))
++		return NL_OK;
++
++	c = ' ', r = '.', w = '.', i = '.', t = '.';
++	if (attrs[BATADV_ATTR_FLAG_BEST])
++		c = '*';
++	if (flags & BATADV_TT_CLIENT_ROAM)
++		r = 'R';
++	if (flags & BATADV_TT_CLIENT_WIFI)
++		w = 'W';
++	if (flags & BATADV_TT_CLIENT_ISOLA)
++		i = 'I';
++	if (flags & BATADV_TT_CLIENT_TEMP)
++		t = 'T';
++
++	printf(" %c ", c);
++
++	bat_host = bat_hosts_find_by_mac((char *)addr);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       addr[0], addr[1], addr[2],
++		       addr[3], addr[4], addr[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("%4i [%c%c%c%c] (%3u) ",
++	       BATADV_PRINT_VID(vid), r, w, i, t, ttvn);
++
++	bat_host = bat_hosts_find_by_mac((char *)orig);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       orig[0], orig[1], orig[2],
++		       orig[3], orig[4], orig[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("(%3u) (0x%.8x)\n",
++	       last_ttvn, crc32);
++
++	return NL_OK;
++}
++
++static const int translocal_mandatory[] = {
++	BATADV_ATTR_TT_ADDRESS,
++	BATADV_ATTR_TT_VID,
++	BATADV_ATTR_TT_CRC32,
++	BATADV_ATTR_TT_FLAGS,
++};
++
++static int translocal_callback(struct nl_msg *msg, void *arg)
++{
++	int last_seen_msecs = 0, last_seen_secs = 0;
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	char r, p, n, x, w, i;
++	uint8_t *addr;
++	int16_t vid;
++	uint32_t crc32;
++	uint32_t flags;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_TRANSTABLE_LOCAL)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, translocal_mandatory,
++				    ARRAY_SIZE(translocal_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	addr = nla_data(attrs[BATADV_ATTR_TT_ADDRESS]);
++	vid = nla_get_u16(attrs[BATADV_ATTR_TT_VID]);
++	crc32 = nla_get_u32(attrs[BATADV_ATTR_TT_CRC32]);
++	flags = nla_get_u32(attrs[BATADV_ATTR_TT_FLAGS]);
++	last_seen_msecs = 0, last_seen_secs = 0;
++
++	if (opts->read_opt & MULTICAST_ONLY && !(addr[0] & 0x01))
++		return NL_OK;
++
++	if (opts->read_opt & UNICAST_ONLY && (addr[0] & 0x01))
++		return NL_OK;
++
++	r = '.', p = '.', n = '.', x = '.', w = '.', i = '.';
++	if (flags & BATADV_TT_CLIENT_ROAM)
++		r = 'R';
++	if (flags & BATADV_TT_CLIENT_NEW)
++		n = 'N';
++	if (flags & BATADV_TT_CLIENT_PENDING)
++		x = 'X';
++	if (flags & BATADV_TT_CLIENT_WIFI)
++		w = 'W';
++	if (flags & BATADV_TT_CLIENT_ISOLA)
++		i = 'I';
++
++	if (flags & BATADV_TT_CLIENT_NOPURGE)  {
++		p = 'P';
++	} else {
++		if (!attrs[BATADV_ATTR_LAST_SEEN_MSECS]) {
++			fputs("Received invalid data from kernel.\n", stderr);
++			exit(1);
++		}
++
++		last_seen_msecs = nla_get_u32(
++			attrs[BATADV_ATTR_LAST_SEEN_MSECS]);
++		last_seen_secs = last_seen_msecs / 1000;
++		last_seen_msecs = last_seen_msecs % 1000;
++	}
++
++	bat_host = bat_hosts_find_by_mac((char *)addr);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       addr[0], addr[1], addr[2],
++		       addr[3], addr[4], addr[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("%4i [%c%c%c%c%c%c] %3u.%03u   (0x%.8x)\n",
++	       BATADV_PRINT_VID(vid), r, p, n, x, w, i,
++	       last_seen_secs, last_seen_msecs,
++	       crc32);
++
++	return NL_OK;
++}
++
++static const int gateways_mandatory[] = {
++	BATADV_ATTR_ORIG_ADDRESS,
++	BATADV_ATTR_TQ,
++	BATADV_ATTR_ROUTER,
++	BATADV_ATTR_HARD_IFNAME,
++	BATADV_ATTR_BANDWIDTH_DOWN,
++	BATADV_ATTR_BANDWIDTH_UP,
++};
++
++static int gateways_callback(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	const char *primary_if;
++	uint32_t bandwidth_down;
++	uint32_t bandwidth_up;
++	uint8_t *router;
++	uint8_t *orig;
++	char c = ' ';
++	uint8_t tq;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_GATEWAYS)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, gateways_mandatory,
++				    ARRAY_SIZE(gateways_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	if (attrs[BATADV_ATTR_FLAG_BEST])
++		c = '*';
++
++	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
++	tq = nla_get_u8(attrs[BATADV_ATTR_TQ]);
++	router = nla_data(attrs[BATADV_ATTR_ROUTER]);
++	primary_if = nla_get_string(attrs[BATADV_ATTR_HARD_IFNAME]);
++	bandwidth_down = nla_get_u32(attrs[BATADV_ATTR_BANDWIDTH_DOWN]);
++	bandwidth_up = nla_get_u32(attrs[BATADV_ATTR_BANDWIDTH_UP]);
++
++	printf("%c ", c);
++
++	bat_host = bat_hosts_find_by_mac((char *)orig);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       orig[0], orig[1], orig[2],
++		       orig[3], orig[4], orig[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("(%3i) ", tq);
++
++	bat_host = bat_hosts_find_by_mac((char *)router);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       router[0], router[1], router[2],
++		       router[3], router[4], router[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("[%10s]: %u.%u/%u.%u MBit\n",
++	       primary_if, bandwidth_down / 10, bandwidth_down % 10,
++	       bandwidth_up / 10, bandwidth_up % 10);
++
++	return NL_OK;
++}
++
++static const int bla_claim_mandatory[] = {
++	BATADV_ATTR_BLA_ADDRESS,
++	BATADV_ATTR_BLA_VID,
++	BATADV_ATTR_BLA_BACKBONE,
++	BATADV_ATTR_BLA_CRC,
++};
++
++static int bla_claim_callback(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	uint16_t backbone_crc;
++	uint8_t *backbone;
++	uint8_t *client;
++	uint16_t vid;
++	char c = ' ';
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_BLA_CLAIM)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, bla_claim_mandatory,
++				       ARRAY_SIZE(bla_claim_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	if (attrs[BATADV_ATTR_BLA_OWN])
++		c = '*';
++
++	client = nla_data(attrs[BATADV_ATTR_BLA_ADDRESS]);
++	vid = nla_get_u16(attrs[BATADV_ATTR_BLA_VID]);
++	backbone = nla_data(attrs[BATADV_ATTR_BLA_BACKBONE]);
++	backbone_crc = nla_get_u16(attrs[BATADV_ATTR_BLA_CRC]);
++
++	bat_host = bat_hosts_find_by_mac((char *)client);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       client[0], client[1], client[2],
++		       client[3], client[4], client[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("on %5d by ", BATADV_PRINT_VID(vid));
++
++	bat_host = bat_hosts_find_by_mac((char *)backbone);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       backbone[0], backbone[1], backbone[2],
++		       backbone[3], backbone[4], backbone[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("[%c] (0x%04x)\n", c, backbone_crc);
++
++	return NL_OK;
++}
++
++static int netlink_print_common(char *mesh_iface, char *orig_iface,
++				int read_opt, float orig_timeout,
++				float watch_interval, const char *header,
++				uint8_t nl_cmd, nl_recvmsg_msg_cb_t callback)
++{
++	struct print_opts opts = {
++		.read_opt = read_opt,
++		.orig_timeout = orig_timeout,
++		.watch_interval = watch_interval
++	};
++	int hardifindex = 0;
++	struct nl_sock *sock;
++	struct nl_msg *msg;
++	struct nl_cb *cb;
++	int ifindex;
++	int family;
++
++	sock = nl_socket_alloc();
++	genl_connect(sock);
++
++	family = genl_ctrl_resolve(sock, BATADV_NL_NAME);
++	if (family < 0)
++		return -EOPNOTSUPP;
++
++	ifindex = if_nametoindex(mesh_iface);
++	if (!ifindex) {
++		fprintf(stderr, "Interface %s is unknown\n", mesh_iface);
++		return -ENODEV;
++	}
++
++	if (orig_iface) {
++		hardifindex = if_nametoindex(orig_iface);
++		if (!hardifindex) {
++			fprintf(stderr, "Interface %s is unknown\n",
++				orig_iface);
++			return -ENODEV;
++		}
++	}
++
++	bat_hosts_init(read_opt);
++
++	cb = nl_cb_alloc(NL_CB_DEFAULT);
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, callback, &opts);
++	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, stop_callback, NULL);
++	nl_cb_err(cb, NL_CB_CUSTOM, print_error, NULL);
++
++	do {
++		if (read_opt & CLR_CONT_READ)
++			/* clear screen, set cursor back to 0,0 */
++			printf("\033[2J\033[0;0f");
++
++		if (!(read_opt & SKIP_HEADER)) {
++			netlink_print_info(ifindex, nl_cmd, 0);
++			if (header)
++				printf("%s", header);
++		}
++
++		msg = nlmsg_alloc();
++		genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0,
++			    NLM_F_DUMP, nl_cmd, 1);
++
++		nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, ifindex);
++		if (hardifindex)
++			nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++				    hardifindex);
++
++		nl_send_auto_complete(sock, msg);
++
++		nlmsg_free(msg);
++
++		last_err = 0;
++		nl_recvmsgs(sock, cb);
++		if (!last_err && read_opt & (CONT_READ|CLR_CONT_READ))
++			usleep(1000000 * watch_interval);
++
++	} while (!last_err && read_opt & (CONT_READ|CLR_CONT_READ));
++
++	bat_hosts_free();
++
++	nl_socket_free(sock);
++
++	return last_err;
++}
++
++int netlink_print_originators(char *mesh_iface, char *orig_iface,
++			      int read_opts, float orig_timeout,
++			      float watch_interval)
++{
++	char *header;
++	int ifindex;
++
++	ifindex = if_nametoindex(mesh_iface);
++	if (!ifindex) {
++		fprintf(stderr, "Interface %s is unknown\n", mesh_iface);
++		return -ENODEV;
++	}
++
++	netlink_print_info(ifindex, BATADV_CMD_GET_ORIGINATORS, PARSE_ONLY);
++
++	if (strlen(algo_name_buf) == 0)
++		return -EINVAL;
++
++	if (!strcmp("BATMAN_IV", algo_name_buf))
++		header = "   Originator        last-seen (#/255) Nexthop           [outgoingIF]\n";
++	if (!strcmp("BATMAN_V", algo_name_buf))
++		header = "   Originator        last-seen ( throughput)  Nexthop           [outgoingIF]\n";
++
++	if (!header)
++		return -EINVAL;
++
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval, header,
++				    BATADV_CMD_GET_ORIGINATORS,
++				    originators_callback);
++}
++
++int netlink_print_neighbors(char *mesh_iface, char *orig_iface, int read_opts,
++			    float orig_timeout,
++			    float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "IF             Neighbor              last-seen\n",
++				    BATADV_CMD_GET_NEIGHBORS,
++				    neighbors_callback);
++}
++
++int netlink_print_transglobal(char *mesh_iface, char *orig_iface,
++			      int read_opts, float orig_timeout,
++			      float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "   Client             VID Flags Last ttvn     Via        ttvn  (CRC       )\n",
++				    BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++				    transglobal_callback);
++}
++
++int netlink_print_translocal(char *mesh_iface, char *orig_iface, int read_opts,
++			     float orig_timeout,
++			     float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "Client             VID Flags    Last seen (CRC       )\n",
++				    BATADV_CMD_GET_TRANSTABLE_LOCAL,
++				    translocal_callback);
++}
++
++int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opts,
++			   float orig_timeout,
++			   float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "    Router           TQ      Next Hop        outgoingIf   Bandwidth\n",
++				    BATADV_CMD_GET_GATEWAYS,
++				    gateways_callback);
++}
++
++int netlink_print_bla_claim(char *mesh_iface, char *orig_iface, int read_opts,
++			    float orig_timeout,
++			    float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "Client               VID      Originator        [o] (CRC   )\n",
++				    BATADV_CMD_GET_BLA_CLAIM,
++				    bla_claim_callback);
++}
+diff --git a/netlink.h b/netlink.h
+index 0a4d3dd..69f0958 100644
+--- a/netlink.h
++++ b/netlink.h
+@@ -1,7 +1,7 @@
+ /*
+  * Copyright (C) 2009-2016  B.A.T.M.A.N. contributors:
+  *
+- * Marek Lindner <mareklindner@neomailbox.ch>
++ * Marek Lindner <mareklindner@neomailbox.ch>, Andrew Lunn <andrew@lunn.ch>
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of version 2 of the GNU General Public
+@@ -25,6 +25,22 @@
+ #include <netlink/genl/genl.h>
+ #include <netlink/genl/ctrl.h>
+ 
++int netlink_print_routing_algos(void);
++int netlink_print_originators(char *mesh_iface, char *orig_iface, int read_opt,
++			      float orig_timeout, float watch_interval);
++int netlink_print_neighbors(char *mesh_iface, char *orig_iface, int read_opt,
++			    float orig_timeout, float watch_interval);
++int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opt,
++			   float orig_timeout, float watch_interval);
++int netlink_print_transglobal(char *mesh_iface, char *orig_iface, int read_opt,
++			      float orig_timeout, float watch_interval);
++int netlink_print_translocal(char *mesh_iface, char *orig_iface, int read_opt,
++			     float orig_timeout, float watch_interval);
++int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opt,
++			   float orig_timeout, float watch_interval);
++int netlink_print_bla_claim(char *mesh_iface, char *orig_iface, int read_opt,
++			    float orig_timeout, float watch_interval);
++
+ extern struct nla_policy batadv_netlink_policy[];
+ 
+ #endif /* _BATCTL_NETLINK_H */
diff --git a/batctl/patches/0012-batctl-add-netlink-dump-function-for-backbone-tables.patch b/batctl/patches/0012-batctl-add-netlink-dump-function-for-backbone-tables.patch
new file mode 100644
index 0000000..f4bc485
--- /dev/null
+++ b/batctl/patches/0012-batctl-add-netlink-dump-function-for-backbone-tables.patch
@@ -0,0 +1,139 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Mon, 18 Jul 2016 12:12:02 +0200
+Subject: [PATCH] batctl: add netlink dump function for backbone tables
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ debug.c   |  1 +
+ netlink.c | 79 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ netlink.h |  2 ++
+ 3 files changed, 82 insertions(+)
+
+diff --git a/debug.c b/debug.c
+index 46f03da..ddabbfb 100644
+--- a/debug.c
++++ b/debug.c
+@@ -79,6 +79,7 @@ const struct debug_table_data batctl_debug_tables[BATCTL_TABLE_NUM] = {
+ 		.opt_short = "bbt",
+ 		.debugfs_name = "bla_backbone_table",
+ 		.header_lines = 2,
++		.netlink_fn = netlink_print_bla_backbone,
+ 	},
+ 	{
+ 		.opt_long = "dat_cache",
+diff --git a/netlink.c b/netlink.c
+index b87964a..1e406a9 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -226,6 +226,7 @@ static int info_callback(struct nl_msg *msg, void *arg)
+ 				if (ret < 0)
+ 					extra_info = NULL;
+ 				break;
++			case BATADV_CMD_GET_BLA_BACKBONE:
+ 			case BATADV_CMD_GET_BLA_CLAIM:
+ 				ret = asprintf(&extra_info, ", group id: 0x%04x",
+ 					       bla_group_id);
+@@ -947,6 +948,74 @@ static int bla_claim_callback(struct nl_msg *msg, void *arg)
+ 	return NL_OK;
+ }
+ 
++static const int bla_backbone_mandatory[] = {
++	BATADV_ATTR_BLA_VID,
++	BATADV_ATTR_BLA_BACKBONE,
++	BATADV_ATTR_BLA_CRC,
++	BATADV_ATTR_LAST_SEEN_MSECS,
++};
++
++static int bla_backbone_callback(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	int last_seen_msecs, last_seen_secs;
++	struct print_opts *opts = arg;
++	struct bat_host *bat_host;
++	struct genlmsghdr *ghdr;
++	uint16_t backbone_crc;
++	uint8_t *backbone;
++	uint16_t vid;
++
++	if (!genlmsg_valid_hdr(nlh, 0)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_BLA_BACKBONE)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		fputs("Received invalid data from kernel.\n", stderr);
++		exit(1);
++	}
++
++	if (missing_mandatory_attrs(attrs, bla_backbone_mandatory,
++				       ARRAY_SIZE(bla_backbone_mandatory))) {
++		fputs("Missing attributes from kernel\n", stderr);
++		exit(1);
++	}
++
++	/* don't show own backbones */
++	if (attrs[BATADV_ATTR_BLA_OWN])
++		return NL_OK;
++
++	vid = nla_get_u16(attrs[BATADV_ATTR_BLA_VID]);
++	backbone = nla_data(attrs[BATADV_ATTR_BLA_BACKBONE]);
++	backbone_crc = nla_get_u16(attrs[BATADV_ATTR_BLA_CRC]);
++
++	last_seen_msecs = nla_get_u32(attrs[BATADV_ATTR_LAST_SEEN_MSECS]);
++	last_seen_secs = last_seen_msecs / 1000;
++	last_seen_msecs = last_seen_msecs % 1000;
++
++	bat_host = bat_hosts_find_by_mac((char *)backbone);
++	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
++		printf("%02x:%02x:%02x:%02x:%02x:%02x ",
++		       backbone[0], backbone[1], backbone[2],
++		       backbone[3], backbone[4], backbone[5]);
++	else
++		printf("%17s ", bat_host->name);
++
++	printf("on %5d %4i.%03is (0x%04x)\n",
++	       BATADV_PRINT_VID(vid), last_seen_secs, last_seen_msecs,
++	       backbone_crc);
++
++	return NL_OK;
++}
++
+ static int netlink_print_common(char *mesh_iface, char *orig_iface,
+ 				int read_opt, float orig_timeout,
+ 				float watch_interval, const char *header,
+@@ -1117,3 +1186,13 @@ int netlink_print_bla_claim(char *mesh_iface, char *orig_iface, int read_opts,
+ 				    BATADV_CMD_GET_BLA_CLAIM,
+ 				    bla_claim_callback);
+ }
++
++int netlink_print_bla_backbone(char *mesh_iface, char *orig_iface, int read_opts,
++			       float orig_timeout, float watch_interval)
++{
++	return netlink_print_common(mesh_iface, orig_iface, read_opts,
++				    orig_timeout, watch_interval,
++				    "Originator           VID   last seen (CRC   )\n",
++				    BATADV_CMD_GET_BLA_BACKBONE,
++				    bla_backbone_callback);
++}
+diff --git a/netlink.h b/netlink.h
+index 69f0958..5ff7ace 100644
+--- a/netlink.h
++++ b/netlink.h
+@@ -40,6 +40,8 @@ int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opt,
+ 			   float orig_timeout, float watch_interval);
+ int netlink_print_bla_claim(char *mesh_iface, char *orig_iface, int read_opt,
+ 			    float orig_timeout, float watch_interval);
++int netlink_print_bla_backbone(char *mesh_iface, char *orig_iface, int read_opt,
++			       float orig_timeout, float watch_interval);
+ 
+ extern struct nla_policy batadv_netlink_policy[];
+ 
diff --git a/batctl/patches/0013-batctl-add-netlink-dump-support-for-B.A.T.M.A.N.-V-g.patch b/batctl/patches/0013-batctl-add-netlink-dump-support-for-B.A.T.M.A.N.-V-g.patch
new file mode 100644
index 0000000..1e934bc
--- /dev/null
+++ b/batctl/patches/0013-batctl-add-netlink-dump-support-for-B.A.T.M.A.N.-V-g.patch
@@ -0,0 +1,87 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 18 Jul 2016 12:12:03 +0200
+Subject: [PATCH] batctl: add netlink dump support for B.A.T.M.A.N. V gateways
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ netlink.c | 36 +++++++++++++++++++++++++++++++-----
+ 1 file changed, 31 insertions(+), 5 deletions(-)
+
+diff --git a/netlink.c b/netlink.c
+index 1e406a9..43b680e 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -794,7 +794,6 @@ static int translocal_callback(struct nl_msg *msg, void *arg)
+ 
+ static const int gateways_mandatory[] = {
+ 	BATADV_ATTR_ORIG_ADDRESS,
+-	BATADV_ATTR_TQ,
+ 	BATADV_ATTR_ROUTER,
+ 	BATADV_ATTR_HARD_IFNAME,
+ 	BATADV_ATTR_BANDWIDTH_DOWN,
+@@ -811,6 +810,7 @@ static int gateways_callback(struct nl_msg *msg, void *arg)
+ 	const char *primary_if;
+ 	uint32_t bandwidth_down;
+ 	uint32_t bandwidth_up;
++	uint32_t throughput;
+ 	uint8_t *router;
+ 	uint8_t *orig;
+ 	char c = ' ';
+@@ -842,7 +842,6 @@ static int gateways_callback(struct nl_msg *msg, void *arg)
+ 		c = '*';
+ 
+ 	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
+-	tq = nla_get_u8(attrs[BATADV_ATTR_TQ]);
+ 	router = nla_data(attrs[BATADV_ATTR_ROUTER]);
+ 	primary_if = nla_get_string(attrs[BATADV_ATTR_HARD_IFNAME]);
+ 	bandwidth_down = nla_get_u32(attrs[BATADV_ATTR_BANDWIDTH_DOWN]);
+@@ -858,7 +857,13 @@ static int gateways_callback(struct nl_msg *msg, void *arg)
+ 	else
+ 		printf("%17s ", bat_host->name);
+ 
+-	printf("(%3i) ", tq);
++	if (attrs[BATADV_ATTR_THROUGHPUT]) {
++		throughput = nla_get_u32(attrs[BATADV_ATTR_THROUGHPUT]);
++		printf("(%9u.%1u) ", throughput / 10, throughput % 10);
++	} else if (attrs[BATADV_ATTR_TQ]) {
++		tq = nla_get_u8(attrs[BATADV_ATTR_TQ]);
++		printf("(%3i) ", tq);
++	}
+ 
+ 	bat_host = bat_hosts_find_by_mac((char *)router);
+ 	if (!(opts->read_opt & USE_BAT_HOSTS) || !bat_host)
+@@ -1168,10 +1173,31 @@ int netlink_print_translocal(char *mesh_iface, char *orig_iface, int read_opts,
+ int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opts,
+ 			   float orig_timeout,
+ 			   float watch_interval)
+-{
++{	char *header;
++	int ifindex;
++
++	ifindex = if_nametoindex(mesh_iface);
++	if (!ifindex) {
++		fprintf(stderr, "Interface %s is unknown\n", mesh_iface);
++		return -ENODEV;
++	}
++
++	netlink_print_info(ifindex, BATADV_CMD_GET_ORIGINATORS, PARSE_ONLY);
++
++	if (strlen(algo_name_buf) == 0)
++		return -EINVAL;
++
++	if (!strcmp("BATMAN_IV", algo_name_buf))
++		header = "  Router            ( TQ) Next Hop          [outgoingIf]  Bandwidth\n";
++	if (!strcmp("BATMAN_V", algo_name_buf))
++		header = "  Router            ( throughput) Next Hop          [outgoingIf]  Bandwidth\n";
++
++	if (!header)
++		return -EINVAL;
++
+ 	return netlink_print_common(mesh_iface, orig_iface, read_opts,
+ 				    orig_timeout, watch_interval,
+-				    "    Router           TQ      Next Hop        outgoingIf   Bandwidth\n",
++				    header,
+ 				    BATADV_CMD_GET_GATEWAYS,
+ 				    gateways_callback);
+ }
diff --git a/batctl/patches/0014-batctl-Import-alfred-version-of-debugfs.patch b/batctl/patches/0014-batctl-Import-alfred-version-of-debugfs.patch
new file mode 100644
index 0000000..cb9f8be
--- /dev/null
+++ b/batctl/patches/0014-batctl-Import-alfred-version-of-debugfs.patch
@@ -0,0 +1,101 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 18 Jul 2016 12:12:04 +0200
+Subject: [PATCH] batctl: Import alfred version of debugfs.*
+
+The alfred version of debugfs.c and debugfs.h contains several cleanups
+regarding error message output, removal of unused declarations and usage of
+const buffers.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ debugfs.c | 17 ++++++++++-------
+ debugfs.h |  4 +---
+ 2 files changed, 11 insertions(+), 10 deletions(-)
+
+diff --git a/debugfs.c b/debugfs.c
+index 3c58195..fc39322 100644
+--- a/debugfs.c
++++ b/debugfs.c
+@@ -33,6 +33,9 @@
+ static int debugfs_premounted;
+ static char debugfs_mountpoint[MAX_PATH+1];
+ 
++static const char *debugfs_find_mountpoint(void);
++static int debugfs_valid_mountpoint(const char *debugfs);
++
+ static const char *debugfs_known_mountpoints[] = {
+ 	"/sys/kernel/debug/",
+ 	"/debug/",
+@@ -40,7 +43,8 @@ static const char *debugfs_known_mountpoints[] = {
+ };
+ 
+ /* construct a full path to a debugfs element */
+-int debugfs_make_path(const char *fmt, char *mesh_iface, char *buffer, int size)
++int debugfs_make_path(const char *fmt, const char *mesh_iface, char *buffer,
++		      int size)
+ {
+ 	if (strlen(debugfs_mountpoint) == 0) {
+ 		buffer[0] = '\0';
+@@ -53,14 +57,14 @@ int debugfs_make_path(const char *fmt, char *mesh_iface, char *buffer, int size)
+ static int debugfs_found;
+ 
+ /* find the path to the mounted debugfs */
+-const char *debugfs_find_mountpoint(void)
++static const char *debugfs_find_mountpoint(void)
+ {
+ 	const char **ptr;
+ 	char type[100];
+ 	FILE *fp;
+ 
+ 	if (debugfs_found)
+-		return (const char *) debugfs_mountpoint;
++		return (const char *)debugfs_mountpoint;
+ 
+ 	ptr = debugfs_known_mountpoints;
+ 	while (*ptr) {
+@@ -68,7 +72,7 @@ const char *debugfs_find_mountpoint(void)
+ 			debugfs_found = 1;
+ 			strncpy(debugfs_mountpoint, *ptr,
+ 				sizeof(debugfs_mountpoint));
+-			debugfs_mountpoint[sizeof(debugfs_mountpoint) - 1] = '\0';
++			debugfs_mountpoint[sizeof(debugfs_mountpoint) - 1] = 0;
+ 			return debugfs_mountpoint;
+ 		}
+ 		ptr++;
+@@ -77,8 +81,7 @@ const char *debugfs_find_mountpoint(void)
+ 	/* give up and parse /proc/mounts */
+ 	fp = fopen("/proc/mounts", "r");
+ 	if (fp == NULL) {
+-		fprintf(stderr, "Error - can't open /proc/mounts for read: %s\n",
+-		       strerror(errno));
++		perror("Error - can't open /proc/mounts for read");
+ 		return NULL;
+ 	}
+ 
+@@ -101,7 +104,7 @@ const char *debugfs_find_mountpoint(void)
+ 
+ /* verify that a mountpoint is actually a debugfs instance */
+ 
+-int debugfs_valid_mountpoint(const char *debugfs)
++static int debugfs_valid_mountpoint(const char *debugfs)
+ {
+ 	struct statfs st_fs;
+ 
+diff --git a/debugfs.h b/debugfs.h
+index e608902..b4dc6bb 100644
+--- a/debugfs.h
++++ b/debugfs.h
+@@ -30,11 +30,9 @@
+ # define STR(x) _STR(x)
+ #endif
+ 
+-extern const char *debugfs_find_mountpoint(void);
+-extern int debugfs_valid_mountpoint(const char *debugfs);
+ extern int debugfs_valid_entry(const char *path);
+ extern char *debugfs_mount(const char *mountpoint);
+-extern int debugfs_make_path(const char *fmt, char *mesh_iface,
++extern int debugfs_make_path(const char *fmt, const char *mesh_iface,
+ 			     char *buffer, int size);
+ 
+ #endif /* __DEBUGFS_H__ */
diff --git a/batctl/patches/0015-batctl-Split-translate_mac-from-debugfs-backend.patch b/batctl/patches/0015-batctl-Split-translate_mac-from-debugfs-backend.patch
new file mode 100644
index 0000000..048e3ec
--- /dev/null
+++ b/batctl/patches/0015-batctl-Split-translate_mac-from-debugfs-backend.patch
@@ -0,0 +1,134 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 18 Jul 2016 12:12:05 +0200
+Subject: [PATCH] batctl: Split translate_mac from debugfs backend
+
+The debugfs tables cannot be used by the batctl in network namespaces.
+These have to use netlink. Thus the translate_mac should be less tightly
+linked to the debugfs tables to implement optional netlink support.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ functions.c | 46 +++++++++++++++++++++++++++++++++++-----------
+ functions.h |  3 ++-
+ 2 files changed, 37 insertions(+), 12 deletions(-)
+
+diff --git a/functions.c b/functions.c
+index 5b76062..f994ced 100644
+--- a/functions.c
++++ b/functions.c
+@@ -26,6 +26,7 @@
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <unistd.h>
++#include <stdbool.h>
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <string.h>
+@@ -371,7 +372,9 @@ out:
+ 	return res;
+ }
+ 
+-struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac)
++static int translate_mac_debugfs(const char *mesh_iface,
++				 const struct ether_addr *mac,
++				 struct ether_addr *mac_out)
+ {
+ 	enum {
+ 		tg_start,
+@@ -381,26 +384,23 @@ struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac)
+ 	} pos;
+ 	char full_path[MAX_PATH+1];
+ 	char *debugfs_mnt;
+-	static struct ether_addr in_mac;
+-	struct ether_addr *mac_result, *mac_tmp;
++	struct ether_addr *mac_tmp;
+ 	FILE *f = NULL;
+ 	size_t len = 0;
+ 	char *line = NULL;
+ 	char *input, *saveptr, *token;
+ 	int line_invalid;
+-
+-	memcpy(&in_mac, mac, sizeof(in_mac));
+-	mac_result = &in_mac;
++	bool found = false;
+ 
+ 	debugfs_mnt = debugfs_mount(NULL);
+ 	if (!debugfs_mnt)
+-		goto out;
++		return -EOPNOTSUPP;
+ 
+ 	debugfs_make_path(DEBUG_BATIF_PATH_FMT "/" DEBUG_TRANSTABLE_GLOBAL, mesh_iface, full_path, sizeof(full_path));
+ 
+ 	f = fopen(full_path, "r");
+ 	if (!f)
+-		goto out;
++		return -EOPNOTSUPP;
+ 
+ 	while (getline(&line, &len, f) != -1) {
+ 		line_invalid = 0;
+@@ -419,8 +419,8 @@ struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac)
+ 				break;
+ 			case tg_mac:
+ 				mac_tmp = ether_aton(token);
+-				if (!mac_tmp || memcmp(mac_tmp, &in_mac,
+-						       sizeof(in_mac)) != 0)
++				if (!mac_tmp || memcmp(mac_tmp, mac,
++						       ETH_ALEN) != 0)
+ 					line_invalid = 1;
+ 				else
+ 					pos = tg_via;
+@@ -434,7 +434,8 @@ struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac)
+ 				if (!mac_tmp) {
+ 					line_invalid = 1;
+ 				} else {
+-					mac_result = mac_tmp;
++					memcpy(mac_out, mac_tmp, ETH_ALEN);
++					found = true;
+ 					goto out;
+ 				}
+ 				break;
+@@ -449,6 +450,29 @@ out:
+ 	if (f)
+ 		fclose(f);
+ 	free(line);
++
++	if (found)
++		return 0;
++	else
++		return -ENOENT;
++}
++
++struct ether_addr *translate_mac(const char *mesh_iface,
++				 const struct ether_addr *mac)
++{
++	struct ether_addr in_mac;
++	static struct ether_addr out_mac;
++	struct ether_addr *mac_result;
++
++	/* input mac has to be copied because it could be in the shared
++	 * ether_aton buffer
++	 */
++	memcpy(&in_mac, mac, sizeof(in_mac));
++	memcpy(&out_mac, mac, sizeof(out_mac));
++	mac_result = &out_mac;
++
++	translate_mac_debugfs(mesh_iface, &in_mac, mac_result);
++
+ 	return mac_result;
+ }
+ 
+diff --git a/functions.h b/functions.h
+index 2d29d52..1f311ca 100644
+--- a/functions.h
++++ b/functions.h
+@@ -40,7 +40,8 @@ int read_file(const char *dir, const char *path, int read_opt,
+ 	      float orig_timeout, float watch_interval, size_t header_lines);
+ int write_file(const char *dir, const char *fname, const char *arg1,
+ 	       const char *arg2);
+-struct ether_addr *translate_mac(char *mesh_iface, struct ether_addr *mac);
++struct ether_addr *translate_mac(const char *mesh_iface,
++				 const struct ether_addr *mac);
+ struct ether_addr *resolve_mac(const char *asc);
+ int vlan_get_link(const char *ifname, char **parent);
+ 
diff --git a/batctl/patches/0016-batctl-Translate-mac-addresses-via-netlink.patch b/batctl/patches/0016-batctl-Translate-mac-addresses-via-netlink.patch
new file mode 100644
index 0000000..065d62e
--- /dev/null
+++ b/batctl/patches/0016-batctl-Translate-mac-addresses-via-netlink.patch
@@ -0,0 +1,281 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 18 Jul 2016 12:12:06 +0200
+Subject: [PATCH] batctl: Translate mac addresses via netlink
+
+The debugfs entries are only available on the main network namespace. All
+other network namespaces have to fall back to netlink to read the global
+translation table.
+
+batctl has therefore try to access the translation table via netlink and
+try to fall back to the debugfs table in case the batman-adv module doesn't
+support BATADV_CMD_GET_TRANSTABLE_GLOBAL.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ functions.c |   6 +-
+ netlink.c   | 185 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ netlink.h   |   5 ++
+ 3 files changed, 195 insertions(+), 1 deletion(-)
+
+diff --git a/functions.c b/functions.c
+index f994ced..d236d64 100644
+--- a/functions.c
++++ b/functions.c
+@@ -463,6 +463,7 @@ struct ether_addr *translate_mac(const char *mesh_iface,
+ 	struct ether_addr in_mac;
+ 	static struct ether_addr out_mac;
+ 	struct ether_addr *mac_result;
++	int ret;
+ 
+ 	/* input mac has to be copied because it could be in the shared
+ 	 * ether_aton buffer
+@@ -471,7 +472,10 @@ struct ether_addr *translate_mac(const char *mesh_iface,
+ 	memcpy(&out_mac, mac, sizeof(out_mac));
+ 	mac_result = &out_mac;
+ 
+-	translate_mac_debugfs(mesh_iface, &in_mac, mac_result);
++	ret = translate_mac_netlink(mesh_iface, &in_mac, mac_result);
++
++	if (ret == -EOPNOTSUPP)
++		translate_mac_debugfs(mesh_iface, &in_mac, mac_result);
+ 
+ 	return mac_result;
+ }
+diff --git a/netlink.c b/netlink.c
+index 43b680e..423fc9b 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -22,6 +22,7 @@
+ #include "netlink.h"
+ #include "main.h"
+ 
++#include <stdbool.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <unistd.h>
+@@ -43,6 +44,12 @@
+ 
+ #define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
+ 
++#ifndef container_of
++#define container_of(ptr, type, member) __extension__ ({ \
++	const __typeof__(((type *)0)->member) *__pmember = (ptr); \
++	(type *)((char *)__pmember - offsetof(type, member)); })
++#endif
++
+ struct print_opts {
+ 	int read_opt;
+ 	float orig_timeout;
+@@ -50,6 +57,10 @@ struct print_opts {
+ 	uint8_t nl_cmd;
+ };
+ 
++struct nlquery_opts {
++	int err;
++};
++
+ struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_VERSION]		= { .type = NLA_STRING },
+ 	[BATADV_ATTR_ALGO_NAME]		= { .type = NLA_STRING },
+@@ -1222,3 +1233,177 @@ int netlink_print_bla_backbone(char *mesh_iface, char *orig_iface, int read_opts
+ 				    BATADV_CMD_GET_BLA_BACKBONE,
+ 				    bla_backbone_callback);
+ }
++
++static int nlquery_error_cb(struct sockaddr_nl *nla __unused,
++			    struct nlmsgerr *nlerr, void *arg)
++{
++	struct nlquery_opts *query_opts = arg;
++
++	query_opts->err = nlerr->error;
++
++	return NL_STOP;
++}
++
++static int nlquery_stop_cb(struct nl_msg *msg, void *arg)
++{
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct nlquery_opts *query_opts = arg;
++	int *error = nlmsg_data(nlh);
++
++	if (*error)
++		query_opts->err = *error;
++
++	return NL_STOP;
++}
++
++static int netlink_query_common(const char *mesh_iface, uint8_t nl_cmd,
++				nl_recvmsg_msg_cb_t callback,
++				struct nlquery_opts *query_opts)
++{
++	struct nl_sock *sock;
++	struct nl_msg *msg;
++	struct nl_cb *cb;
++	int ifindex;
++	int family;
++	int ret;
++
++	query_opts->err = 0;
++
++	sock = nl_socket_alloc();
++	if (!sock)
++		return -ENOMEM;
++
++	ret = genl_connect(sock);
++	if (ret < 0) {
++		query_opts->err = ret;
++		goto err_free_sock;
++	}
++
++	family = genl_ctrl_resolve(sock, BATADV_NL_NAME);
++	if (family < 0) {
++		query_opts->err = -EOPNOTSUPP;
++		goto err_free_sock;
++	}
++
++	ifindex = if_nametoindex(mesh_iface);
++	if (!ifindex) {
++		query_opts->err = -ENODEV;
++		goto err_free_sock;
++	}
++
++	cb = nl_cb_alloc(NL_CB_DEFAULT);
++	if (!cb) {
++		query_opts->err = -ENOMEM;
++		goto err_free_sock;
++	}
++
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, callback, query_opts);
++	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, nlquery_stop_cb, query_opts);
++	nl_cb_err(cb, NL_CB_CUSTOM, nlquery_error_cb, query_opts);
++
++	msg = nlmsg_alloc();
++	if (!msg) {
++		query_opts->err = -ENOMEM;
++		goto err_free_cb;
++	}
++
++	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_DUMP,
++		    nl_cmd, 1);
++
++	nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, ifindex);
++	nl_send_auto_complete(sock, msg);
++	nlmsg_free(msg);
++
++	nl_recvmsgs(sock, cb);
++
++err_free_cb:
++	nl_cb_put(cb);
++err_free_sock:
++	nl_socket_free(sock);
++
++	return query_opts->err;
++}
++
++static const int translate_mac_netlink_mandatory[] = {
++	BATADV_ATTR_TT_ADDRESS,
++	BATADV_ATTR_ORIG_ADDRESS,
++};
++
++struct translate_mac_netlink_opts {
++	struct ether_addr mac;
++	bool found;
++	struct nlquery_opts query_opts;
++};
++
++static int translate_mac_netlink_cb(struct nl_msg *msg, void *arg)
++{
++	struct nlattr *attrs[BATADV_ATTR_MAX+1];
++	struct nlmsghdr *nlh = nlmsg_hdr(msg);
++	struct nlquery_opts *query_opts = arg;
++	struct translate_mac_netlink_opts *opts;
++	struct genlmsghdr *ghdr;
++	uint8_t *addr;
++	uint8_t *orig;
++
++	opts = container_of(query_opts, struct translate_mac_netlink_opts,
++			    query_opts);
++
++	if (!genlmsg_valid_hdr(nlh, 0))
++		return NL_OK;
++
++	ghdr = nlmsg_data(nlh);
++
++	if (ghdr->cmd != BATADV_CMD_GET_TRANSTABLE_GLOBAL)
++		return NL_OK;
++
++	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
++		      genlmsg_len(ghdr), batadv_netlink_policy)) {
++		return NL_OK;
++	}
++
++	if (missing_mandatory_attrs(attrs, translate_mac_netlink_mandatory,
++				    ARRAY_SIZE(translate_mac_netlink_mandatory)))
++		return NL_OK;
++
++	addr = nla_data(attrs[BATADV_ATTR_TT_ADDRESS]);
++	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
++
++	if (!attrs[BATADV_ATTR_FLAG_BEST])
++		return NL_OK;
++
++	if (memcmp(&opts->mac, addr, ETH_ALEN) != 0)
++		return NL_OK;
++
++	memcpy(&opts->mac, orig, ETH_ALEN);
++	opts->found = true;
++	opts->query_opts.err = 0;
++
++	return NL_STOP;
++}
++
++int translate_mac_netlink(const char *mesh_iface, const struct ether_addr *mac,
++			  struct ether_addr *mac_out)
++{
++	struct translate_mac_netlink_opts opts = {
++		.found = false,
++		.query_opts = {
++			.err = 0,
++		},
++	};
++	int ret;
++
++	memcpy(&opts.mac, mac, ETH_ALEN);
++
++	ret = netlink_query_common(mesh_iface,
++				   BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++			           translate_mac_netlink_cb, &opts.query_opts);
++	if (ret < 0)
++		return ret;
++
++	if (!opts.found)
++		return -ENOENT;
++
++	memcpy(mac_out, &opts.mac, ETH_ALEN);
++
++	return 0;
++}
+diff --git a/netlink.h b/netlink.h
+index 5ff7ace..b2084fb 100644
+--- a/netlink.h
++++ b/netlink.h
+@@ -25,6 +25,8 @@
+ #include <netlink/genl/genl.h>
+ #include <netlink/genl/ctrl.h>
+ 
++struct ether_addr;
++
+ int netlink_print_routing_algos(void);
+ int netlink_print_originators(char *mesh_iface, char *orig_iface, int read_opt,
+ 			      float orig_timeout, float watch_interval);
+@@ -43,6 +45,9 @@ int netlink_print_bla_claim(char *mesh_iface, char *orig_iface, int read_opt,
+ int netlink_print_bla_backbone(char *mesh_iface, char *orig_iface, int read_opt,
+ 			       float orig_timeout, float watch_interval);
+ 
++int translate_mac_netlink(const char *mesh_iface, const struct ether_addr *mac,
++			  struct ether_addr *mac_out);
++
+ extern struct nla_policy batadv_netlink_policy[];
+ 
+ #endif /* _BATCTL_NETLINK_H */
diff --git a/batctl/patches/0017-batctl-Document-a-network-namespaces-example.patch b/batctl/patches/0017-batctl-Document-a-network-namespaces-example.patch
new file mode 100644
index 0000000..219d65a
--- /dev/null
+++ b/batctl/patches/0017-batctl-Document-a-network-namespaces-example.patch
@@ -0,0 +1,79 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Mon, 18 Jul 2016 12:12:07 +0200
+Subject: [PATCH] batctl: Document a network namespaces example.
+
+Add example of has BATMAN can be used with network name spaces in the
+README.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ README | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 57 insertions(+)
+
+diff --git a/README b/README
+index 6df669a..ce049d4 100644
+--- a/README
++++ b/README
+@@ -555,3 +555,60 @@ where:
+ - IPv4 is the IP address of a client in the mesh network
+ - MAC is the MAC address associated to that IP
+ - last-seen is the amount of time since last refresh of this entry
++
++batctl and network name spaces
++==============================
++
++The batman-adv kernel module is netns aware. Mesh instances can be
++created in name spaces, and interfaces in that name space added to the
++mesh. The mesh interface cannot be moved between name spaces, as is
++typical for virtual interfaces.
++
++The following example creates two network namespaces, and uses veth
++pairs to connect them together into a mesh of three nodes.
++
++EMU1="ip netns exec emu1"
++EMU2="ip netns exec emu2"
++
++ip netns add emu1
++ip netns add emu2
++
++ip link add emu1-veth1 type veth peer name emu2-veth1
++ip link set emu1-veth1 netns emu1
++ip link set emu2-veth1 netns emu2
++
++$EMU1 ip link set emu1-veth1 name veth1
++$EMU2 ip link set emu2-veth1 name veth1
++
++$EMU1 ip link set veth1 up
++$EMU2 ip link set veth1 up
++
++ip link add emu1-veth2 type veth peer name veth2
++ip link set emu1-veth2 netns emu1
++$EMU1 ip link set emu1-veth2 name veth2
++
++$EMU1 ip link set veth2 up
++ip link set veth2 up
++
++$EMU1 batctl if add veth1
++$EMU1 batctl if add veth2
++$EMU1 ip link set bat0 up
++
++$EMU2 batctl if add veth1
++$EMU2 ip link set bat0 up
++
++batctl if add veth2
++ip link set bat0 up
++
++alfred and batadv-vis can also be used with name spaces. In this
++example, only netns has been used, so there are no filesystem name
++spaces. Hence the unix domain socket used by alfred needs to be given
++a unique name per instance.
++
++($EMU1 alfred -m -i bat0 -u /var/run/emu1-alfred.soc) &
++($EMU2 alfred -m -i bat0 -u /var/run/emu2-alfred.soc) &
++alfred -m -i bat0 &
++
++($EMU1 batadv-vis -s -u /var/run/emu1-alfred.soc) &
++($EMU2 batadv-vis -s -u /var/run/emu2-alfred.soc) &
++batadv-vis -s &
diff --git a/batctl/patches/0018-batctl-Use-debugfs-fallback-when-netlink-not-support.patch b/batctl/patches/0018-batctl-Use-debugfs-fallback-when-netlink-not-support.patch
new file mode 100644
index 0000000..64a7dd3
--- /dev/null
+++ b/batctl/patches/0018-batctl-Use-debugfs-fallback-when-netlink-not-support.patch
@@ -0,0 +1,330 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 19 Jul 2016 22:09:52 +0200
+Subject: [PATCH] batctl: Use debugfs fallback when netlink not supported
+
+The batman-adv release v2016.2 already has the batadv netlink family . Thus
+the fallback to debugfs not only has to be triggered when the the netlink
+family doesn't exist but also when the cmd returns a -EOPNOTSUPP. This
+still has the problem that the header is generated via a different command
+then the actual table entries. Falling back to debugfs would cause a second
+header entry for the table.
+
+The header print functionality is therefore refactored to only gather the
+data for the header and print the actual header either with the first
+received entry or when the CMD finished without any result.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ functions.h |   1 -
+ netlink.c   | 148 ++++++++++++++++++++++++++++++++++++++++--------------------
+ 2 files changed, 100 insertions(+), 49 deletions(-)
+
+diff --git a/functions.h b/functions.h
+index 1f311ca..e24dea0 100644
+--- a/functions.h
++++ b/functions.h
+@@ -61,7 +61,6 @@ enum {
+ 	SKIP_HEADER = 0x100,
+ 	UNICAST_ONLY = 0x200,
+ 	MULTICAST_ONLY = 0x400,
+-	PARSE_ONLY = 0x800,
+ };
+ 
+ #endif
+diff --git a/netlink.c b/netlink.c
+index 423fc9b..e8e94b2 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -54,6 +54,9 @@ struct print_opts {
+ 	int read_opt;
+ 	float orig_timeout;
+ 	float watch_interval;
++	nl_recvmsg_msg_cb_t callback;
++	char *remaining_header;
++	const char *static_header;
+ 	uint8_t nl_cmd;
+ };
+ 
+@@ -139,7 +142,7 @@ static int print_error(struct sockaddr_nl *nla __unused,
+ 		fprintf(stderr, "Error received: %s\n",
+ 			strerror(-nlerr->error));
+ 
+-	last_err = -nlerr->error;
++	last_err = nlerr->error;
+ 
+ 	return NL_STOP;
+ }
+@@ -182,6 +185,7 @@ static int info_callback(struct nl_msg *msg, void *arg)
+ 	uint8_t ttvn = 0;
+ 	uint16_t bla_group_id = 0;
+ 	const char *algo_name;
++	const char *extra_header;
+ 	int ret;
+ 
+ 	if (!genlmsg_valid_hdr(nlh, 0)) {
+@@ -230,54 +234,64 @@ static int info_callback(struct nl_msg *msg, void *arg)
+ 		if (attrs[BATADV_ATTR_BLA_CRC])
+ 			bla_group_id = nla_get_u16(attrs[BATADV_ATTR_BLA_CRC]);
+ 
+-		if (!(opts->read_opt & PARSE_ONLY)) {
+-			switch (opts->nl_cmd) {
+-			case BATADV_CMD_GET_TRANSTABLE_LOCAL:
+-				ret = asprintf(&extra_info, ", TTVN: %u", ttvn);
+-				if (ret < 0)
+-					extra_info = NULL;
+-				break;
+-			case BATADV_CMD_GET_BLA_BACKBONE:
+-			case BATADV_CMD_GET_BLA_CLAIM:
+-				ret = asprintf(&extra_info, ", group id: 0x%04x",
+-					       bla_group_id);
+-				if (ret < 0)
+-					extra_info = NULL;
+-				break;
+-			default:
+-				extra_info = strdup("");
+-				break;
+-			}
++		switch (opts->nl_cmd) {
++		case BATADV_CMD_GET_TRANSTABLE_LOCAL:
++			ret = asprintf(&extra_info, ", TTVN: %u", ttvn);
++			if (ret < 0)
++				extra_info = NULL;
++			break;
++		case BATADV_CMD_GET_BLA_BACKBONE:
++		case BATADV_CMD_GET_BLA_CLAIM:
++			ret = asprintf(&extra_info, ", group id: 0x%04x",
++				       bla_group_id);
++			if (ret < 0)
++				extra_info = NULL;
++			break;
++		default:
++			extra_info = strdup("");
++			break;
++		}
+ 
+-			printf("[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%02x:%02x:%02x:%02x:%02x:%02x (%s/%02x:%02x:%02x:%02x:%02x:%02x %s)%s]\n",
++		if (opts->static_header)
++			extra_header = opts->static_header;
++		else
++			extra_header = "";
++
++		ret = asprintf(&opts->remaining_header,
++			       "[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%02x:%02x:%02x:%02x:%02x:%02x (%s/%02x:%02x:%02x:%02x:%02x:%02x %s)%s]\n%s",
+ 			       version, primary_if,
+ 			       primary_mac[0], primary_mac[1], primary_mac[2],
+ 			       primary_mac[3], primary_mac[4], primary_mac[5],
+ 			       mesh_name,
+ 			       mesh_mac[0], mesh_mac[1], mesh_mac[2],
+ 			       mesh_mac[3], mesh_mac[4], mesh_mac[5],
+-			       algo_name, extra_info);
++			       algo_name, extra_info, extra_header);
++		if (ret < 0)
++			opts->remaining_header = NULL;
+ 
+-			if (extra_info)
+-				free(extra_info);
+-		}
++		if (extra_info)
++			free(extra_info);
+ 	} else {
+-		if (!(opts->read_opt & PARSE_ONLY))
+-			printf("BATMAN mesh %s disabled\n", mesh_name);
++		ret = asprintf(&opts->remaining_header,
++			       "BATMAN mesh %s disabled\n", mesh_name);
++		if (ret < 0)
++			opts->remaining_header = NULL;
+ 	}
+ 
+ 	return NL_STOP;
+ }
+ 
+-static void netlink_print_info(int ifindex, uint8_t nl_cmd, int read_opt)
++static char *netlink_get_info(int ifindex, uint8_t nl_cmd, const char *header)
+ {
+ 	struct nl_sock *sock;
+ 	struct nl_msg *msg;
+ 	struct nl_cb *cb;
+ 	int family;
+ 	struct print_opts opts = {
+-		.read_opt = read_opt,
++		.read_opt = 0,
+ 		.nl_cmd = nl_cmd,
++		.remaining_header = NULL,
++		.static_header = header,
+ 	};
+ 
+ 	sock = nl_socket_alloc();
+@@ -285,7 +299,7 @@ static void netlink_print_info(int ifindex, uint8_t nl_cmd, int read_opt)
+ 
+ 	family = genl_ctrl_resolve(sock, BATADV_NL_NAME);
+ 	if (family < 0)
+-		return;
++		return NULL;
+ 
+ 	msg = nlmsg_alloc();
+ 	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, 0,
+@@ -304,6 +318,27 @@ static void netlink_print_info(int ifindex, uint8_t nl_cmd, int read_opt)
+ 	nl_recvmsgs(sock, cb);
+ 
+ 	nl_socket_free(sock);
++
++	return opts.remaining_header;
++}
++
++static void netlink_print_remaining_header(struct print_opts *opts)
++{
++	if (!opts->remaining_header)
++		return;
++
++	fputs(opts->remaining_header, stdout);
++	free(opts->remaining_header);
++	opts->remaining_header = NULL;
++}
++
++static int netlink_print_common_cb(struct nl_msg *msg, void *arg)
++{
++	struct print_opts *opts = arg;
++
++	netlink_print_remaining_header(opts);
++
++	return opts->callback(msg, arg);
+ }
+ 
+ static const int routing_algos_mandatory[] = {
+@@ -352,6 +387,9 @@ int netlink_print_routing_algos(void)
+ 	struct nl_msg *msg;
+ 	struct nl_cb *cb;
+ 	int family;
++	struct print_opts opts = {
++		.callback = routing_algos_callback,
++	};
+ 
+ 	sock = nl_socket_alloc();
+ 	genl_connect(sock);
+@@ -368,19 +406,21 @@ int netlink_print_routing_algos(void)
+ 
+ 	nlmsg_free(msg);
+ 
++	opts.remaining_header = strdup("Available routing algorithms:\n");
++
+ 	cb = nl_cb_alloc(NL_CB_DEFAULT);
+-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, routing_algos_callback,
+-		  NULL);
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, netlink_print_common_cb,
++		  &opts);
+ 	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, stop_callback, NULL);
+ 	nl_cb_err(cb, NL_CB_CUSTOM, print_error, NULL);
+ 
+-	printf("Available routing algorithms:\n");
+-
+ 	nl_recvmsgs(sock, cb);
+-
+ 	nl_socket_free(sock);
+ 
+-	return 0;
++	if (!last_err)
++		netlink_print_remaining_header(&opts);
++
++	return last_err;
+ }
+ 
+ static const int originators_mandatory[] = {
+@@ -1040,7 +1080,9 @@ static int netlink_print_common(char *mesh_iface, char *orig_iface,
+ 	struct print_opts opts = {
+ 		.read_opt = read_opt,
+ 		.orig_timeout = orig_timeout,
+-		.watch_interval = watch_interval
++		.watch_interval = watch_interval,
++		.remaining_header = NULL,
++		.callback = callback,
+ 	};
+ 	int hardifindex = 0;
+ 	struct nl_sock *sock;
+@@ -1074,7 +1116,7 @@ static int netlink_print_common(char *mesh_iface, char *orig_iface,
+ 	bat_hosts_init(read_opt);
+ 
+ 	cb = nl_cb_alloc(NL_CB_DEFAULT);
+-	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, callback, &opts);
++	nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, netlink_print_common_cb, &opts);
+ 	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, stop_callback, NULL);
+ 	nl_cb_err(cb, NL_CB_CUSTOM, print_error, NULL);
+ 
+@@ -1083,11 +1125,10 @@ static int netlink_print_common(char *mesh_iface, char *orig_iface,
+ 			/* clear screen, set cursor back to 0,0 */
+ 			printf("\033[2J\033[0;0f");
+ 
+-		if (!(read_opt & SKIP_HEADER)) {
+-			netlink_print_info(ifindex, nl_cmd, 0);
+-			if (header)
+-				printf("%s", header);
+-		}
++		if (!(read_opt & SKIP_HEADER))
++			opts.remaining_header = netlink_get_info(ifindex,
++								 nl_cmd,
++								 header);
+ 
+ 		msg = nlmsg_alloc();
+ 		genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0,
+@@ -1104,6 +1145,11 @@ static int netlink_print_common(char *mesh_iface, char *orig_iface,
+ 
+ 		last_err = 0;
+ 		nl_recvmsgs(sock, cb);
++
++		/* the header should still be printed when no entry was received */
++		if (!last_err)
++			netlink_print_remaining_header(&opts);
++
+ 		if (!last_err && read_opt & (CONT_READ|CLR_CONT_READ))
+ 			usleep(1000000 * watch_interval);
+ 
+@@ -1120,7 +1166,8 @@ int netlink_print_originators(char *mesh_iface, char *orig_iface,
+ 			      int read_opts, float orig_timeout,
+ 			      float watch_interval)
+ {
+-	char *header;
++	char *header = NULL;
++	char *info_header;
+ 	int ifindex;
+ 
+ 	ifindex = if_nametoindex(mesh_iface);
+@@ -1129,10 +1176,12 @@ int netlink_print_originators(char *mesh_iface, char *orig_iface,
+ 		return -ENODEV;
+ 	}
+ 
+-	netlink_print_info(ifindex, BATADV_CMD_GET_ORIGINATORS, PARSE_ONLY);
++	/* only parse routing algorithm name */
++	info_header = netlink_get_info(ifindex, BATADV_CMD_GET_ORIGINATORS, NULL);
++	free(info_header);
+ 
+ 	if (strlen(algo_name_buf) == 0)
+-		return -EINVAL;
++		return -EOPNOTSUPP;
+ 
+ 	if (!strcmp("BATMAN_IV", algo_name_buf))
+ 		header = "   Originator        last-seen (#/255) Nexthop           [outgoingIF]\n";
+@@ -1184,7 +1233,8 @@ int netlink_print_translocal(char *mesh_iface, char *orig_iface, int read_opts,
+ int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opts,
+ 			   float orig_timeout,
+ 			   float watch_interval)
+-{	char *header;
++{	char *header = NULL;
++	char *info_header;
+ 	int ifindex;
+ 
+ 	ifindex = if_nametoindex(mesh_iface);
+@@ -1193,10 +1243,12 @@ int netlink_print_gateways(char *mesh_iface, char *orig_iface, int read_opts,
+ 		return -ENODEV;
+ 	}
+ 
+-	netlink_print_info(ifindex, BATADV_CMD_GET_ORIGINATORS, PARSE_ONLY);
++	/* only parse routing algorithm name */
++	info_header = netlink_get_info(ifindex, BATADV_CMD_GET_ORIGINATORS, NULL);
++	free(info_header);
+ 
+ 	if (strlen(algo_name_buf) == 0)
+-		return -EINVAL;
++		return -EOPNOTSUPP;
+ 
+ 	if (!strcmp("BATMAN_IV", algo_name_buf))
+ 		header = "  Router            ( TQ) Next Hop          [outgoingIf]  Bandwidth\n";
diff --git a/batctl/patches/0019-batctl-Start-new-development-cycle.patch b/batctl/patches/0019-batctl-Start-new-development-cycle.patch
new file mode 100644
index 0000000..fafe3c1
--- /dev/null
+++ b/batctl/patches/0019-batctl-Start-new-development-cycle.patch
@@ -0,0 +1,22 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Thu, 1 Sep 2016 16:20:00 +0200
+Subject: [PATCH] batctl: Start new development cycle
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+---
+ main.h | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/main.h b/main.h
+index 12c33b7..dbde6dd 100644
+--- a/main.h
++++ b/main.h
+@@ -25,7 +25,7 @@
+ #include <stdint.h>
+ 
+ #ifndef SOURCE_VERSION
+-#define SOURCE_VERSION "2016.3"
++#define SOURCE_VERSION "2016.4"
+ #endif
+ 
+ #define SOCKET_PATH_FMT "%s/batman_adv/%s/socket"
diff --git a/batctl/patches/0020-batctl-Work-around-uclibc-collision-for-__unused.patch b/batctl/patches/0020-batctl-Work-around-uclibc-collision-for-__unused.patch
new file mode 100644
index 0000000..2f65b78
--- /dev/null
+++ b/batctl/patches/0020-batctl-Work-around-uclibc-collision-for-__unused.patch
@@ -0,0 +1,52 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 23 Sep 2016 15:05:29 +0200
+Subject: [PATCH] batctl: Work around uclibc collision for __unused
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+---
+ netlink.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/netlink.c b/netlink.c
+index e8e94b2..8fce3d8 100644
+--- a/netlink.c
++++ b/netlink.c
+@@ -134,9 +134,9 @@ static int missing_mandatory_attrs(struct nlattr *attrs[],
+ 	return 0;
+ }
+ 
+-static int print_error(struct sockaddr_nl *nla __unused,
++static int print_error(struct sockaddr_nl *nla __maybe_unused,
+ 		       struct nlmsgerr *nlerr,
+-		       void *arg __unused)
++		       void *arg __maybe_unused)
+ {
+ 	if (nlerr->error != -EOPNOTSUPP)
+ 		fprintf(stderr, "Error received: %s\n",
+@@ -147,7 +147,7 @@ static int print_error(struct sockaddr_nl *nla __unused,
+ 	return NL_STOP;
+ }
+ 
+-static int stop_callback(struct nl_msg *msg, void *arg __unused)
++static int stop_callback(struct nl_msg *msg, void *arg __maybe_unused)
+ {
+ 	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+ 	int *error = nlmsg_data(nlh);
+@@ -345,7 +345,7 @@ static const int routing_algos_mandatory[] = {
+ 	BATADV_ATTR_ALGO_NAME,
+ };
+ 
+-static int routing_algos_callback(struct nl_msg *msg, void *arg __unused)
++static int routing_algos_callback(struct nl_msg *msg, void *arg __maybe_unused)
+ {
+ 	struct nlattr *attrs[BATADV_ATTR_MAX+1];
+ 	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+@@ -1286,7 +1286,7 @@ int netlink_print_bla_backbone(char *mesh_iface, char *orig_iface, int read_opts
+ 				    bla_backbone_callback);
+ }
+ 
+-static int nlquery_error_cb(struct sockaddr_nl *nla __unused,
++static int nlquery_error_cb(struct sockaddr_nl *nla __maybe_unused,
+ 			    struct nlmsgerr *nlerr, void *arg)
+ {
+ 	struct nlquery_opts *query_opts = arg;
diff --git a/batman-adv/patches/0001-batman-adv-Fix-hardif-remove-add-race.patch b/batman-adv/patches/0001-batman-adv-Fix-hardif-remove-add-race.patch
new file mode 100644
index 0000000..1700493
--- /dev/null
+++ b/batman-adv/patches/0001-batman-adv-Fix-hardif-remove-add-race.patch
@@ -0,0 +1,166 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Tue, 17 May 2016 15:39:27 +0200
+Subject: [PATCH] batman-adv: Fix hardif remove/add race
+
+A hard interface can be removed and then added back in quick
+succession. This is particularly true for hdlc interface when changing
+the protocol.
+
+It is not possible it synchronously remove the sysfs and debugfs
+entries for the hard interface when it is removed because the files
+may be open. Thus removal is deferred. The files may thus already
+exist in sysfs and debugfs when the hard interface is re-added, and
+the operations fail.
+
+To fix this race, synchronously rename the debugfs and sysfs files to
+a unique temporary name, thus making the name available when the
+interface comes back, yet keeps open files still available.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/debugfs.c        | 23 +++++++++++++++++++++++
+ net/batman-adv/debugfs.h        |  1 +
+ net/batman-adv/hard-interface.c | 19 +++++++++++++++++++
+ net/batman-adv/sysfs.c          | 17 +++++++++++++++++
+ net/batman-adv/sysfs.h          |  2 ++
+ 5 files changed, 62 insertions(+)
+
+diff --git a/net/batman-adv/debugfs.c b/net/batman-adv/debugfs.c
+index 1d68b6e..aea4133 100644
+--- a/net/batman-adv/debugfs.c
++++ b/net/batman-adv/debugfs.c
+@@ -44,6 +44,7 @@
+ #include "translation-table.h"
+ 
+ static struct dentry *batadv_debugfs;
++static atomic_t batadv_rename = ATOMIC_INIT(0);
+ 
+ static int batadv_algorithms_open(struct inode *inode, struct file *file)
+ {
+@@ -347,6 +348,28 @@ void batadv_debugfs_del_hardif(struct batadv_hard_iface *hard_iface)
+ 	}
+ }
+ 
++/**
++ * batadv_debugfs_rename_hardif - rename the base directory
++ * @hard_iface: hard interface which is renamed.
++ *
++ * The interface may be removed and then quickly added back
++ * again. Rename the old instance to something temporary and unique,
++ * so avoiding a name space clash if it does reappear before the deferred
++ * work completes the removal.
++ */
++void batadv_debugfs_rename_hardif(struct batadv_hard_iface *hard_iface)
++{
++	char new_name[32];
++
++	snprintf(new_name, sizeof(*new_name) - 1, "tmp-%d",
++		 atomic_inc_return(&batadv_rename));
++
++	if (batadv_debugfs && hard_iface->debug_dir) {
++		debugfs_rename(batadv_debugfs, hard_iface->debug_dir,
++			       batadv_debugfs, new_name);
++	}
++}
++
+ int batadv_debugfs_add_meshif(struct net_device *dev)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(dev);
+diff --git a/net/batman-adv/debugfs.h b/net/batman-adv/debugfs.h
+index 1ab4e2e..e7d19c1 100644
+--- a/net/batman-adv/debugfs.h
++++ b/net/batman-adv/debugfs.h
+@@ -34,6 +34,7 @@ int batadv_debugfs_add_meshif(struct net_device *dev);
+ void batadv_debugfs_del_meshif(struct net_device *dev);
+ int batadv_debugfs_add_hardif(struct batadv_hard_iface *hard_iface);
+ void batadv_debugfs_del_hardif(struct batadv_hard_iface *hard_iface);
++void batadv_debugfs_rename_hardif(struct batadv_hard_iface *hard_iface);
+ 
+ #else
+ 
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 1f90808..ccc7641 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -706,6 +706,23 @@ out:
+ 	return NULL;
+ }
+ 
++/**
++ * batadv_hardif_rename - rename the sysfs and debugfs
++ * @hard_iface: The hard interface to rename
++ *
++ * The sysfs and debugfs files cannot be removed until all users close
++ * them.  So the removal is deferred into a work queue. This however
++ * means if the interface comes back before the work queue runs, the
++ * files are still there, and so the create gives an EEXISTS error. To
++ * avoid this, rename them to a tempory name.
++ */
++static void batadv_hardif_rename(struct batadv_hard_iface *hard_iface)
++{
++	batadv_sysfs_rename_hardif(&hard_iface->hardif_obj,
++				   hard_iface->net_dev);
++	batadv_debugfs_rename_hardif(hard_iface);
++}
++
+ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ {
+ 	ASSERT_RTNL();
+@@ -719,6 +736,8 @@ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ 		return;
+ 
+ 	hard_iface->if_status = BATADV_IF_TO_BE_REMOVED;
++	batadv_hardif_rename(hard_iface);
++
+ 	queue_work(batadv_event_workqueue, &hard_iface->cleanup_work);
+ }
+ 
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index fe9ca94..9b2c28f 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -48,6 +48,8 @@
+ #include "packet.h"
+ #include "soft-interface.h"
+ 
++static atomic_t batadv_rename = ATOMIC_INIT(0);
++
+ static struct net_device *batadv_kobj_to_netdev(struct kobject *obj)
+ {
+ 	struct device *dev = container_of(obj->parent, struct device, kobj);
+@@ -1046,6 +1048,21 @@ out:
+ 	return -ENOMEM;
+ }
+ 
++void batadv_sysfs_rename_hardif(struct kobject **hardif_obj,
++				struct net_device *dev)
++{
++	char new_name[32];
++	int err;
++
++	snprintf(new_name, sizeof(*new_name) - 1, "tmp-%d",
++		 atomic_inc_return(&batadv_rename));
++
++	err = kobject_rename(*hardif_obj, new_name);
++	if (err)
++		batadv_err(dev, "Can't rename sysfs dir: %s/%s: %d\n",
++			   dev->name, new_name, err);
++}
++
+ void batadv_sysfs_del_hardif(struct kobject **hardif_obj)
+ {
+ 	kobject_put(*hardif_obj);
+diff --git a/net/batman-adv/sysfs.h b/net/batman-adv/sysfs.h
+index c76021b..64d3722 100644
+--- a/net/batman-adv/sysfs.h
++++ b/net/batman-adv/sysfs.h
+@@ -48,6 +48,8 @@ void batadv_sysfs_del_meshif(struct net_device *dev);
+ int batadv_sysfs_add_hardif(struct kobject **hardif_obj,
+ 			    struct net_device *dev);
+ void batadv_sysfs_del_hardif(struct kobject **hardif_obj);
++void batadv_sysfs_rename_hardif(struct kobject **hardif_obj,
++				struct net_device *dev);
+ int batadv_sysfs_add_vlan(struct net_device *dev,
+ 			  struct batadv_softif_vlan *vlan);
+ void batadv_sysfs_del_vlan(struct batadv_priv *bat_priv,
diff --git a/batman-adv/patches/0002-batman-adv-Document-optional-batadv_algo_ops.patch b/batman-adv/patches/0002-batman-adv-Document-optional-batadv_algo_ops.patch
new file mode 100644
index 0000000..50677d6
--- /dev/null
+++ b/batman-adv/patches/0002-batman-adv-Document-optional-batadv_algo_ops.patch
@@ -0,0 +1,51 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Tue, 7 Jun 2016 22:44:53 +0200
+Subject: [PATCH] batman-adv: Document optional batadv_algo_ops
+
+Some operations in batadv_algo_ops are optional and marked as such in the
+kerneldoc. But some of them miss the "(optional)" in their kerneldoc. These
+have to also be marked to give an implementor of an algorithm the correct
+background information without looking in the code calling these function
+pointers.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/types.h | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index a64522c..0ede27a 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1396,6 +1396,7 @@ struct batadv_forw_packet {
+ /**
+  * struct batadv_algo_iface_ops - mesh algorithm callbacks (interface specific)
+  * @activate: start routing mechanisms when hard-interface is brought up
++ *  (optional)
+  * @enable: init routing info when hard-interface is enabled
+  * @disable: de-init routing info when hard-interface is disabled
+  * @update_mac: (re-)init mac addresses of the protocol information
+@@ -1413,6 +1414,7 @@ struct batadv_algo_iface_ops {
+ /**
+  * struct batadv_algo_neigh_ops - mesh algorithm callbacks (neighbour specific)
+  * @hardif_init: called on creation of single hop entry
++ *  (optional)
+  * @cmp: compare the metrics of two neighbors for their respective outgoing
+  *  interfaces
+  * @is_similar_or_better: check if neigh1 is equally similar or better than
+@@ -1435,11 +1437,11 @@ struct batadv_algo_neigh_ops {
+ /**
+  * struct batadv_algo_orig_ops - mesh algorithm callbacks (originator specific)
+  * @free: free the resources allocated by the routing algorithm for an orig_node
+- *  object
++ *  object (optional)
+  * @add_if: ask the routing algorithm to apply the needed changes to the
+- *  orig_node due to a new hard-interface being added into the mesh
++ *  orig_node due to a new hard-interface being added into the mesh (optional)
+  * @del_if: ask the routing algorithm to apply the needed changes to the
+- *  orig_node due to an hard-interface being removed from the mesh
++ *  orig_node due to an hard-interface being removed from the mesh (optional)
+  * @print: print the originator table (optional)
+  */
+ struct batadv_algo_orig_ops {
diff --git a/batman-adv/patches/0003-batman-adv-Define-module-rtnl-link-name.patch b/batman-adv/patches/0003-batman-adv-Define-module-rtnl-link-name.patch
new file mode 100644
index 0000000..814e7d6
--- /dev/null
+++ b/batman-adv/patches/0003-batman-adv-Define-module-rtnl-link-name.patch
@@ -0,0 +1,23 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 10 Jun 2016 23:00:55 +0200
+Subject: [PATCH] batman-adv: Define module rtnl link name
+
+The batman-adv module can automatically be loaded when operations over the
+rtnl link are triggered. This requires only the correct rtnl link name in
+the module header.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/main.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/net/batman-adv/main.c b/net/batman-adv/main.c
+index fe4c5e2..f61479b 100644
+--- a/net/batman-adv/main.c
++++ b/net/batman-adv/main.c
+@@ -638,3 +638,4 @@ MODULE_AUTHOR(BATADV_DRIVER_AUTHOR);
+ MODULE_DESCRIPTION(BATADV_DRIVER_DESC);
+ MODULE_SUPPORTED_DEVICE(BATADV_DRIVER_DEVICE);
+ MODULE_VERSION(BATADV_SOURCE_VERSION);
++MODULE_ALIAS_RTNL_LINK("batadv");
diff --git a/batman-adv/patches/0004-batman-adv-Use-rtnl-link-in-device-creation-example.patch b/batman-adv/patches/0004-batman-adv-Use-rtnl-link-in-device-creation-example.patch
new file mode 100644
index 0000000..9368e94
--- /dev/null
+++ b/batman-adv/patches/0004-batman-adv-Use-rtnl-link-in-device-creation-example.patch
@@ -0,0 +1,52 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 10 Jun 2016 23:00:56 +0200
+Subject: [PATCH] batman-adv: Use rtnl link in device creation example
+
+The standard kernel API to add new virtual interfaces and attach other
+interfaces to it is rtnl-link. batman-adv supports it since v3.10. This
+functionality should be used instead of the legacy batman-adv-only sysfs
+interface.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ Documentation/networking/batman-adv.txt | 17 +++++++++++------
+ 1 file changed, 11 insertions(+), 6 deletions(-)
+
+diff --git a/Documentation/networking/batman-adv.txt b/Documentation/networking/batman-adv.txt
+index 1b5e7a7..8a8d3d9 100644
+--- a/Documentation/networking/batman-adv.txt
++++ b/Documentation/networking/batman-adv.txt
+@@ -43,10 +43,15 @@ new interfaces to verify the compatibility. There is no  need  to
+ reload the module if you plug your USB wifi adapter into your ma-
+ chine after batman advanced was initially loaded.
+ 
+-To activate a  given  interface  simply  write  "bat0"  into  its
+-"mesh_iface" file inside the batman_adv subfolder:
++The batman-adv soft-interface can be created using  the  iproute2
++tool "ip"
+ 
+-# echo bat0 > /sys/class/net/eth0/batman_adv/mesh_iface
++# ip link add name bat0 type batadv
++
++To  activate a  given  interface  simply  attach it to the "bat0"
++interface
++
++# ip link set dev eth0 master bat0
+ 
+ Repeat  this step for all interfaces you wish to add.  Now batman
+ starts using/broadcasting on this/these interface(s).
+@@ -56,10 +61,10 @@ By reading the "iface_status" file you can check its status:
+ # cat /sys/class/net/eth0/batman_adv/iface_status
+ # active
+ 
+-To deactivate an interface you have  to  write  "none"  into  its
+-"mesh_iface" file:
++To  deactivate  an  interface  you  have   to  detach it from the
++"bat0" interface:
+ 
+-# echo none > /sys/class/net/eth0/batman_adv/mesh_iface
++# ip link set dev eth0 nomaster
+ 
+ 
+ All  mesh  wide  settings  can be found in batman's own interface
diff --git a/batman-adv/patches/0005-Revert-batman-adv-Fix-hardif-remove-add-race.patch b/batman-adv/patches/0005-Revert-batman-adv-Fix-hardif-remove-add-race.patch
new file mode 100644
index 0000000..ea485bb
--- /dev/null
+++ b/batman-adv/patches/0005-Revert-batman-adv-Fix-hardif-remove-add-race.patch
@@ -0,0 +1,159 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 13 Jun 2016 07:41:29 +0200
+Subject: [PATCH] Revert "batman-adv: Fix hardif remove/add race"
+
+The description given in the commit is misleading and is at least not true
+for sysfs. The sysfs file structure should instead be deleted immediately on
+rtnl notifications and be underlying objects should be removed later when
+all kobject_put were done for the object.
+
+This reverts commit 6b0485c758be ("batman-adv: Fix hardif remove/add race")
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/debugfs.c        | 23 -----------------------
+ net/batman-adv/debugfs.h        |  1 -
+ net/batman-adv/hard-interface.c | 19 -------------------
+ net/batman-adv/sysfs.c          | 17 -----------------
+ net/batman-adv/sysfs.h          |  2 --
+ 5 files changed, 62 deletions(-)
+
+diff --git a/net/batman-adv/debugfs.c b/net/batman-adv/debugfs.c
+index aea4133..1d68b6e 100644
+--- a/net/batman-adv/debugfs.c
++++ b/net/batman-adv/debugfs.c
+@@ -44,7 +44,6 @@
+ #include "translation-table.h"
+ 
+ static struct dentry *batadv_debugfs;
+-static atomic_t batadv_rename = ATOMIC_INIT(0);
+ 
+ static int batadv_algorithms_open(struct inode *inode, struct file *file)
+ {
+@@ -348,28 +347,6 @@ void batadv_debugfs_del_hardif(struct batadv_hard_iface *hard_iface)
+ 	}
+ }
+ 
+-/**
+- * batadv_debugfs_rename_hardif - rename the base directory
+- * @hard_iface: hard interface which is renamed.
+- *
+- * The interface may be removed and then quickly added back
+- * again. Rename the old instance to something temporary and unique,
+- * so avoiding a name space clash if it does reappear before the deferred
+- * work completes the removal.
+- */
+-void batadv_debugfs_rename_hardif(struct batadv_hard_iface *hard_iface)
+-{
+-	char new_name[32];
+-
+-	snprintf(new_name, sizeof(*new_name) - 1, "tmp-%d",
+-		 atomic_inc_return(&batadv_rename));
+-
+-	if (batadv_debugfs && hard_iface->debug_dir) {
+-		debugfs_rename(batadv_debugfs, hard_iface->debug_dir,
+-			       batadv_debugfs, new_name);
+-	}
+-}
+-
+ int batadv_debugfs_add_meshif(struct net_device *dev)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(dev);
+diff --git a/net/batman-adv/debugfs.h b/net/batman-adv/debugfs.h
+index e7d19c1..1ab4e2e 100644
+--- a/net/batman-adv/debugfs.h
++++ b/net/batman-adv/debugfs.h
+@@ -34,7 +34,6 @@ int batadv_debugfs_add_meshif(struct net_device *dev);
+ void batadv_debugfs_del_meshif(struct net_device *dev);
+ int batadv_debugfs_add_hardif(struct batadv_hard_iface *hard_iface);
+ void batadv_debugfs_del_hardif(struct batadv_hard_iface *hard_iface);
+-void batadv_debugfs_rename_hardif(struct batadv_hard_iface *hard_iface);
+ 
+ #else
+ 
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index ccc7641..1f90808 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -706,23 +706,6 @@ out:
+ 	return NULL;
+ }
+ 
+-/**
+- * batadv_hardif_rename - rename the sysfs and debugfs
+- * @hard_iface: The hard interface to rename
+- *
+- * The sysfs and debugfs files cannot be removed until all users close
+- * them.  So the removal is deferred into a work queue. This however
+- * means if the interface comes back before the work queue runs, the
+- * files are still there, and so the create gives an EEXISTS error. To
+- * avoid this, rename them to a tempory name.
+- */
+-static void batadv_hardif_rename(struct batadv_hard_iface *hard_iface)
+-{
+-	batadv_sysfs_rename_hardif(&hard_iface->hardif_obj,
+-				   hard_iface->net_dev);
+-	batadv_debugfs_rename_hardif(hard_iface);
+-}
+-
+ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ {
+ 	ASSERT_RTNL();
+@@ -736,8 +719,6 @@ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ 		return;
+ 
+ 	hard_iface->if_status = BATADV_IF_TO_BE_REMOVED;
+-	batadv_hardif_rename(hard_iface);
+-
+ 	queue_work(batadv_event_workqueue, &hard_iface->cleanup_work);
+ }
+ 
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index 9b2c28f..fe9ca94 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -48,8 +48,6 @@
+ #include "packet.h"
+ #include "soft-interface.h"
+ 
+-static atomic_t batadv_rename = ATOMIC_INIT(0);
+-
+ static struct net_device *batadv_kobj_to_netdev(struct kobject *obj)
+ {
+ 	struct device *dev = container_of(obj->parent, struct device, kobj);
+@@ -1048,21 +1046,6 @@ out:
+ 	return -ENOMEM;
+ }
+ 
+-void batadv_sysfs_rename_hardif(struct kobject **hardif_obj,
+-				struct net_device *dev)
+-{
+-	char new_name[32];
+-	int err;
+-
+-	snprintf(new_name, sizeof(*new_name) - 1, "tmp-%d",
+-		 atomic_inc_return(&batadv_rename));
+-
+-	err = kobject_rename(*hardif_obj, new_name);
+-	if (err)
+-		batadv_err(dev, "Can't rename sysfs dir: %s/%s: %d\n",
+-			   dev->name, new_name, err);
+-}
+-
+ void batadv_sysfs_del_hardif(struct kobject **hardif_obj)
+ {
+ 	kobject_put(*hardif_obj);
+diff --git a/net/batman-adv/sysfs.h b/net/batman-adv/sysfs.h
+index 64d3722..c76021b 100644
+--- a/net/batman-adv/sysfs.h
++++ b/net/batman-adv/sysfs.h
+@@ -48,8 +48,6 @@ void batadv_sysfs_del_meshif(struct net_device *dev);
+ int batadv_sysfs_add_hardif(struct kobject **hardif_obj,
+ 			    struct net_device *dev);
+ void batadv_sysfs_del_hardif(struct kobject **hardif_obj);
+-void batadv_sysfs_rename_hardif(struct kobject **hardif_obj,
+-				struct net_device *dev);
+ int batadv_sysfs_add_vlan(struct net_device *dev,
+ 			  struct batadv_softif_vlan *vlan);
+ void batadv_sysfs_del_vlan(struct batadv_priv *bat_priv,
diff --git a/batman-adv/patches/0006-batman-adv-Modify-mesh_iface-outside-sysfs-context.patch b/batman-adv/patches/0006-batman-adv-Modify-mesh_iface-outside-sysfs-context.patch
new file mode 100644
index 0000000..ca4cb8a
--- /dev/null
+++ b/batman-adv/patches/0006-batman-adv-Modify-mesh_iface-outside-sysfs-context.patch
@@ -0,0 +1,208 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 13 Jun 2016 07:41:30 +0200
+Subject: [PATCH] batman-adv: Modify mesh_iface outside sysfs context
+
+The legacy sysfs interface to modify interfaces belonging to batman-adv
+is run inside a region holding s_lock. And to add a net_device, it has
+to also get the rtnl_lock. This is exactly the other way around than in
+other virtual net_devices and conflicts with netdevice notifier which
+executes inside rtnl_lock.
+
+The inverted lock situation is currently solved by executing the removal
+of netdevices via workqueue. The workqueue isn't executed inside
+rtnl_lock and thus can independently get the s_lock and the rtnl_lock.
+
+But this workaround fails when the netdevice notifier creates events in
+quick succession and the earlier triggered removal of a net_device isn't
+processed in the workqueue before the adding of the new netdevice (with
+same name) event is issued.
+
+Instead the legacy sysfs interface store events have to be enqueued in
+a workqueue to loose the s_lock. The worker is then free to get the
+required locks and the deadlock is avoided.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/sysfs.c | 107 +++++++++++++++++++++++++++++++++++++------------
+ net/batman-adv/types.h |  13 ++++++
+ 2 files changed, 94 insertions(+), 26 deletions(-)
+
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index fe9ca94..8528959 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -37,6 +37,7 @@
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/stringify.h>
++#include <linux/workqueue.h>
+ 
+ #include "bridge_loop_avoidance.h"
+ #include "distributed-arp-table.h"
+@@ -828,31 +829,31 @@ static ssize_t batadv_show_mesh_iface(struct kobject *kobj,
+ 	return length;
+ }
+ 
+-static ssize_t batadv_store_mesh_iface(struct kobject *kobj,
+-				       struct attribute *attr, char *buff,
+-				       size_t count)
++/**
++ * batadv_store_mesh_iface_finish - store new hardif mesh_iface state
++ * @net_dev: netdevice to add/remove to/from batman-adv soft-interface
++ * @ifname: name of soft-interface to modify
++ *
++ * Changes the parts of the hard+soft interface which can not be modified under
++ * sysfs lock (to prevent deadlock situations).
++ *
++ * Return: 0 on success, 0 < on failure
++ */
++static int batadv_store_mesh_iface_finish(struct net_device *net_dev,
++					  char ifname[IFNAMSIZ])
+ {
+-	struct net_device *net_dev = batadv_kobj_to_netdev(kobj);
+ 	struct net *net = dev_net(net_dev);
+ 	struct batadv_hard_iface *hard_iface;
+-	int status_tmp = -1;
+-	int ret = count;
++	int status_tmp;
++	int ret = 0;
++
++	ASSERT_RTNL();
+ 
+ 	hard_iface = batadv_hardif_get_by_netdev(net_dev);
+ 	if (!hard_iface)
+-		return count;
++		return 0;
+ 
+-	if (buff[count - 1] == '\n')
+-		buff[count - 1] = '\0';
+-
+-	if (strlen(buff) >= IFNAMSIZ) {
+-		pr_err("Invalid parameter for 'mesh_iface' setting received: interface name too long '%s'\n",
+-		       buff);
+-		batadv_hardif_put(hard_iface);
+-		return -EINVAL;
+-	}
+-
+-	if (strncmp(buff, "none", 4) == 0)
++	if (strncmp(ifname, "none", 4) == 0)
+ 		status_tmp = BATADV_IF_NOT_IN_USE;
+ 	else
+ 		status_tmp = BATADV_IF_I_WANT_YOU;
+@@ -861,15 +862,13 @@ static ssize_t batadv_store_mesh_iface(struct kobject *kobj,
+ 		goto out;
+ 
+ 	if ((hard_iface->soft_iface) &&
+-	    (strncmp(hard_iface->soft_iface->name, buff, IFNAMSIZ) == 0))
++	    (strncmp(hard_iface->soft_iface->name, ifname, IFNAMSIZ) == 0))
+ 		goto out;
+ 
+-	rtnl_lock();
+-
+ 	if (status_tmp == BATADV_IF_NOT_IN_USE) {
+ 		batadv_hardif_disable_interface(hard_iface,
+ 						BATADV_IF_CLEANUP_AUTO);
+-		goto unlock;
++		goto out;
+ 	}
+ 
+ 	/* if the interface already is in use */
+@@ -877,15 +876,71 @@ static ssize_t batadv_store_mesh_iface(struct kobject *kobj,
+ 		batadv_hardif_disable_interface(hard_iface,
+ 						BATADV_IF_CLEANUP_AUTO);
+ 
+-	ret = batadv_hardif_enable_interface(hard_iface, net, buff);
+-
+-unlock:
+-	rtnl_unlock();
++	ret = batadv_hardif_enable_interface(hard_iface, net, ifname);
+ out:
+ 	batadv_hardif_put(hard_iface);
+ 	return ret;
+ }
+ 
++/**
++ * batadv_store_mesh_iface_work - store new hardif mesh_iface state
++ * @work: work queue item
++ *
++ * Changes the parts of the hard+soft interface which can not be modified under
++ * sysfs lock (to prevent deadlock situations).
++ */
++static void batadv_store_mesh_iface_work(struct work_struct *work)
++{
++	struct batadv_store_mesh_work *store_work;
++	int ret;
++
++	store_work = container_of(work, struct batadv_store_mesh_work, work);
++
++	rtnl_lock();
++	ret = batadv_store_mesh_iface_finish(store_work->net_dev,
++					     store_work->soft_iface_name);
++	rtnl_unlock();
++
++	if (ret < 0)
++		pr_err("Failed to store new mesh_iface state %s for %s: %d\n",
++		       store_work->soft_iface_name, store_work->net_dev->name,
++		       ret);
++
++	dev_put(store_work->net_dev);
++	kfree(store_work);
++}
++
++static ssize_t batadv_store_mesh_iface(struct kobject *kobj,
++				       struct attribute *attr, char *buff,
++				       size_t count)
++{
++	struct net_device *net_dev = batadv_kobj_to_netdev(kobj);
++	struct batadv_store_mesh_work *store_work;
++
++	if (buff[count - 1] == '\n')
++		buff[count - 1] = '\0';
++
++	if (strlen(buff) >= IFNAMSIZ) {
++		pr_err("Invalid parameter for 'mesh_iface' setting received: interface name too long '%s'\n",
++		       buff);
++		return -EINVAL;
++	}
++
++	store_work = kmalloc(sizeof(*store_work), GFP_KERNEL);
++	if (!store_work)
++		return -ENOMEM;
++
++	dev_hold(net_dev);
++	INIT_WORK(&store_work->work, batadv_store_mesh_iface_work);
++	store_work->net_dev = net_dev;
++	strlcpy(store_work->soft_iface_name, buff,
++		sizeof(store_work->soft_iface_name));
++
++	queue_work(batadv_event_workqueue, &store_work->work);
++
++	return count;
++}
++
+ static ssize_t batadv_show_iface_status(struct kobject *kobj,
+ 					struct attribute *attr, char *buff)
+ {
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 0ede27a..23c9577 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1566,4 +1566,17 @@ enum batadv_tvlv_handler_flags {
+ 	BATADV_TVLV_HANDLER_OGM_CALLED = BIT(2),
+ };
+ 
++/**
++ * struct batadv_store_mesh_work - Work queue item to detach add/del interface
++ *  from sysfs locks
++ * @net_dev: netdevice to add/remove to/from batman-adv soft-interface
++ * @soft_iface_name: name of soft-interface to modify
++ * @work: work queue item
++ */
++struct batadv_store_mesh_work {
++	struct net_device *net_dev;
++	char soft_iface_name[IFNAMSIZ];
++	struct work_struct work;
++};
++
+ #endif /* _NET_BATMAN_ADV_TYPES_H_ */
diff --git a/batman-adv/patches/0007-batman-adv-Revert-postpone-sysfs-removal-when-unregi.patch b/batman-adv/patches/0007-batman-adv-Revert-postpone-sysfs-removal-when-unregi.patch
new file mode 100644
index 0000000..d17661e
--- /dev/null
+++ b/batman-adv/patches/0007-batman-adv-Revert-postpone-sysfs-removal-when-unregi.patch
@@ -0,0 +1,197 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 13 Jun 2016 07:41:31 +0200
+Subject: [PATCH] batman-adv: Revert "postpone sysfs removal when unregistering"
+
+Postponing the removal of the interface breaks the expected behavior of
+NETDEV_UNREGISTER and NETDEV_PRE_TYPE_CHANGE. This is especially
+problematic when an interface is removed and added in quick succession.
+
+This reverts commit a33c882c1069 ("batman-adv: postpone sysfs removal when
+unregistering").
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/hard-interface.c | 26 +++---------------------
+ net/batman-adv/soft-interface.c | 44 ++++++++++++-----------------------------
+ net/batman-adv/types.h          |  4 ----
+ 3 files changed, 16 insertions(+), 58 deletions(-)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 1f90808..714af8e 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -35,7 +35,6 @@
+ #include <linux/rtnetlink.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+-#include <linux/workqueue.h>
+ 
+ #include "bat_v.h"
+ #include "bridge_loop_avoidance.h"
+@@ -625,25 +624,6 @@ out:
+ 		batadv_hardif_put(primary_if);
+ }
+ 
+-/**
+- * batadv_hardif_remove_interface_finish - cleans up the remains of a hardif
+- * @work: work queue item
+- *
+- * Free the parts of the hard interface which can not be removed under
+- * rtnl lock (to prevent deadlock situations).
+- */
+-static void batadv_hardif_remove_interface_finish(struct work_struct *work)
+-{
+-	struct batadv_hard_iface *hard_iface;
+-
+-	hard_iface = container_of(work, struct batadv_hard_iface,
+-				  cleanup_work);
+-
+-	batadv_debugfs_del_hardif(hard_iface);
+-	batadv_sysfs_del_hardif(&hard_iface->hardif_obj);
+-	batadv_hardif_put(hard_iface);
+-}
+-
+ static struct batadv_hard_iface *
+ batadv_hardif_add_interface(struct net_device *net_dev)
+ {
+@@ -676,8 +656,6 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+ 
+ 	INIT_LIST_HEAD(&hard_iface->list);
+ 	INIT_HLIST_HEAD(&hard_iface->neigh_list);
+-	INIT_WORK(&hard_iface->cleanup_work,
+-		  batadv_hardif_remove_interface_finish);
+ 
+ 	spin_lock_init(&hard_iface->neigh_list_lock);
+ 
+@@ -719,7 +697,9 @@ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ 		return;
+ 
+ 	hard_iface->if_status = BATADV_IF_TO_BE_REMOVED;
+-	queue_work(batadv_event_workqueue, &hard_iface->cleanup_work);
++	batadv_debugfs_del_hardif(hard_iface);
++	batadv_sysfs_del_hardif(&hard_iface->hardif_obj);
++	batadv_hardif_put(hard_iface);
+ }
+ 
+ void batadv_hardif_remove_interfaces(void)
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index 7527c06..216ac03 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -39,6 +39,7 @@
+ #include <linux/random.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
++#include <linux/rtnetlink.h>
+ #include <linux/skbuff.h>
+ #include <linux/slab.h>
+ #include <linux/socket.h>
+@@ -46,7 +47,6 @@
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/types.h>
+-#include <linux/workqueue.h>
+ 
+ #include "bat_algo.h"
+ #include "bridge_loop_avoidance.h"
+@@ -747,34 +747,6 @@ static void batadv_set_lockdep_class(struct net_device *dev)
+ }
+ 
+ /**
+- * batadv_softif_destroy_finish - cleans up the remains of a softif
+- * @work: work queue item
+- *
+- * Free the parts of the soft interface which can not be removed under
+- * rtnl lock (to prevent deadlock situations).
+- */
+-static void batadv_softif_destroy_finish(struct work_struct *work)
+-{
+-	struct batadv_softif_vlan *vlan;
+-	struct batadv_priv *bat_priv;
+-	struct net_device *soft_iface;
+-
+-	bat_priv = container_of(work, struct batadv_priv,
+-				cleanup_work);
+-	soft_iface = bat_priv->soft_iface;
+-
+-	/* destroy the "untagged" VLAN */
+-	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
+-	if (vlan) {
+-		batadv_softif_destroy_vlan(bat_priv, vlan);
+-		batadv_softif_vlan_put(vlan);
+-	}
+-
+-	batadv_sysfs_del_meshif(soft_iface);
+-	unregister_netdev(soft_iface);
+-}
+-
+-/**
+  * batadv_softif_init_late - late stage initialization of soft interface
+  * @dev: registered network device to modify
+  *
+@@ -791,7 +763,6 @@ static int batadv_softif_init_late(struct net_device *dev)
+ 
+ 	bat_priv = netdev_priv(dev);
+ 	bat_priv->soft_iface = dev;
+-	INIT_WORK(&bat_priv->cleanup_work, batadv_softif_destroy_finish);
+ 
+ 	/* batadv_interface_stats() needs to be available as soon as
+ 	 * register_netdevice() has been called
+@@ -1028,8 +999,19 @@ struct net_device *batadv_softif_create(struct net *net, const char *name)
+ void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
++	struct batadv_softif_vlan *vlan;
+ 
+-	queue_work(batadv_event_workqueue, &bat_priv->cleanup_work);
++	ASSERT_RTNL();
++
++	/* destroy the "untagged" VLAN */
++	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
++	if (vlan) {
++		batadv_softif_destroy_vlan(bat_priv, vlan);
++		batadv_softif_vlan_put(vlan);
++	}
++
++	batadv_sysfs_del_meshif(soft_iface);
++	unregister_netdevice(soft_iface);
+ }
+ 
+ /**
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 23c9577..96af6da 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -132,7 +132,6 @@ struct batadv_hard_iface_bat_v {
+  * @rcu: struct used for freeing in an RCU-safe manner
+  * @bat_iv: per hard-interface B.A.T.M.A.N. IV data
+  * @bat_v: per hard-interface B.A.T.M.A.N. V data
+- * @cleanup_work: work queue callback item for hard-interface deinit
+  * @debug_dir: dentry for nc subdir in batman-adv directory in debugfs
+  * @neigh_list: list of unique single hop neighbors via this interface
+  * @neigh_list_lock: lock protecting neigh_list
+@@ -152,7 +151,6 @@ struct batadv_hard_iface {
+ #ifdef CONFIG_BATMAN_ADV_BATMAN_V
+ 	struct batadv_hard_iface_bat_v bat_v;
+ #endif
+-	struct work_struct cleanup_work;
+ 	struct dentry *debug_dir;
+ 	struct hlist_head neigh_list;
+ 	/* neigh_list_lock protects: neigh_list */
+@@ -1015,7 +1013,6 @@ struct batadv_priv_bat_v {
+  * @forw_bcast_list_lock: lock protecting forw_bcast_list
+  * @tp_list_lock: spinlock protecting @tp_list
+  * @orig_work: work queue callback item for orig node purging
+- * @cleanup_work: work queue callback item for soft-interface deinit
+  * @primary_if: one of the hard-interfaces assigned to this mesh interface
+  *  becomes the primary interface
+  * @algo_ops: routing algorithm used by this mesh interface
+@@ -1074,7 +1071,6 @@ struct batadv_priv {
+ 	spinlock_t tp_list_lock; /* protects tp_list */
+ 	atomic_t tp_num;
+ 	struct delayed_work orig_work;
+-	struct work_struct cleanup_work;
+ 	struct batadv_hard_iface __rcu *primary_if;  /* rcu protected pointer */
+ 	struct batadv_algo_ops *algo_ops;
+ 	struct hlist_head softif_vlan_list;
diff --git a/batman-adv/patches/0008-batman-adv-Avoid-sysfs-name-collision-for-netns-move.patch b/batman-adv/patches/0008-batman-adv-Avoid-sysfs-name-collision-for-netns-move.patch
new file mode 100644
index 0000000..c72f3ac
--- /dev/null
+++ b/batman-adv/patches/0008-batman-adv-Avoid-sysfs-name-collision-for-netns-move.patch
@@ -0,0 +1,76 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 13 Jun 2016 07:41:32 +0200
+Subject: [PATCH] batman-adv: Avoid sysfs name collision for netns moves
+
+The kobject_put is only removing the sysfs entry and corresponding entries
+when its reference counter becomes zero. This tends to lead to collisions
+when a device is moved between two different network namespaces because
+some of the sysfs files have to be removed first and then added again to
+the already moved sysfs entry.
+
+    WARNING: CPU: 0 PID: 290 at lib/kobject.c:240 kobject_add_internal+0x5ec/0x8a0
+    kobject_add_internal failed for batman_adv with -EEXIST, don't try to register things with the same name in the same directory.
+
+But the caller of kobject_put can already remove the sysfs entry before it
+does the kobject_put. This removal is done even when the reference counter
+is not yet zero and thus avoids the problem.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/sysfs.c | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index 8528959..4e06cb7 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -713,6 +713,8 @@ rem_attr:
+ 	for (bat_attr = batadv_mesh_attrs; *bat_attr; ++bat_attr)
+ 		sysfs_remove_file(bat_priv->mesh_obj, &((*bat_attr)->attr));
+ 
++	kobject_uevent(bat_priv->mesh_obj, KOBJ_REMOVE);
++	kobject_del(bat_priv->mesh_obj);
+ 	kobject_put(bat_priv->mesh_obj);
+ 	bat_priv->mesh_obj = NULL;
+ out:
+@@ -727,6 +729,8 @@ void batadv_sysfs_del_meshif(struct net_device *dev)
+ 	for (bat_attr = batadv_mesh_attrs; *bat_attr; ++bat_attr)
+ 		sysfs_remove_file(bat_priv->mesh_obj, &((*bat_attr)->attr));
+ 
++	kobject_uevent(bat_priv->mesh_obj, KOBJ_REMOVE);
++	kobject_del(bat_priv->mesh_obj);
+ 	kobject_put(bat_priv->mesh_obj);
+ 	bat_priv->mesh_obj = NULL;
+ }
+@@ -782,6 +786,10 @@ rem_attr:
+ 	for (bat_attr = batadv_vlan_attrs; *bat_attr; ++bat_attr)
+ 		sysfs_remove_file(vlan->kobj, &((*bat_attr)->attr));
+ 
++	if (vlan->kobj != bat_priv->mesh_obj) {
++		kobject_uevent(vlan->kobj, KOBJ_REMOVE);
++		kobject_del(vlan->kobj);
++	}
+ 	kobject_put(vlan->kobj);
+ 	vlan->kobj = NULL;
+ out:
+@@ -801,6 +809,10 @@ void batadv_sysfs_del_vlan(struct batadv_priv *bat_priv,
+ 	for (bat_attr = batadv_vlan_attrs; *bat_attr; ++bat_attr)
+ 		sysfs_remove_file(vlan->kobj, &((*bat_attr)->attr));
+ 
++	if (vlan->kobj != bat_priv->mesh_obj) {
++		kobject_uevent(vlan->kobj, KOBJ_REMOVE);
++		kobject_del(vlan->kobj);
++	}
+ 	kobject_put(vlan->kobj);
+ 	vlan->kobj = NULL;
+ }
+@@ -1103,6 +1115,8 @@ out:
+ 
+ void batadv_sysfs_del_hardif(struct kobject **hardif_obj)
+ {
++	kobject_uevent(*hardif_obj, KOBJ_REMOVE);
++	kobject_del(*hardif_obj);
+ 	kobject_put(*hardif_obj);
+ 	*hardif_obj = NULL;
+ }
diff --git a/batman-adv/patches/0009-batman-adv-Remove-unused-primary_if-and-bat_priv-var.patch b/batman-adv/patches/0009-batman-adv-Remove-unused-primary_if-and-bat_priv-var.patch
new file mode 100644
index 0000000..3ef5d95
--- /dev/null
+++ b/batman-adv/patches/0009-batman-adv-Remove-unused-primary_if-and-bat_priv-var.patch
@@ -0,0 +1,58 @@
+From: Linus Lssing <linus.luessing@c0d3.blue>
+Date: Tue, 14 Jun 2016 22:56:50 +0200
+Subject: [PATCH] batman-adv: Remove unused primary_if and bat_priv variables
+
+Acked-by: Simon Wunderlich <sw@simonwunderlich.de>
+Fixes: 29b9256e6631 ("batman-adv: consider outgoing interface in OGM sending")
+Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
+Reviewed-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c | 19 ++++---------------
+ 1 file changed, 4 insertions(+), 15 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 19b0abd..6af4462 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -528,36 +528,25 @@ static void batadv_iv_ogm_send_to_if(struct batadv_forw_packet *forw_packet,
+ static void batadv_iv_ogm_emit(struct batadv_forw_packet *forw_packet)
+ {
+ 	struct net_device *soft_iface;
+-	struct batadv_priv *bat_priv;
+-	struct batadv_hard_iface *primary_if = NULL;
+ 
+ 	if (!forw_packet->if_incoming) {
+ 		pr_err("Error - can't forward packet: incoming iface not specified\n");
+-		goto out;
++		return;
+ 	}
+ 
+ 	soft_iface = forw_packet->if_incoming->soft_iface;
+-	bat_priv = netdev_priv(soft_iface);
+ 
+ 	if (WARN_ON(!forw_packet->if_outgoing))
+-		goto out;
++		return;
+ 
+ 	if (WARN_ON(forw_packet->if_outgoing->soft_iface != soft_iface))
+-		goto out;
++		return;
+ 
+ 	if (forw_packet->if_incoming->if_status != BATADV_IF_ACTIVE)
+-		goto out;
+-
+-	primary_if = batadv_primary_if_get_selected(bat_priv);
+-	if (!primary_if)
+-		goto out;
++		return;
+ 
+ 	/* only for one specific outgoing interface */
+ 	batadv_iv_ogm_send_to_if(forw_packet, forw_packet->if_outgoing);
+-
+-out:
+-	if (primary_if)
+-		batadv_hardif_put(primary_if);
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0010-batman-adv-make-the-GW-selection-class-algorithm-spe.patch b/batman-adv/patches/0010-batman-adv-make-the-GW-selection-class-algorithm-spe.patch
new file mode 100644
index 0000000..93a8aeb
--- /dev/null
+++ b/batman-adv/patches/0010-batman-adv-make-the-GW-selection-class-algorithm-spe.patch
@@ -0,0 +1,184 @@
+From: Antonio Quartulli <a@unstable.cc>
+Date: Sun, 3 Jul 2016 12:46:32 +0200
+Subject: [PATCH] batman-adv: make the GW selection class algorithm specific
+
+The B.A.T.M.A.N. V algorithm uses a different metric compared to its
+predecessor and for this reason the logic used to compute the best
+Gateway is also changed. This means that the GW selection class
+fed to this logic has a semantics that depends on the algorithm being
+used.
+
+Make the parsing and printing routine of the GW selection class
+routing algorithm specific. Each algorithm can now parse (and print)
+this value independently.
+
+If no API is provided by any algorithm, the default is to use the
+current mechanism of considering such value like an integer between
+1 and 255.
+
+Signed-off-by: Antonio Quartulli <a@unstable.cc>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_v.c | 34 ++++++++++++++++++++++++++++++++++
+ net/batman-adv/sysfs.c | 34 ++++++++++++++++++++++++++++++++--
+ net/batman-adv/types.h | 13 +++++++++++++
+ 3 files changed, 79 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index 0366cbf..90fd5ee 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -21,8 +21,10 @@
+ #include <linux/atomic.h>
+ #include <linux/bug.h>
+ #include <linux/cache.h>
++#include <linux/errno.h>
+ #include <linux/init.h>
+ #include <linux/jiffies.h>
++#include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+@@ -34,6 +36,8 @@
+ #include "bat_algo.h"
+ #include "bat_v_elp.h"
+ #include "bat_v_ogm.h"
++#include "gateway_client.h"
++#include "gateway_common.h"
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "originator.h"
+@@ -320,6 +324,32 @@ err_ifinfo1:
+ 	return ret;
+ }
+ 
++static ssize_t batadv_v_store_sel_class(struct batadv_priv *bat_priv,
++					char *buff, size_t count)
++{
++	u32 old_class, class;
++
++	if (!batadv_parse_throughput(bat_priv->soft_iface, buff,
++				     "B.A.T.M.A.N. V GW selection class",
++				     &class))
++		return -EINVAL;
++
++	old_class = atomic_read(&bat_priv->gw.sel_class);
++	atomic_set(&bat_priv->gw.sel_class, class);
++
++	if (old_class != class)
++		batadv_gw_reselect(bat_priv);
++
++	return count;
++}
++
++static ssize_t batadv_v_show_sel_class(struct batadv_priv *bat_priv, char *buff)
++{
++	u32 class = atomic_read(&bat_priv->gw.sel_class);
++
++	return sprintf(buff, "%u.%u MBit\n", class / 10, class % 10);
++}
++
+ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 	.name = "BATMAN_V",
+ 	.iface = {
+@@ -338,6 +368,10 @@ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 	.orig = {
+ 		.print = batadv_v_orig_print,
+ 	},
++	.gw = {
++		.store_sel_class = batadv_v_store_sel_class,
++		.show_sel_class = batadv_v_show_sel_class,
++	},
+ };
+ 
+ /**
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index 4e06cb7..e78bd7f 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -515,6 +515,36 @@ static ssize_t batadv_store_gw_mode(struct kobject *kobj,
+ 	return count;
+ }
+ 
++static ssize_t batadv_show_gw_sel_class(struct kobject *kobj,
++					struct attribute *attr, char *buff)
++{
++	struct batadv_priv *bat_priv = batadv_kobj_to_batpriv(kobj);
++
++	if (bat_priv->algo_ops->gw.show_sel_class)
++		return bat_priv->algo_ops->gw.show_sel_class(bat_priv, buff);
++
++	return sprintf(buff, "%i\n", atomic_read(&bat_priv->gw.sel_class));
++}
++
++static ssize_t batadv_store_gw_sel_class(struct kobject *kobj,
++					 struct attribute *attr, char *buff,
++					 size_t count)
++{
++	struct batadv_priv *bat_priv = batadv_kobj_to_batpriv(kobj);
++
++	if (buff[count - 1] == '\n')
++		buff[count - 1] = '\0';
++
++	if (bat_priv->algo_ops->gw.store_sel_class)
++		return bat_priv->algo_ops->gw.store_sel_class(bat_priv, buff,
++							      count);
++
++	return __batadv_store_uint_attr(buff, count, 1, BATADV_TQ_MAX_VALUE,
++					batadv_post_gw_reselect, attr,
++					&bat_priv->gw.sel_class,
++					bat_priv->soft_iface);
++}
++
+ static ssize_t batadv_show_gw_bwidth(struct kobject *kobj,
+ 				     struct attribute *attr, char *buff)
+ {
+@@ -626,8 +656,8 @@ BATADV_ATTR_SIF_UINT(orig_interval, orig_interval, S_IRUGO | S_IWUSR,
+ 		     2 * BATADV_JITTER, INT_MAX, NULL);
+ BATADV_ATTR_SIF_UINT(hop_penalty, hop_penalty, S_IRUGO | S_IWUSR, 0,
+ 		     BATADV_TQ_MAX_VALUE, NULL);
+-BATADV_ATTR_SIF_UINT(gw_sel_class, gw.sel_class, S_IRUGO | S_IWUSR, 1,
+-		     BATADV_TQ_MAX_VALUE, batadv_post_gw_reselect);
++static BATADV_ATTR(gw_sel_class, S_IRUGO | S_IWUSR, batadv_show_gw_sel_class,
++		   batadv_store_gw_sel_class);
+ static BATADV_ATTR(gw_bandwidth, S_IRUGO | S_IWUSR, batadv_show_gw_bwidth,
+ 		   batadv_store_gw_bwidth);
+ #ifdef CONFIG_BATMAN_ADV_MCAST
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 96af6da..deaadba 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1450,12 +1450,24 @@ struct batadv_algo_orig_ops {
+ };
+ 
+ /**
++ * struct batadv_algo_gw_ops - mesh algorithm callbacks (GW specific)
++ * @store_sel_class: parse and stores a new GW selection class (optional)
++ * @show_sel_class: prints the current GW selection class (optional)
++ */
++struct batadv_algo_gw_ops {
++	ssize_t (*store_sel_class)(struct batadv_priv *bat_priv, char *buff,
++				   size_t count);
++	ssize_t (*show_sel_class)(struct batadv_priv *bat_priv, char *buff);
++};
++
++/**
+  * struct batadv_algo_ops - mesh algorithm callbacks
+  * @list: list node for the batadv_algo_list
+  * @name: name of the algorithm
+  * @iface: callbacks related to interface handling
+  * @neigh: callbacks related to neighbors handling
+  * @orig: callbacks related to originators handling
++ * @gw: callbacks related to GW mode
+  */
+ struct batadv_algo_ops {
+ 	struct hlist_node list;
+@@ -1463,6 +1475,7 @@ struct batadv_algo_ops {
+ 	struct batadv_algo_iface_ops iface;
+ 	struct batadv_algo_neigh_ops neigh;
+ 	struct batadv_algo_orig_ops orig;
++	struct batadv_algo_gw_ops gw;
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0011-batman-adv-make-GW-election-code-protocol-specific.patch b/batman-adv/patches/0011-batman-adv-make-GW-election-code-protocol-specific.patch
new file mode 100644
index 0000000..ac991d5
--- /dev/null
+++ b/batman-adv/patches/0011-batman-adv-make-GW-election-code-protocol-specific.patch
@@ -0,0 +1,621 @@
+From: Antonio Quartulli <a@unstable.cc>
+Date: Sun, 3 Jul 2016 12:46:33 +0200
+Subject: [PATCH] batman-adv: make GW election code protocol specific
+
+Each routing protocol may have its own specific logic about
+gateway election which is potentially based on the metric being
+used.
+
+Create two GW specific API functions and move the current election
+logic in the B.A.T.M.A.N. IV specific code.
+
+Signed-off-by: Antonio Quartulli <a@unstable.cc>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c     | 219 ++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/gateway_client.c | 217 +++++----------------------------------
+ net/batman-adv/gateway_client.h |   3 +
+ net/batman-adv/gateway_common.c |   5 +-
+ net/batman-adv/types.h          |  11 ++
+ 5 files changed, 263 insertions(+), 192 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 6af4462..d04874f 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -51,6 +51,7 @@
+ 
+ #include "bat_algo.h"
+ #include "bitarray.h"
++#include "gateway_client.h"
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
+@@ -2106,6 +2107,219 @@ static void batadv_iv_iface_activate(struct batadv_hard_iface *hard_iface)
+ 	batadv_iv_ogm_schedule(hard_iface);
+ }
+ 
++static struct batadv_gw_node *
++batadv_iv_gw_get_best_gw_node(struct batadv_priv *bat_priv)
++{
++	struct batadv_neigh_node *router;
++	struct batadv_neigh_ifinfo *router_ifinfo;
++	struct batadv_gw_node *gw_node, *curr_gw = NULL;
++	u64 max_gw_factor = 0;
++	u64 tmp_gw_factor = 0;
++	u8 max_tq = 0;
++	u8 tq_avg;
++	struct batadv_orig_node *orig_node;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		orig_node = gw_node->orig_node;
++		router = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
++		if (!router)
++			continue;
++
++		router_ifinfo = batadv_neigh_ifinfo_get(router,
++							BATADV_IF_DEFAULT);
++		if (!router_ifinfo)
++			goto next;
++
++		if (!kref_get_unless_zero(&gw_node->refcount))
++			goto next;
++
++		tq_avg = router_ifinfo->bat_iv.tq_avg;
++
++		switch (atomic_read(&bat_priv->gw.sel_class)) {
++		case 1: /* fast connection */
++			tmp_gw_factor = tq_avg * tq_avg;
++			tmp_gw_factor *= gw_node->bandwidth_down;
++			tmp_gw_factor *= 100 * 100;
++			tmp_gw_factor >>= 18;
++
++			if ((tmp_gw_factor > max_gw_factor) ||
++			    ((tmp_gw_factor == max_gw_factor) &&
++			     (tq_avg > max_tq))) {
++				if (curr_gw)
++					batadv_gw_node_put(curr_gw);
++				curr_gw = gw_node;
++				kref_get(&curr_gw->refcount);
++			}
++			break;
++
++		default: /* 2:  stable connection (use best statistic)
++			  * 3:  fast-switch (use best statistic but change as
++			  *     soon as a better gateway appears)
++			  * XX: late-switch (use best statistic but change as
++			  *     soon as a better gateway appears which has
++			  *     $routing_class more tq points)
++			  */
++			if (tq_avg > max_tq) {
++				if (curr_gw)
++					batadv_gw_node_put(curr_gw);
++				curr_gw = gw_node;
++				kref_get(&curr_gw->refcount);
++			}
++			break;
++		}
++
++		if (tq_avg > max_tq)
++			max_tq = tq_avg;
++
++		if (tmp_gw_factor > max_gw_factor)
++			max_gw_factor = tmp_gw_factor;
++
++		batadv_gw_node_put(gw_node);
++
++next:
++		batadv_neigh_node_put(router);
++		if (router_ifinfo)
++			batadv_neigh_ifinfo_put(router_ifinfo);
++	}
++	rcu_read_unlock();
++
++	return curr_gw;
++}
++
++static bool batadv_iv_gw_is_eligible(struct batadv_priv *bat_priv,
++				     struct batadv_orig_node *curr_gw_orig,
++				     struct batadv_orig_node *orig_node)
++{
++	struct batadv_neigh_ifinfo *router_orig_ifinfo = NULL;
++	struct batadv_neigh_ifinfo *router_gw_ifinfo = NULL;
++	struct batadv_neigh_node *router_gw = NULL;
++	struct batadv_neigh_node *router_orig = NULL;
++	u8 gw_tq_avg, orig_tq_avg;
++	bool ret = false;
++
++	/* dynamic re-election is performed only on fast or late switch */
++	if (atomic_read(&bat_priv->gw.sel_class) <= 2)
++		return false;
++
++	router_gw = batadv_orig_router_get(curr_gw_orig, BATADV_IF_DEFAULT);
++	if (!router_gw) {
++		ret = true;
++		goto out;
++	}
++
++	router_gw_ifinfo = batadv_neigh_ifinfo_get(router_gw,
++						   BATADV_IF_DEFAULT);
++	if (!router_gw_ifinfo) {
++		ret = true;
++		goto out;
++	}
++
++	router_orig = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
++	if (!router_orig)
++		goto out;
++
++	router_orig_ifinfo = batadv_neigh_ifinfo_get(router_orig,
++						     BATADV_IF_DEFAULT);
++	if (!router_orig_ifinfo)
++		goto out;
++
++	gw_tq_avg = router_gw_ifinfo->bat_iv.tq_avg;
++	orig_tq_avg = router_orig_ifinfo->bat_iv.tq_avg;
++
++	/* the TQ value has to be better */
++	if (orig_tq_avg < gw_tq_avg)
++		goto out;
++
++	/* if the routing class is greater than 3 the value tells us how much
++	 * greater the TQ value of the new gateway must be
++	 */
++	if ((atomic_read(&bat_priv->gw.sel_class) > 3) &&
++	    (orig_tq_avg - gw_tq_avg < atomic_read(&bat_priv->gw.sel_class)))
++		goto out;
++
++	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
++		   "Restarting gateway selection: better gateway found (tq curr: %i, tq new: %i)\n",
++		   gw_tq_avg, orig_tq_avg);
++
++	ret = true;
++out:
++	if (router_gw_ifinfo)
++		batadv_neigh_ifinfo_put(router_gw_ifinfo);
++	if (router_orig_ifinfo)
++		batadv_neigh_ifinfo_put(router_orig_ifinfo);
++	if (router_gw)
++		batadv_neigh_node_put(router_gw);
++	if (router_orig)
++		batadv_neigh_node_put(router_orig);
++
++	return ret;
++}
++
++/* fails if orig_node has no router */
++static int batadv_iv_gw_write_buffer_text(struct batadv_priv *bat_priv,
++					  struct seq_file *seq,
++					  const struct batadv_gw_node *gw_node)
++{
++	struct batadv_gw_node *curr_gw;
++	struct batadv_neigh_node *router;
++	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
++	int ret = -1;
++
++	router = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);
++	if (!router)
++		goto out;
++
++	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
++	if (!router_ifinfo)
++		goto out;
++
++	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
++
++	seq_printf(seq, "%s %pM (%3i) %pM [%10s]: %u.%u/%u.%u MBit\n",
++		   (curr_gw == gw_node ? "=>" : "  "),
++		   gw_node->orig_node->orig,
++		   router_ifinfo->bat_iv.tq_avg, router->addr,
++		   router->if_incoming->net_dev->name,
++		   gw_node->bandwidth_down / 10,
++		   gw_node->bandwidth_down % 10,
++		   gw_node->bandwidth_up / 10,
++		   gw_node->bandwidth_up % 10);
++	ret = seq_has_overflowed(seq) ? -1 : 0;
++
++	if (curr_gw)
++		batadv_gw_node_put(curr_gw);
++out:
++	if (router_ifinfo)
++		batadv_neigh_ifinfo_put(router_ifinfo);
++	if (router)
++		batadv_neigh_node_put(router);
++	return ret;
++}
++
++static void batadv_iv_gw_print(struct batadv_priv *bat_priv,
++			       struct seq_file *seq)
++{
++	struct batadv_gw_node *gw_node;
++	int gw_count = 0;
++
++	seq_puts(seq,
++		 "      Gateway      (#/255)           Nexthop [outgoingIF]: advertised uplink bandwidth\n");
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		/* fails if orig_node has no router */
++		if (batadv_iv_gw_write_buffer_text(bat_priv, seq, gw_node) < 0)
++			continue;
++
++		gw_count++;
++	}
++	rcu_read_unlock();
++
++	if (gw_count == 0)
++		seq_puts(seq, "No gateways in range ...\n");
++}
++
+ static struct batadv_algo_ops batadv_batman_iv __read_mostly = {
+ 	.name = "BATMAN_IV",
+ 	.iface = {
+@@ -2126,6 +2340,11 @@ static struct batadv_algo_ops batadv_batman_iv __read_mostly = {
+ 		.add_if = batadv_iv_ogm_orig_add_if,
+ 		.del_if = batadv_iv_ogm_orig_del_if,
+ 	},
++	.gw = {
++		.get_best_gw_node = batadv_iv_gw_get_best_gw_node,
++		.is_eligible = batadv_iv_gw_is_eligible,
++		.print = batadv_iv_gw_print,
++	},
+ };
+ 
+ int __init batadv_iv_init(void)
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index 63a805d..ec363f3 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -80,12 +80,12 @@ static void batadv_gw_node_release(struct kref *ref)
+  * batadv_gw_node_put - decrement the gw_node refcounter and possibly release it
+  * @gw_node: gateway node to free
+  */
+-static void batadv_gw_node_put(struct batadv_gw_node *gw_node)
++void batadv_gw_node_put(struct batadv_gw_node *gw_node)
+ {
+ 	kref_put(&gw_node->refcount, batadv_gw_node_release);
+ }
+ 
+-static struct batadv_gw_node *
++struct batadv_gw_node *
+ batadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv)
+ {
+ 	struct batadv_gw_node *gw_node;
+@@ -164,86 +164,6 @@ void batadv_gw_reselect(struct batadv_priv *bat_priv)
+ 	atomic_set(&bat_priv->gw.reselect, 1);
+ }
+ 
+-static struct batadv_gw_node *
+-batadv_gw_get_best_gw_node(struct batadv_priv *bat_priv)
+-{
+-	struct batadv_neigh_node *router;
+-	struct batadv_neigh_ifinfo *router_ifinfo;
+-	struct batadv_gw_node *gw_node, *curr_gw = NULL;
+-	u64 max_gw_factor = 0;
+-	u64 tmp_gw_factor = 0;
+-	u8 max_tq = 0;
+-	u8 tq_avg;
+-	struct batadv_orig_node *orig_node;
+-
+-	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
+-		orig_node = gw_node->orig_node;
+-		router = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
+-		if (!router)
+-			continue;
+-
+-		router_ifinfo = batadv_neigh_ifinfo_get(router,
+-							BATADV_IF_DEFAULT);
+-		if (!router_ifinfo)
+-			goto next;
+-
+-		if (!kref_get_unless_zero(&gw_node->refcount))
+-			goto next;
+-
+-		tq_avg = router_ifinfo->bat_iv.tq_avg;
+-
+-		switch (atomic_read(&bat_priv->gw.sel_class)) {
+-		case 1: /* fast connection */
+-			tmp_gw_factor = tq_avg * tq_avg;
+-			tmp_gw_factor *= gw_node->bandwidth_down;
+-			tmp_gw_factor *= 100 * 100;
+-			tmp_gw_factor >>= 18;
+-
+-			if ((tmp_gw_factor > max_gw_factor) ||
+-			    ((tmp_gw_factor == max_gw_factor) &&
+-			     (tq_avg > max_tq))) {
+-				if (curr_gw)
+-					batadv_gw_node_put(curr_gw);
+-				curr_gw = gw_node;
+-				kref_get(&curr_gw->refcount);
+-			}
+-			break;
+-
+-		default: /* 2:  stable connection (use best statistic)
+-			  * 3:  fast-switch (use best statistic but change as
+-			  *     soon as a better gateway appears)
+-			  * XX: late-switch (use best statistic but change as
+-			  *     soon as a better gateway appears which has
+-			  *     $routing_class more tq points)
+-			  */
+-			if (tq_avg > max_tq) {
+-				if (curr_gw)
+-					batadv_gw_node_put(curr_gw);
+-				curr_gw = gw_node;
+-				kref_get(&curr_gw->refcount);
+-			}
+-			break;
+-		}
+-
+-		if (tq_avg > max_tq)
+-			max_tq = tq_avg;
+-
+-		if (tmp_gw_factor > max_gw_factor)
+-			max_gw_factor = tmp_gw_factor;
+-
+-		batadv_gw_node_put(gw_node);
+-
+-next:
+-		batadv_neigh_node_put(router);
+-		if (router_ifinfo)
+-			batadv_neigh_ifinfo_put(router_ifinfo);
+-	}
+-	rcu_read_unlock();
+-
+-	return curr_gw;
+-}
+-
+ /**
+  * batadv_gw_check_client_stop - check if client mode has been switched off
+  * @bat_priv: the bat priv with all the soft interface information
+@@ -287,12 +207,19 @@ void batadv_gw_election(struct batadv_priv *bat_priv)
+ 	if (atomic_read(&bat_priv->gw.mode) != BATADV_GW_MODE_CLIENT)
+ 		goto out;
+ 
++	if (!bat_priv->algo_ops->gw.get_best_gw_node)
++		goto out;
++
+ 	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
+ 
+ 	if (!batadv_atomic_dec_not_zero(&bat_priv->gw.reselect) && curr_gw)
+ 		goto out;
+ 
+-	next_gw = batadv_gw_get_best_gw_node(bat_priv);
++	/* if gw.reselect is set to 1 it means that a previous call to
++	 * gw.is_eligible() said that we have a new best GW, therefore it can
++	 * now be picked from the list and selected
++	 */
++	next_gw = bat_priv->algo_ops->gw.get_best_gw_node(bat_priv);
+ 
+ 	if (curr_gw == next_gw)
+ 		goto out;
+@@ -360,70 +287,31 @@ out:
+ void batadv_gw_check_election(struct batadv_priv *bat_priv,
+ 			      struct batadv_orig_node *orig_node)
+ {
+-	struct batadv_neigh_ifinfo *router_orig_tq = NULL;
+-	struct batadv_neigh_ifinfo *router_gw_tq = NULL;
+ 	struct batadv_orig_node *curr_gw_orig;
+-	struct batadv_neigh_node *router_gw = NULL;
+-	struct batadv_neigh_node *router_orig = NULL;
+-	u8 gw_tq_avg, orig_tq_avg;
++
++	/* abort immediately if the routing algorithm does not support gateway
++	 * election
++	 */
++	if (!bat_priv->algo_ops->gw.is_eligible)
++		return;
+ 
+ 	curr_gw_orig = batadv_gw_get_selected_orig(bat_priv);
+ 	if (!curr_gw_orig)
+ 		goto reselect;
+ 
+-	router_gw = batadv_orig_router_get(curr_gw_orig, BATADV_IF_DEFAULT);
+-	if (!router_gw)
+-		goto reselect;
+-
+-	router_gw_tq = batadv_neigh_ifinfo_get(router_gw,
+-					       BATADV_IF_DEFAULT);
+-	if (!router_gw_tq)
+-		goto reselect;
+-
+ 	/* this node already is the gateway */
+ 	if (curr_gw_orig == orig_node)
+ 		goto out;
+ 
+-	router_orig = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
+-	if (!router_orig)
++	if (!bat_priv->algo_ops->gw.is_eligible(bat_priv, curr_gw_orig,
++						orig_node))
+ 		goto out;
+ 
+-	router_orig_tq = batadv_neigh_ifinfo_get(router_orig,
+-						 BATADV_IF_DEFAULT);
+-	if (!router_orig_tq)
+-		goto out;
+-
+-	gw_tq_avg = router_gw_tq->bat_iv.tq_avg;
+-	orig_tq_avg = router_orig_tq->bat_iv.tq_avg;
+-
+-	/* the TQ value has to be better */
+-	if (orig_tq_avg < gw_tq_avg)
+-		goto out;
+-
+-	/* if the routing class is greater than 3 the value tells us how much
+-	 * greater the TQ value of the new gateway must be
+-	 */
+-	if ((atomic_read(&bat_priv->gw.sel_class) > 3) &&
+-	    (orig_tq_avg - gw_tq_avg < atomic_read(&bat_priv->gw.sel_class)))
+-		goto out;
+-
+-	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+-		   "Restarting gateway selection: better gateway found (tq curr: %i, tq new: %i)\n",
+-		   gw_tq_avg, orig_tq_avg);
+-
+ reselect:
+ 	batadv_gw_reselect(bat_priv);
+ out:
+ 	if (curr_gw_orig)
+ 		batadv_orig_node_put(curr_gw_orig);
+-	if (router_gw)
+-		batadv_neigh_node_put(router_gw);
+-	if (router_orig)
+-		batadv_neigh_node_put(router_orig);
+-	if (router_gw_tq)
+-		batadv_neigh_ifinfo_put(router_gw_tq);
+-	if (router_orig_tq)
+-		batadv_neigh_ifinfo_put(router_orig_tq);
+ }
+ 
+ /**
+@@ -585,80 +473,31 @@ void batadv_gw_node_free(struct batadv_priv *bat_priv)
+ 	spin_unlock_bh(&bat_priv->gw.list_lock);
+ }
+ 
+-/* fails if orig_node has no router */
+-static int batadv_write_buffer_text(struct batadv_priv *bat_priv,
+-				    struct seq_file *seq,
+-				    const struct batadv_gw_node *gw_node)
+-{
+-	struct batadv_gw_node *curr_gw;
+-	struct batadv_neigh_node *router;
+-	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
+-	int ret = -1;
+-
+-	router = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);
+-	if (!router)
+-		goto out;
+-
+-	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
+-	if (!router_ifinfo)
+-		goto out;
+-
+-	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
+-
+-	seq_printf(seq, "%s %pM (%3i) %pM [%10s]: %u.%u/%u.%u MBit\n",
+-		   (curr_gw == gw_node ? "=>" : "  "),
+-		   gw_node->orig_node->orig,
+-		   router_ifinfo->bat_iv.tq_avg, router->addr,
+-		   router->if_incoming->net_dev->name,
+-		   gw_node->bandwidth_down / 10,
+-		   gw_node->bandwidth_down % 10,
+-		   gw_node->bandwidth_up / 10,
+-		   gw_node->bandwidth_up % 10);
+-	ret = seq_has_overflowed(seq) ? -1 : 0;
+-
+-	if (curr_gw)
+-		batadv_gw_node_put(curr_gw);
+-out:
+-	if (router_ifinfo)
+-		batadv_neigh_ifinfo_put(router_ifinfo);
+-	if (router)
+-		batadv_neigh_node_put(router);
+-	return ret;
+-}
+-
+ int batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset)
+ {
+ 	struct net_device *net_dev = (struct net_device *)seq->private;
+ 	struct batadv_priv *bat_priv = netdev_priv(net_dev);
+ 	struct batadv_hard_iface *primary_if;
+-	struct batadv_gw_node *gw_node;
+-	int gw_count = 0;
+ 
+ 	primary_if = batadv_seq_print_text_primary_if_get(seq);
+ 	if (!primary_if)
+-		goto out;
++		return 0;
+ 
+-	seq_printf(seq,
+-		   "      Gateway      (#/255)           Nexthop [outgoingIF]: advertised uplink bandwidth ... [B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s)]\n",
++	seq_printf(seq, "[B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s %s)]\n",
+ 		   BATADV_SOURCE_VERSION, primary_if->net_dev->name,
+-		   primary_if->net_dev->dev_addr, net_dev->name);
++		   primary_if->net_dev->dev_addr, net_dev->name,
++		   bat_priv->algo_ops->name);
+ 
+-	rcu_read_lock();
+-	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
+-		/* fails if orig_node has no router */
+-		if (batadv_write_buffer_text(bat_priv, seq, gw_node) < 0)
+-			continue;
++	batadv_hardif_put(primary_if);
+ 
+-		gw_count++;
++	if (!bat_priv->algo_ops->gw.print) {
++		seq_puts(seq,
++			 "No printing function for this routing protocol\n");
++		return 0;
+ 	}
+-	rcu_read_unlock();
+ 
+-	if (gw_count == 0)
+-		seq_puts(seq, "No gateways in range ...\n");
++	bat_priv->algo_ops->gw.print(bat_priv, seq);
+ 
+-out:
+-	if (primary_if)
+-		batadv_hardif_put(primary_if);
+ 	return 0;
+ }
+ 
+diff --git a/net/batman-adv/gateway_client.h b/net/batman-adv/gateway_client.h
+index 582dd8c..4c9edde 100644
+--- a/net/batman-adv/gateway_client.h
++++ b/net/batman-adv/gateway_client.h
+@@ -39,6 +39,9 @@ void batadv_gw_node_update(struct batadv_priv *bat_priv,
+ void batadv_gw_node_delete(struct batadv_priv *bat_priv,
+ 			   struct batadv_orig_node *orig_node);
+ void batadv_gw_node_free(struct batadv_priv *bat_priv);
++void batadv_gw_node_put(struct batadv_gw_node *gw_node);
++struct batadv_gw_node *
++batadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv);
+ int batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset);
+ bool batadv_gw_out_of_range(struct batadv_priv *bat_priv, struct sk_buff *skb);
+ enum batadv_dhcp_recipient
+diff --git a/net/batman-adv/gateway_common.c b/net/batman-adv/gateway_common.c
+index d7bc6a8..2118481 100644
+--- a/net/batman-adv/gateway_common.c
++++ b/net/batman-adv/gateway_common.c
+@@ -241,10 +241,9 @@ static void batadv_gw_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,
+ 
+ 	batadv_gw_node_update(bat_priv, orig, &gateway);
+ 
+-	/* restart gateway selection if fast or late switching was enabled */
++	/* restart gateway selection */
+ 	if ((gateway.bandwidth_down != 0) &&
+-	    (atomic_read(&bat_priv->gw.mode) == BATADV_GW_MODE_CLIENT) &&
+-	    (atomic_read(&bat_priv->gw.sel_class) > 2))
++	    (atomic_read(&bat_priv->gw.mode) == BATADV_GW_MODE_CLIENT))
+ 		batadv_gw_check_election(bat_priv, orig);
+ }
+ 
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index deaadba..54710c7 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1453,11 +1453,22 @@ struct batadv_algo_orig_ops {
+  * struct batadv_algo_gw_ops - mesh algorithm callbacks (GW specific)
+  * @store_sel_class: parse and stores a new GW selection class (optional)
+  * @show_sel_class: prints the current GW selection class (optional)
++ * @get_best_gw_node: select the best GW from the list of available nodes
++ *  (optional)
++ * @is_eligible: check if a newly discovered GW is a potential candidate for
++ *  the election as best GW (optional)
++ * @print: print the gateway table (optional)
+  */
+ struct batadv_algo_gw_ops {
+ 	ssize_t (*store_sel_class)(struct batadv_priv *bat_priv, char *buff,
+ 				   size_t count);
+ 	ssize_t (*show_sel_class)(struct batadv_priv *bat_priv, char *buff);
++	struct batadv_gw_node *(*get_best_gw_node)
++		(struct batadv_priv *bat_priv);
++	bool (*is_eligible)(struct batadv_priv *bat_priv,
++			    struct batadv_orig_node *curr_gw_orig,
++			    struct batadv_orig_node *orig_node);
++	void (*print)(struct batadv_priv *bat_priv, struct seq_file *seq);
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0012-batman-adv-B.A.T.M.A.N.-V-implement-GW-selection-log.patch b/batman-adv/patches/0012-batman-adv-B.A.T.M.A.N.-V-implement-GW-selection-log.patch
new file mode 100644
index 0000000..ce9548d
--- /dev/null
+++ b/batman-adv/patches/0012-batman-adv-B.A.T.M.A.N.-V-implement-GW-selection-log.patch
@@ -0,0 +1,310 @@
+From: Antonio Quartulli <a@unstable.cc>
+Date: Sun, 3 Jul 2016 12:46:34 +0200
+Subject: [PATCH] batman-adv: B.A.T.M.A.N. V - implement GW selection logic
+
+Since the GW selection logic has been made routing protocol specific
+it is now possible for B.A.T.M.A.N V to have its own mechanism by
+providing the API implementation.
+
+Implement the GW specific API in the B.A.T.M.A.N. V protocol in
+order to provide a working GW selection mechanism.
+
+Signed-off-by: Antonio Quartulli <a@unstable.cc>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_v.c          | 223 +++++++++++++++++++++++++++++++++++++++-
+ net/batman-adv/gateway_client.c |   5 +-
+ net/batman-adv/gateway_client.h |   2 +
+ 3 files changed, 226 insertions(+), 4 deletions(-)
+
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index 90fd5ee..1d777b1 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -25,6 +25,7 @@
+ #include <linux/init.h>
+ #include <linux/jiffies.h>
+ #include <linux/kernel.h>
++#include <linux/kref.h>
+ #include <linux/netdevice.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+@@ -40,6 +41,7 @@
+ #include "gateway_common.h"
+ #include "hard-interface.h"
+ #include "hash.h"
++#include "log.h"
+ #include "originator.h"
+ #include "packet.h"
+ 
+@@ -350,6 +352,213 @@ static ssize_t batadv_v_show_sel_class(struct batadv_priv *bat_priv, char *buff)
+ 	return sprintf(buff, "%u.%u MBit\n", class / 10, class % 10);
+ }
+ 
++/**
++ * batadv_v_gw_throughput_get - retrieve the GW-bandwidth for a given GW
++ * @gw_node: the GW to retrieve the metric for
++ * @bw: the pointer where the metric will be stored. The metric is computed as
++ *  the minimum between the GW advertised throughput and the path throughput to
++ *  it in the mesh
++ *
++ * Return: 0 on success, -1 on failure
++ */
++static int batadv_v_gw_throughput_get(struct batadv_gw_node *gw_node, u32 *bw)
++{
++	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
++	struct batadv_orig_node *orig_node;
++	struct batadv_neigh_node *router;
++	int ret = -1;
++
++	orig_node = gw_node->orig_node;
++	router = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);
++	if (!router)
++		goto out;
++
++	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
++	if (!router_ifinfo)
++		goto out;
++
++	/* the GW metric is computed as the minimum between the path throughput
++	 * to reach the GW itself and the advertised bandwidth.
++	 * This gives us an approximation of the effective throughput that the
++	 * client can expect via this particular GW node
++	 */
++	*bw = router_ifinfo->bat_v.throughput;
++	*bw = min_t(u32, *bw, gw_node->bandwidth_down);
++
++	ret = 0;
++out:
++	if (router)
++		batadv_neigh_node_put(router);
++	if (router_ifinfo)
++		batadv_neigh_ifinfo_put(router_ifinfo);
++
++	return ret;
++}
++
++/**
++ * batadv_v_gw_get_best_gw_node - retrieve the best GW node
++ * @bat_priv: the bat priv with all the soft interface information
++ *
++ * Return: the GW node having the best GW-metric, NULL if no GW is known
++ */
++static struct batadv_gw_node *
++batadv_v_gw_get_best_gw_node(struct batadv_priv *bat_priv)
++{
++	struct batadv_gw_node *gw_node, *curr_gw = NULL;
++	u32 max_bw = 0, bw;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		if (!kref_get_unless_zero(&gw_node->refcount))
++			continue;
++
++		if (batadv_v_gw_throughput_get(gw_node, &bw) < 0)
++			goto next;
++
++		if (curr_gw && (bw <= max_bw))
++			goto next;
++
++		if (curr_gw)
++			batadv_gw_node_put(curr_gw);
++
++		curr_gw = gw_node;
++		kref_get(&curr_gw->refcount);
++		max_bw = bw;
++
++next:
++		batadv_gw_node_put(gw_node);
++	}
++	rcu_read_unlock();
++
++	return curr_gw;
++}
++
++/**
++ * batadv_v_gw_is_eligible - check if a originator would be selected as GW
++ * @bat_priv: the bat priv with all the soft interface information
++ * @curr_gw_orig: originator representing the currently selected GW
++ * @orig_node: the originator representing the new candidate
++ *
++ * Return: true if orig_node can be selected as current GW, false otherwise
++ */
++static bool batadv_v_gw_is_eligible(struct batadv_priv *bat_priv,
++				    struct batadv_orig_node *curr_gw_orig,
++				    struct batadv_orig_node *orig_node)
++{
++	struct batadv_gw_node *curr_gw = NULL, *orig_gw = NULL;
++	u32 gw_throughput, orig_throughput, threshold;
++	bool ret = false;
++
++	threshold = atomic_read(&bat_priv->gw.sel_class);
++
++	curr_gw = batadv_gw_node_get(bat_priv, curr_gw_orig);
++	if (!curr_gw) {
++		ret = true;
++		goto out;
++	}
++
++	if (batadv_v_gw_throughput_get(curr_gw, &gw_throughput) < 0) {
++		ret = true;
++		goto out;
++	}
++
++	orig_gw = batadv_gw_node_get(bat_priv, orig_node);
++	if (!orig_node)
++		goto out;
++
++	if (batadv_v_gw_throughput_get(orig_gw, &orig_throughput) < 0)
++		goto out;
++
++	if (orig_throughput < gw_throughput)
++		goto out;
++
++	if ((orig_throughput - gw_throughput) < threshold)
++		goto out;
++
++	batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
++		   "Restarting gateway selection: better gateway found (throughput curr: %u, throughput new: %u)\n",
++		   gw_throughput, orig_throughput);
++
++	ret = true;
++out:
++	if (curr_gw)
++		batadv_gw_node_put(curr_gw);
++	if (orig_gw)
++		batadv_gw_node_put(orig_gw);
++
++	return ret;
++}
++
++/* fails if orig_node has no router */
++static int batadv_v_gw_write_buffer_text(struct batadv_priv *bat_priv,
++					 struct seq_file *seq,
++					 const struct batadv_gw_node *gw_node)
++{
++	struct batadv_gw_node *curr_gw;
++	struct batadv_neigh_node *router;
++	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
++	int ret = -1;
++
++	router = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);
++	if (!router)
++		goto out;
++
++	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
++	if (!router_ifinfo)
++		goto out;
++
++	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
++
++	seq_printf(seq, "%s %pM (%9u.%1u) %pM [%10s]: %u.%u/%u.%u MBit\n",
++		   (curr_gw == gw_node ? "=>" : "  "),
++		   gw_node->orig_node->orig,
++		   router_ifinfo->bat_v.throughput / 10,
++		   router_ifinfo->bat_v.throughput % 10, router->addr,
++		   router->if_incoming->net_dev->name,
++		   gw_node->bandwidth_down / 10,
++		   gw_node->bandwidth_down % 10,
++		   gw_node->bandwidth_up / 10,
++		   gw_node->bandwidth_up % 10);
++	ret = seq_has_overflowed(seq) ? -1 : 0;
++
++	if (curr_gw)
++		batadv_gw_node_put(curr_gw);
++out:
++	if (router_ifinfo)
++		batadv_neigh_ifinfo_put(router_ifinfo);
++	if (router)
++		batadv_neigh_node_put(router);
++	return ret;
++}
++
++/**
++ * batadv_v_gw_print - print the gateway list
++ * @bat_priv: the bat priv with all the soft interface information
++ * @seq: gateway table seq_file struct
++ */
++static void batadv_v_gw_print(struct batadv_priv *bat_priv,
++			      struct seq_file *seq)
++{
++	struct batadv_gw_node *gw_node;
++	int gw_count = 0;
++
++	seq_puts(seq,
++		 "      Gateway        ( throughput)           Nexthop [outgoingIF]: advertised uplink bandwidth\n");
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		/* fails if orig_node has no router */
++		if (batadv_v_gw_write_buffer_text(bat_priv, seq, gw_node) < 0)
++			continue;
++
++		gw_count++;
++	}
++	rcu_read_unlock();
++
++	if (gw_count == 0)
++		seq_puts(seq, "No gateways in range ...\n");
++}
++
+ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 	.name = "BATMAN_V",
+ 	.iface = {
+@@ -371,6 +580,9 @@ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 	.gw = {
+ 		.store_sel_class = batadv_v_store_sel_class,
+ 		.show_sel_class = batadv_v_show_sel_class,
++		.get_best_gw_node = batadv_v_gw_get_best_gw_node,
++		.is_eligible = batadv_v_gw_is_eligible,
++		.print = batadv_v_gw_print,
+ 	},
+ };
+ 
+@@ -397,7 +609,16 @@ void batadv_v_hardif_init(struct batadv_hard_iface *hard_iface)
+  */
+ int batadv_v_mesh_init(struct batadv_priv *bat_priv)
+ {
+-	return batadv_v_ogm_init(bat_priv);
++	int ret = 0;
++
++	ret = batadv_v_ogm_init(bat_priv);
++	if (ret < 0)
++		return ret;
++
++	/* set default throughput difference threshold to 5Mbps */
++	atomic_set(&bat_priv->gw.sel_class, 50);
++
++	return 0;
+ }
+ 
+ /**
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index ec363f3..a77a179 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -360,9 +360,8 @@ static void batadv_gw_node_add(struct batadv_priv *bat_priv,
+  *
+  * Return: gateway node if found or NULL otherwise.
+  */
+-static struct batadv_gw_node *
+-batadv_gw_node_get(struct batadv_priv *bat_priv,
+-		   struct batadv_orig_node *orig_node)
++struct batadv_gw_node *batadv_gw_node_get(struct batadv_priv *bat_priv,
++					  struct batadv_orig_node *orig_node)
+ {
+ 	struct batadv_gw_node *gw_node_tmp, *gw_node = NULL;
+ 
+diff --git a/net/batman-adv/gateway_client.h b/net/batman-adv/gateway_client.h
+index 4c9edde..6b40432 100644
+--- a/net/batman-adv/gateway_client.h
++++ b/net/batman-adv/gateway_client.h
+@@ -47,5 +47,7 @@ bool batadv_gw_out_of_range(struct batadv_priv *bat_priv, struct sk_buff *skb);
+ enum batadv_dhcp_recipient
+ batadv_gw_dhcp_recipient_get(struct sk_buff *skb, unsigned int *header_len,
+ 			     u8 *chaddr);
++struct batadv_gw_node *batadv_gw_node_get(struct batadv_priv *bat_priv,
++					  struct batadv_orig_node *orig_node);
+ 
+ #endif /* _NET_BATMAN_ADV_GATEWAY_CLIENT_H_ */
diff --git a/batman-adv/patches/0013-batman-adv-disable-sysfs-knobs-when-GW-mode-is-not-i.patch b/batman-adv/patches/0013-batman-adv-disable-sysfs-knobs-when-GW-mode-is-not-i.patch
new file mode 100644
index 0000000..c5414a0
--- /dev/null
+++ b/batman-adv/patches/0013-batman-adv-disable-sysfs-knobs-when-GW-mode-is-not-i.patch
@@ -0,0 +1,79 @@
+From: Antonio Quartulli <a@unstable.cc>
+Date: Sun, 3 Jul 2016 12:46:35 +0200
+Subject: [PATCH] batman-adv: disable sysfs knobs when GW-mode is not implemented
+
+Now that the GW-mode code is algorithm specific, batman-adv expects the
+routing algorithm to implement some APIs to make it work.
+
+However, such APIs are not mandatory, therefore we might have algorithms
+not providing them. In this case all the sysfs knobs related to GW-mode
+should be deactivated to make sure that settings injected by the user
+for this feature are rejected.
+
+Signed-off-by: Antonio Quartulli <a@unstable.cc>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/sysfs.c | 28 ++++++++++++++++++++++++++++
+ 1 file changed, 28 insertions(+)
+
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index e78bd7f..02d96f2 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -429,6 +429,13 @@ static ssize_t batadv_show_gw_mode(struct kobject *kobj, struct attribute *attr,
+ 	struct batadv_priv *bat_priv = batadv_kobj_to_batpriv(kobj);
+ 	int bytes_written;
+ 
++	/* GW mode is not available if the routing algorithm in use does not
++	 * implement the GW API
++	 */
++	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
++	    !bat_priv->algo_ops->gw.is_eligible)
++		return -ENOENT;
++
+ 	switch (atomic_read(&bat_priv->gw.mode)) {
+ 	case BATADV_GW_MODE_CLIENT:
+ 		bytes_written = sprintf(buff, "%s\n",
+@@ -456,6 +463,13 @@ static ssize_t batadv_store_gw_mode(struct kobject *kobj,
+ 	char *curr_gw_mode_str;
+ 	int gw_mode_tmp = -1;
+ 
++	/* toggling GW mode is allowed only if the routing algorithm in use
++	 * provides the GW API
++	 */
++	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
++	    !bat_priv->algo_ops->gw.is_eligible)
++		return -EINVAL;
++
+ 	if (buff[count - 1] == '\n')
+ 		buff[count - 1] = '\0';
+ 
+@@ -520,6 +534,13 @@ static ssize_t batadv_show_gw_sel_class(struct kobject *kobj,
+ {
+ 	struct batadv_priv *bat_priv = batadv_kobj_to_batpriv(kobj);
+ 
++	/* GW selection class is not available if the routing algorithm in use
++	 * does not implement the GW API
++	 */
++	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
++	    !bat_priv->algo_ops->gw.is_eligible)
++		return -ENOENT;
++
+ 	if (bat_priv->algo_ops->gw.show_sel_class)
+ 		return bat_priv->algo_ops->gw.show_sel_class(bat_priv, buff);
+ 
+@@ -532,6 +553,13 @@ static ssize_t batadv_store_gw_sel_class(struct kobject *kobj,
+ {
+ 	struct batadv_priv *bat_priv = batadv_kobj_to_batpriv(kobj);
+ 
++	/* setting the GW selection class is allowed only if the routing
++	 * algorithm in use implements the GW API
++	 */
++	if (!bat_priv->algo_ops->gw.get_best_gw_node ||
++	    !bat_priv->algo_ops->gw.is_eligible)
++		return -EINVAL;
++
+ 	if (buff[count - 1] == '\n')
+ 		buff[count - 1] = '\0';
+ 
diff --git a/batman-adv/patches/0014-batman-adv-iv_ogm-Reduce-code-duplication.patch b/batman-adv/patches/0014-batman-adv-iv_ogm-Reduce-code-duplication.patch
new file mode 100644
index 0000000..1cac32b
--- /dev/null
+++ b/batman-adv/patches/0014-batman-adv-iv_ogm-Reduce-code-duplication.patch
@@ -0,0 +1,145 @@
+From: Markus Pargmann <mpa@pengutronix.de>
+Date: Sun, 3 Jul 2016 11:07:14 +0200
+Subject: [PATCH] batman-adv: iv_ogm, Reduce code duplication
+
+The difference between tq1 and tq2 are calculated the same way in two
+separate functions.
+
+This patch moves the common code to a seperate function
+'batadv_iv_ogm_neigh_diff' which handles everything necessary. The other
+two functions can then handle errors and use the difference directly.
+
+Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
+[sven@narfation.org: rebased on current version, initialize return variable
+in batadv_iv_ogm_neigh_diff, add kerneldoc, convert to bool return type]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c | 95 ++++++++++++++++++++++++++-------------------
+ 1 file changed, 56 insertions(+), 39 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index d04874f..57e0af9 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -2019,6 +2019,51 @@ static void batadv_iv_neigh_print(struct batadv_priv *bat_priv,
+ }
+ 
+ /**
++ * batadv_iv_ogm_neigh_diff - calculate tq difference of two neighbors
++ * @neigh1: the first neighbor object of the comparison
++ * @if_outgoing1: outgoing interface for the first neighbor
++ * @neigh2: the second neighbor object of the comparison
++ * @if_outgoing2: outgoing interface for the second neighbor
++ * @diff: pointer to integer receiving the calculated difference
++ *
++ * The content of *@diff is only valid when this function returns true.
++ * It is less, equal to or greater than 0 if the metric via neigh1 is lower,
++ * the same as or higher than the metric via neigh2
++ *
++ * Return: true when the difference could be calculated, false otherwise
++ */
++static bool batadv_iv_ogm_neigh_diff(struct batadv_neigh_node *neigh1,
++				     struct batadv_hard_iface *if_outgoing1,
++				     struct batadv_neigh_node *neigh2,
++				     struct batadv_hard_iface *if_outgoing2,
++				     int *diff)
++{
++	struct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;
++	u8 tq1, tq2;
++	bool ret = true;
++
++	neigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
++	neigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
++
++	if (!neigh1_ifinfo || !neigh2_ifinfo) {
++		ret = false;
++		goto out;
++	}
++
++	tq1 = neigh1_ifinfo->bat_iv.tq_avg;
++	tq2 = neigh2_ifinfo->bat_iv.tq_avg;
++	*diff = (int)tq1 - (int)tq2;
++
++out:
++	if (neigh1_ifinfo)
++		batadv_neigh_ifinfo_put(neigh1_ifinfo);
++	if (neigh2_ifinfo)
++		batadv_neigh_ifinfo_put(neigh2_ifinfo);
++
++	return ret;
++}
++
++/**
+  * batadv_iv_ogm_neigh_cmp - compare the metrics of two neighbors
+  * @neigh1: the first neighbor object of the comparison
+  * @if_outgoing1: outgoing interface for the first neighbor
+@@ -2033,27 +2078,13 @@ static int batadv_iv_ogm_neigh_cmp(struct batadv_neigh_node *neigh1,
+ 				   struct batadv_neigh_node *neigh2,
+ 				   struct batadv_hard_iface *if_outgoing2)
+ {
+-	struct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;
+-	u8 tq1, tq2;
++	bool ret;
+ 	int diff;
+ 
+-	neigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
+-	neigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
+-
+-	if (!neigh1_ifinfo || !neigh2_ifinfo) {
+-		diff = 0;
+-		goto out;
+-	}
+-
+-	tq1 = neigh1_ifinfo->bat_iv.tq_avg;
+-	tq2 = neigh2_ifinfo->bat_iv.tq_avg;
+-	diff = tq1 - tq2;
+-
+-out:
+-	if (neigh1_ifinfo)
+-		batadv_neigh_ifinfo_put(neigh1_ifinfo);
+-	if (neigh2_ifinfo)
+-		batadv_neigh_ifinfo_put(neigh2_ifinfo);
++	ret = batadv_iv_ogm_neigh_diff(neigh1, if_outgoing1, neigh2,
++				       if_outgoing2, &diff);
++	if (!ret)
++		return 0;
+ 
+ 	return diff;
+ }
+@@ -2075,29 +2106,15 @@ batadv_iv_ogm_neigh_is_sob(struct batadv_neigh_node *neigh1,
+ 			   struct batadv_neigh_node *neigh2,
+ 			   struct batadv_hard_iface *if_outgoing2)
+ {
+-	struct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;
+-	u8 tq1, tq2;
+ 	bool ret;
++	int diff;
+ 
+-	neigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
+-	neigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
+-
+-	/* we can't say that the metric is better */
+-	if (!neigh1_ifinfo || !neigh2_ifinfo) {
+-		ret = false;
+-		goto out;
+-	}
+-
+-	tq1 = neigh1_ifinfo->bat_iv.tq_avg;
+-	tq2 = neigh2_ifinfo->bat_iv.tq_avg;
+-	ret = (tq1 - tq2) > -BATADV_TQ_SIMILARITY_THRESHOLD;
+-
+-out:
+-	if (neigh1_ifinfo)
+-		batadv_neigh_ifinfo_put(neigh1_ifinfo);
+-	if (neigh2_ifinfo)
+-		batadv_neigh_ifinfo_put(neigh2_ifinfo);
++	ret = batadv_iv_ogm_neigh_diff(neigh1, if_outgoing1, neigh2,
++				       if_outgoing2, &diff);
++	if (!ret)
++		return false;
+ 
++	ret = diff > -BATADV_TQ_SIMILARITY_THRESHOLD;
+ 	return ret;
+ }
+ 
diff --git a/batman-adv/patches/0015-batman-adv-fix-boolreturn.cocci-warnings.patch b/batman-adv/patches/0015-batman-adv-fix-boolreturn.cocci-warnings.patch
new file mode 100644
index 0000000..1fc1c94
--- /dev/null
+++ b/batman-adv/patches/0015-batman-adv-fix-boolreturn.cocci-warnings.patch
@@ -0,0 +1,31 @@
+From: kbuild test robot <fengguang.wu@intel.com>
+Date: Wed, 6 Jul 2016 10:49:29 +0800
+Subject: [PATCH] batman-adv: fix boolreturn.cocci warnings
+
+net/batman-adv/bridge_loop_avoidance.c:1105:9-10: WARNING: return of 0/1 in function 'batadv_bla_process_claim' with return type bool
+
+ Return statements in functions returning bool should use
+ true/false instead of 1/0.
+Generated by: scripts/coccinelle/misc/boolreturn.cocci
+
+CC: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
+Reviewed-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bridge_loop_avoidance.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
+index ad2ffe1..c75ef64 100644
+--- a/net/batman-adv/bridge_loop_avoidance.c
++++ b/net/batman-adv/bridge_loop_avoidance.c
+@@ -1148,7 +1148,7 @@ static bool batadv_bla_process_claim(struct batadv_priv *bat_priv,
+ 
+ 	/* Let the loopdetect frames on the mesh in any case. */
+ 	if (bla_dst->type == BATADV_CLAIM_TYPE_LOOPDETECT)
+-		return 0;
++		return false;
+ 
+ 	/* check if it is a claim frame. */
+ 	ret = batadv_check_claim_group(bat_priv, primary_if, hw_src, hw_dst,
diff --git a/batman-adv/patches/0016-batman-adv-Introduce-forward-packet-creation-helper.patch b/batman-adv/patches/0016-batman-adv-Introduce-forward-packet-creation-helper.patch
new file mode 100644
index 0000000..fef6952
--- /dev/null
+++ b/batman-adv/patches/0016-batman-adv-Introduce-forward-packet-creation-helper.patch
@@ -0,0 +1,321 @@
+From: Linus Lssing <linus.luessing@c0d3.blue>
+Date: Mon, 20 Jun 2016 21:39:54 +0200
+Subject: [PATCH] batman-adv: Introduce forward packet creation helper
+
+This patch abstracts the forward packet creation into the new function
+batadv_forw_packet_alloc().
+
+The queue counting and interface reference counters are now handled
+internally within batadv_forw_packet_alloc() and its
+batadv_forw_packet_free() counterpart. This should reduce the risk of
+having reference/queue counting bugs again and should increase
+code readibility.
+
+Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
+Reviewed-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c |  38 ++++-----------
+ net/batman-adv/send.c       | 111 ++++++++++++++++++++++++++++++++------------
+ net/batman-adv/send.h       |   6 +++
+ net/batman-adv/types.h      |   2 +
+ 4 files changed, 98 insertions(+), 59 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 57e0af9..a40cdf2 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -675,19 +675,12 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 	struct batadv_forw_packet *forw_packet_aggr;
+ 	unsigned char *skb_buff;
+ 	unsigned int skb_size;
++	atomic_t *queue_left = own_packet ? NULL : &bat_priv->batman_queue_left;
+ 
+-	/* own packet should always be scheduled */
+-	if (!own_packet) {
+-		if (!batadv_atomic_dec_not_zero(&bat_priv->batman_queue_left)) {
+-			batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+-				   "batman packet queue full\n");
+-			return;
+-		}
+-	}
+-
+-	forw_packet_aggr = kmalloc(sizeof(*forw_packet_aggr), GFP_ATOMIC);
++	forw_packet_aggr = batadv_forw_packet_alloc(if_incoming, if_outgoing,
++						    queue_left, bat_priv);
+ 	if (!forw_packet_aggr)
+-		goto out_nomem;
++		return;
+ 
+ 	if (atomic_read(&bat_priv->aggregated_ogms) &&
+ 	    packet_len < BATADV_MAX_AGGREGATION_BYTES)
+@@ -698,8 +691,11 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 	skb_size += ETH_HLEN;
+ 
+ 	forw_packet_aggr->skb = netdev_alloc_skb_ip_align(NULL, skb_size);
+-	if (!forw_packet_aggr->skb)
+-		goto out_free_forw_packet;
++	if (!forw_packet_aggr->skb) {
++		batadv_forw_packet_free(forw_packet_aggr);
++		return;
++	}
++
+ 	forw_packet_aggr->skb->priority = TC_PRIO_CONTROL;
+ 	skb_reserve(forw_packet_aggr->skb, ETH_HLEN);
+ 
+@@ -707,12 +703,7 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 	forw_packet_aggr->packet_len = packet_len;
+ 	memcpy(skb_buff, packet_buff, packet_len);
+ 
+-	kref_get(&if_incoming->refcount);
+-	kref_get(&if_outgoing->refcount);
+ 	forw_packet_aggr->own = own_packet;
+-	forw_packet_aggr->if_incoming = if_incoming;
+-	forw_packet_aggr->if_outgoing = if_outgoing;
+-	forw_packet_aggr->num_packets = 0;
+ 	forw_packet_aggr->direct_link_flags = BATADV_NO_FLAGS;
+ 	forw_packet_aggr->send_time = send_time;
+ 
+@@ -731,13 +722,6 @@ static void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,
+ 	queue_delayed_work(batadv_event_workqueue,
+ 			   &forw_packet_aggr->delayed_work,
+ 			   send_time - jiffies);
+-
+-	return;
+-out_free_forw_packet:
+-	kfree(forw_packet_aggr);
+-out_nomem:
+-	if (!own_packet)
+-		atomic_inc(&bat_priv->batman_queue_left);
+ }
+ 
+ /* aggregate a new packet into the existing ogm packet */
+@@ -1820,10 +1804,6 @@ static void batadv_iv_send_outstanding_bat_ogm_packet(struct work_struct *work)
+ 		batadv_iv_ogm_schedule(forw_packet->if_incoming);
+ 
+ out:
+-	/* don't count own packet */
+-	if (!forw_packet->own)
+-		atomic_inc(&bat_priv->batman_queue_left);
+-
+ 	batadv_forw_packet_free(forw_packet);
+ }
+ 
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 6191159..33d8bd1 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -439,6 +439,13 @@ int batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ 				       BATADV_P_DATA, orig_node, vid);
+ }
+ 
++/**
++ * batadv_forw_packet_free - free a forwarding packet
++ * @forw_packet: The packet to free
++ *
++ * This frees a forwarding packet and releases any resources it might
++ * have claimed.
++ */
+ void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet)
+ {
+ 	kfree_skb(forw_packet->skb);
+@@ -446,9 +453,73 @@ void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet)
+ 		batadv_hardif_put(forw_packet->if_incoming);
+ 	if (forw_packet->if_outgoing)
+ 		batadv_hardif_put(forw_packet->if_outgoing);
++	if (forw_packet->queue_left)
++		atomic_inc(forw_packet->queue_left);
+ 	kfree(forw_packet);
+ }
+ 
++/**
++ * batadv_forw_packet_alloc - allocate a forwarding packet
++ * @if_incoming: The (optional) if_incoming to be grabbed
++ * @if_outgoing: The (optional) if_outgoing to be grabbed
++ * @queue_left: The (optional) queue counter to decrease
++ * @bat_priv: The bat_priv for the mesh of this forw_packet
++ *
++ * Allocates a forwarding packet and tries to get a reference to the
++ * (optional) if_incoming, if_outgoing and queue_left. If queue_left
++ * is NULL then bat_priv is optional, too.
++ *
++ * Return: An allocated forwarding packet on success, NULL otherwise.
++ */
++struct batadv_forw_packet *
++batadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,
++			 struct batadv_hard_iface *if_outgoing,
++			 atomic_t *queue_left,
++			 struct batadv_priv *bat_priv)
++{
++	struct batadv_forw_packet *forw_packet;
++	const char *qname;
++
++	if (queue_left && !batadv_atomic_dec_not_zero(queue_left)) {
++		qname = "unknown";
++
++		if (queue_left == &bat_priv->bcast_queue_left)
++			qname = "bcast";
++
++		if (queue_left == &bat_priv->batman_queue_left)
++			qname = "batman";
++
++		batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
++			   "%s queue is full\n", qname);
++
++		return NULL;
++	}
++
++	forw_packet = kmalloc(sizeof(*forw_packet), GFP_ATOMIC);
++	if (!forw_packet)
++		goto err;
++
++	if (if_incoming)
++		kref_get(&if_incoming->refcount);
++
++	if (if_outgoing)
++		kref_get(&if_outgoing->refcount);
++
++	forw_packet->skb = NULL;
++	forw_packet->queue_left = queue_left;
++	forw_packet->if_incoming = if_incoming;
++	forw_packet->if_outgoing = if_outgoing;
++	forw_packet->num_packets = 0;
++
++	return forw_packet;
++
++err:
++	if (queue_left)
++		atomic_inc(queue_left);
++
++	return NULL;
++}
++
+ static void
+ _batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 				 struct batadv_forw_packet *forw_packet,
+@@ -487,24 +558,20 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	struct batadv_bcast_packet *bcast_packet;
+ 	struct sk_buff *newskb;
+ 
+-	if (!batadv_atomic_dec_not_zero(&bat_priv->bcast_queue_left)) {
+-		batadv_dbg(BATADV_DBG_BATMAN, bat_priv,
+-			   "bcast packet queue full\n");
+-		goto out;
+-	}
+-
+ 	primary_if = batadv_primary_if_get_selected(bat_priv);
+ 	if (!primary_if)
+-		goto out_and_inc;
+-
+-	forw_packet = kmalloc(sizeof(*forw_packet), GFP_ATOMIC);
++		goto err;
+ 
++	forw_packet = batadv_forw_packet_alloc(primary_if, NULL,
++					       &bat_priv->bcast_queue_left,
++					       bat_priv);
++	batadv_hardif_put(primary_if);
+ 	if (!forw_packet)
+-		goto out_and_inc;
++		goto err;
+ 
+ 	newskb = skb_copy(skb, GFP_ATOMIC);
+ 	if (!newskb)
+-		goto packet_free;
++		goto err_packet_free;
+ 
+ 	/* as we have a copy now, it is safe to decrease the TTL */
+ 	bcast_packet = (struct batadv_bcast_packet *)newskb->data;
+@@ -513,11 +580,6 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	skb_reset_mac_header(newskb);
+ 
+ 	forw_packet->skb = newskb;
+-	forw_packet->if_incoming = primary_if;
+-	forw_packet->if_outgoing = NULL;
+-
+-	/* how often did we send the bcast packet ? */
+-	forw_packet->num_packets = 0;
+ 
+ 	INIT_DELAYED_WORK(&forw_packet->delayed_work,
+ 			  batadv_send_outstanding_bcast_packet);
+@@ -525,13 +587,9 @@ int batadv_add_bcast_packet_to_list(struct batadv_priv *bat_priv,
+ 	_batadv_add_bcast_packet_to_list(bat_priv, forw_packet, delay);
+ 	return NETDEV_TX_OK;
+ 
+-packet_free:
+-	kfree(forw_packet);
+-out_and_inc:
+-	atomic_inc(&bat_priv->bcast_queue_left);
+-out:
+-	if (primary_if)
+-		batadv_hardif_put(primary_if);
++err_packet_free:
++	batadv_forw_packet_free(forw_packet);
++err:
+ 	return NETDEV_TX_BUSY;
+ }
+ 
+@@ -592,7 +650,6 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 
+ out:
+ 	batadv_forw_packet_free(forw_packet);
+-	atomic_inc(&bat_priv->bcast_queue_left);
+ }
+ 
+ void
+@@ -633,9 +690,6 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 
+ 		if (pending) {
+ 			hlist_del(&forw_packet->list);
+-			if (!forw_packet->own)
+-				atomic_inc(&bat_priv->bcast_queue_left);
+-
+ 			batadv_forw_packet_free(forw_packet);
+ 		}
+ 	}
+@@ -663,9 +717,6 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
+ 
+ 		if (pending) {
+ 			hlist_del(&forw_packet->list);
+-			if (!forw_packet->own)
+-				atomic_inc(&bat_priv->batman_queue_left);
+-
+ 			batadv_forw_packet_free(forw_packet);
+ 		}
+ 	}
+diff --git a/net/batman-adv/send.h b/net/batman-adv/send.h
+index 7cecb75..999f786 100644
+--- a/net/batman-adv/send.h
++++ b/net/batman-adv/send.h
+@@ -28,6 +28,12 @@
+ struct sk_buff;
+ 
+ void batadv_forw_packet_free(struct batadv_forw_packet *forw_packet);
++struct batadv_forw_packet *
++batadv_forw_packet_alloc(struct batadv_hard_iface *if_incoming,
++			 struct batadv_hard_iface *if_outgoing,
++			 atomic_t *queue_left,
++			 struct batadv_priv *bat_priv);
++
+ int batadv_send_skb_to_orig(struct sk_buff *skb,
+ 			    struct batadv_orig_node *orig_node,
+ 			    struct batadv_hard_iface *recv_if);
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 54710c7..72806a3 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1375,6 +1375,7 @@ struct batadv_skb_cb {
+  *  locally generated packet
+  * @if_outgoing: packet where the packet should be sent to, or NULL if
+  *  unspecified
++ * @queue_left: The queue (counter) this packet was applied to
+  */
+ struct batadv_forw_packet {
+ 	struct hlist_node list;
+@@ -1387,6 +1388,7 @@ struct batadv_forw_packet {
+ 	struct delayed_work delayed_work;
+ 	struct batadv_hard_iface *if_incoming;
+ 	struct batadv_hard_iface *if_outgoing;
++	atomic_t *queue_left;
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0017-batman-adv-use-kmem_cache-for-translation-table.patch b/batman-adv/patches/0017-batman-adv-use-kmem_cache-for-translation-table.patch
new file mode 100644
index 0000000..51b8ff3
--- /dev/null
+++ b/batman-adv/patches/0017-batman-adv-use-kmem_cache-for-translation-table.patch
@@ -0,0 +1,416 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sat, 25 Jun 2016 16:44:06 +0200
+Subject: [PATCH] batman-adv: use kmem_cache for translation table
+
+The translation table (global, local) is usually the part of batman-adv
+which has the most dynamical allocated objects. Most of them
+(tt_local_entry, tt_global_entry, tt_orig_list_entry, tt_change_node,
+tt_req_node, tt_roam_node) are equally sized. So it makes sense to have
+them allocated from a kmem_cache for each type.
+
+This approach allowed a small wireless router (TP-Link TL-841NDv8; SLUB
+allocator) to store 34% more translation table entries compared to the
+current implementation.
+
+[1] https://open-mesh.org/projects/batman-adv/wiki/Kmalloc-kmem-cache-tests
+
+Reported-by: Linus Lssing <linus.luessing@c0d3.blue>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/main.c              |  16 +++-
+ net/batman-adv/translation-table.c | 169 +++++++++++++++++++++++++++++++++----
+ net/batman-adv/translation-table.h |   3 +
+ 3 files changed, 169 insertions(+), 19 deletions(-)
+
+diff --git a/net/batman-adv/main.c b/net/batman-adv/main.c
+index f61479b..ef07e5b 100644
+--- a/net/batman-adv/main.c
++++ b/net/batman-adv/main.c
+@@ -82,6 +82,12 @@ static void batadv_recv_handler_init(void);
+ 
+ static int __init batadv_init(void)
+ {
++	int ret;
++
++	ret = batadv_tt_cache_init();
++	if (ret < 0)
++		return ret;
++
+ 	INIT_LIST_HEAD(&batadv_hardif_list);
+ 	batadv_algo_init();
+ 
+@@ -93,9 +99,8 @@ static int __init batadv_init(void)
+ 	batadv_tp_meter_init();
+ 
+ 	batadv_event_workqueue = create_singlethread_workqueue("bat_events");
+-
+ 	if (!batadv_event_workqueue)
+-		return -ENOMEM;
++		goto err_create_wq;
+ 
+ 	batadv_socket_init();
+ 	batadv_debugfs_init();
+@@ -108,6 +113,11 @@ static int __init batadv_init(void)
+ 		BATADV_SOURCE_VERSION, BATADV_COMPAT_VERSION);
+ 
+ 	return 0;
++
++err_create_wq:
++	batadv_tt_cache_destroy();
++
++	return -ENOMEM;
+ }
+ 
+ static void __exit batadv_exit(void)
+@@ -123,6 +133,8 @@ static void __exit batadv_exit(void)
+ 	batadv_event_workqueue = NULL;
+ 
+ 	rcu_barrier();
++
++	batadv_tt_cache_destroy();
+ }
+ 
+ int batadv_mesh_init(struct net_device *soft_iface)
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 7e6df7a..af2bfef 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -22,12 +22,14 @@
+ #include <linux/bitops.h>
+ #include <linux/bug.h>
+ #include <linux/byteorder/generic.h>
++#include <linux/cache.h>
+ #include <linux/compiler.h>
+ #include <linux/crc32c.h>
+ #include <linux/errno.h>
+ #include <linux/etherdevice.h>
+ #include <linux/fs.h>
+ #include <linux/if_ether.h>
++#include <linux/init.h>
+ #include <linux/jhash.h>
+ #include <linux/jiffies.h>
+ #include <linux/kernel.h>
+@@ -54,6 +56,13 @@
+ #include "soft-interface.h"
+ #include "tvlv.h"
+ 
++static struct kmem_cache *batadv_tl_cache __read_mostly;
++static struct kmem_cache *batadv_tg_cache __read_mostly;
++static struct kmem_cache *batadv_tt_orig_cache __read_mostly;
++static struct kmem_cache *batadv_tt_change_cache __read_mostly;
++static struct kmem_cache *batadv_tt_req_cache __read_mostly;
++static struct kmem_cache *batadv_tt_roam_cache __read_mostly;
++
+ /* hash class keys */
+ static struct lock_class_key batadv_tt_local_hash_lock_class_key;
+ static struct lock_class_key batadv_tt_global_hash_lock_class_key;
+@@ -205,6 +214,20 @@ batadv_tt_global_hash_find(struct batadv_priv *bat_priv, const u8 *addr,
+ }
+ 
+ /**
++ * batadv_tt_local_entry_free_rcu - free the tt_local_entry
++ * @rcu: rcu pointer of the tt_local_entry
++ */
++static void batadv_tt_local_entry_free_rcu(struct rcu_head *rcu)
++{
++	struct batadv_tt_local_entry *tt_local_entry;
++
++	tt_local_entry = container_of(rcu, struct batadv_tt_local_entry,
++				      common.rcu);
++
++	kmem_cache_free(batadv_tl_cache, tt_local_entry);
++}
++
++/**
+  * batadv_tt_local_entry_release - release tt_local_entry from lists and queue
+  *  for free after rcu grace period
+  * @ref: kref pointer of the nc_node
+@@ -218,7 +241,7 @@ static void batadv_tt_local_entry_release(struct kref *ref)
+ 
+ 	batadv_softif_vlan_put(tt_local_entry->vlan);
+ 
+-	kfree_rcu(tt_local_entry, common.rcu);
++	call_rcu(&tt_local_entry->common.rcu, batadv_tt_local_entry_free_rcu);
+ }
+ 
+ /**
+@@ -234,6 +257,20 @@ batadv_tt_local_entry_put(struct batadv_tt_local_entry *tt_local_entry)
+ }
+ 
+ /**
++ * batadv_tt_global_entry_free_rcu - free the tt_global_entry
++ * @rcu: rcu pointer of the tt_global_entry
++ */
++static void batadv_tt_global_entry_free_rcu(struct rcu_head *rcu)
++{
++	struct batadv_tt_global_entry *tt_global_entry;
++
++	tt_global_entry = container_of(rcu, struct batadv_tt_global_entry,
++				       common.rcu);
++
++	kmem_cache_free(batadv_tg_cache, tt_global_entry);
++}
++
++/**
+  * batadv_tt_global_entry_release - release tt_global_entry from lists and queue
+  *  for free after rcu grace period
+  * @ref: kref pointer of the nc_node
+@@ -246,7 +283,8 @@ static void batadv_tt_global_entry_release(struct kref *ref)
+ 				       common.refcount);
+ 
+ 	batadv_tt_global_del_orig_list(tt_global_entry);
+-	kfree_rcu(tt_global_entry, common.rcu);
++
++	call_rcu(&tt_global_entry->common.rcu, batadv_tt_global_entry_free_rcu);
+ }
+ 
+ /**
+@@ -384,6 +422,19 @@ static void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,
+ }
+ 
+ /**
++ * batadv_tt_orig_list_entry_free_rcu - free the orig_entry
++ * @rcu: rcu pointer of the orig_entry
++ */
++static void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)
++{
++	struct batadv_tt_orig_list_entry *orig_entry;
++
++	orig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);
++
++	kmem_cache_free(batadv_tt_orig_cache, orig_entry);
++}
++
++/**
+  * batadv_tt_orig_list_entry_release - release tt orig entry from lists and
+  *  queue for free after rcu grace period
+  * @ref: kref pointer of the tt orig entry
+@@ -396,7 +447,7 @@ static void batadv_tt_orig_list_entry_release(struct kref *ref)
+ 				  refcount);
+ 
+ 	batadv_orig_node_put(orig_entry->orig_node);
+-	kfree_rcu(orig_entry, rcu);
++	call_rcu(&orig_entry->rcu, batadv_tt_orig_list_entry_free_rcu);
+ }
+ 
+ /**
+@@ -426,7 +477,7 @@ static void batadv_tt_local_event(struct batadv_priv *bat_priv,
+ 	bool event_removed = false;
+ 	bool del_op_requested, del_op_entry;
+ 
+-	tt_change_node = kmalloc(sizeof(*tt_change_node), GFP_ATOMIC);
++	tt_change_node = kmem_cache_alloc(batadv_tt_change_cache, GFP_ATOMIC);
+ 	if (!tt_change_node)
+ 		return;
+ 
+@@ -467,8 +518,8 @@ static void batadv_tt_local_event(struct batadv_priv *bat_priv,
+ 		continue;
+ del:
+ 		list_del(&entry->list);
+-		kfree(entry);
+-		kfree(tt_change_node);
++		kmem_cache_free(batadv_tt_change_cache, entry);
++		kmem_cache_free(batadv_tt_change_cache, tt_change_node);
+ 		event_removed = true;
+ 		goto unlock;
+ 	}
+@@ -646,7 +697,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 		goto out;
+ 	}
+ 
+-	tt_local = kmalloc(sizeof(*tt_local), GFP_ATOMIC);
++	tt_local = kmem_cache_alloc(batadv_tl_cache, GFP_ATOMIC);
+ 	if (!tt_local)
+ 		goto out;
+ 
+@@ -656,7 +707,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 		net_ratelimited_function(batadv_info, soft_iface,
+ 					 "adding TT local entry %pM to non-existent VLAN %d\n",
+ 					 addr, BATADV_PRINT_VID(vid));
+-		kfree(tt_local);
++		kmem_cache_free(batadv_tl_cache, tt_local);
+ 		tt_local = NULL;
+ 		goto out;
+ 	}
+@@ -959,7 +1010,7 @@ static void batadv_tt_tvlv_container_update(struct batadv_priv *bat_priv)
+ 			tt_diff_entries_count++;
+ 		}
+ 		list_del(&entry->list);
+-		kfree(entry);
++		kmem_cache_free(batadv_tt_change_cache, entry);
+ 	}
+ 	spin_unlock_bh(&bat_priv->tt.changes_list_lock);
+ 
+@@ -1259,7 +1310,7 @@ static void batadv_tt_changes_list_free(struct batadv_priv *bat_priv)
+ 	list_for_each_entry_safe(entry, safe, &bat_priv->tt.changes_list,
+ 				 list) {
+ 		list_del(&entry->list);
+-		kfree(entry);
++		kmem_cache_free(batadv_tt_change_cache, entry);
+ 	}
+ 
+ 	atomic_set(&bat_priv->tt.local_changes, 0);
+@@ -1341,7 +1392,7 @@ batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,
+ 		goto out;
+ 	}
+ 
+-	orig_entry = kzalloc(sizeof(*orig_entry), GFP_ATOMIC);
++	orig_entry = kmem_cache_zalloc(batadv_tt_orig_cache, GFP_ATOMIC);
+ 	if (!orig_entry)
+ 		goto out;
+ 
+@@ -1411,7 +1462,8 @@ static bool batadv_tt_global_add(struct batadv_priv *bat_priv,
+ 		goto out;
+ 
+ 	if (!tt_global_entry) {
+-		tt_global_entry = kzalloc(sizeof(*tt_global_entry), GFP_ATOMIC);
++		tt_global_entry = kmem_cache_zalloc(batadv_tg_cache,
++						    GFP_ATOMIC);
+ 		if (!tt_global_entry)
+ 			goto out;
+ 
+@@ -2280,7 +2332,7 @@ static void batadv_tt_req_node_release(struct kref *ref)
+ 
+ 	tt_req_node = container_of(ref, struct batadv_tt_req_node, refcount);
+ 
+-	kfree(tt_req_node);
++	kmem_cache_free(batadv_tt_req_cache, tt_req_node);
+ }
+ 
+ /**
+@@ -2367,7 +2419,7 @@ batadv_tt_req_node_new(struct batadv_priv *bat_priv,
+ 			goto unlock;
+ 	}
+ 
+-	tt_req_node = kmalloc(sizeof(*tt_req_node), GFP_ATOMIC);
++	tt_req_node = kmem_cache_alloc(batadv_tt_req_cache, GFP_ATOMIC);
+ 	if (!tt_req_node)
+ 		goto unlock;
+ 
+@@ -3104,7 +3156,7 @@ static void batadv_tt_roam_list_free(struct batadv_priv *bat_priv)
+ 
+ 	list_for_each_entry_safe(node, safe, &bat_priv->tt.roam_list, list) {
+ 		list_del(&node->list);
+-		kfree(node);
++		kmem_cache_free(batadv_tt_roam_cache, node);
+ 	}
+ 
+ 	spin_unlock_bh(&bat_priv->tt.roam_list_lock);
+@@ -3121,7 +3173,7 @@ static void batadv_tt_roam_purge(struct batadv_priv *bat_priv)
+ 			continue;
+ 
+ 		list_del(&node->list);
+-		kfree(node);
++		kmem_cache_free(batadv_tt_roam_cache, node);
+ 	}
+ 	spin_unlock_bh(&bat_priv->tt.roam_list_lock);
+ }
+@@ -3162,7 +3214,8 @@ static bool batadv_tt_check_roam_count(struct batadv_priv *bat_priv, u8 *client)
+ 	}
+ 
+ 	if (!ret) {
+-		tt_roam_node = kmalloc(sizeof(*tt_roam_node), GFP_ATOMIC);
++		tt_roam_node = kmem_cache_alloc(batadv_tt_roam_cache,
++						GFP_ATOMIC);
+ 		if (!tt_roam_node)
+ 			goto unlock;
+ 
+@@ -3865,3 +3918,85 @@ bool batadv_tt_global_is_isolated(struct batadv_priv *bat_priv,
+ 
+ 	return ret;
+ }
++
++/**
++ * batadv_tt_cache_init - Initialize tt memory object cache
++ *
++ * Return: 0 on success or negative error number in case of failure.
++ */
++int __init batadv_tt_cache_init(void)
++{
++	size_t tl_size = sizeof(struct batadv_tt_local_entry);
++	size_t tg_size = sizeof(struct batadv_tt_global_entry);
++	size_t tt_orig_size = sizeof(struct batadv_tt_orig_list_entry);
++	size_t tt_change_size = sizeof(struct batadv_tt_change_node);
++	size_t tt_req_size = sizeof(struct batadv_tt_req_node);
++	size_t tt_roam_size = sizeof(struct batadv_tt_roam_node);
++
++	batadv_tl_cache = kmem_cache_create("batadv_tl_cache", tl_size, 0,
++					    SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tl_cache)
++		return -ENOMEM;
++
++	batadv_tg_cache = kmem_cache_create("batadv_tg_cache", tg_size, 0,
++					    SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tg_cache)
++		goto err_tt_tl_destroy;
++
++	batadv_tt_orig_cache = kmem_cache_create("batadv_tt_orig_cache",
++						 tt_orig_size, 0,
++						 SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tt_orig_cache)
++		goto err_tt_tg_destroy;
++
++	batadv_tt_change_cache = kmem_cache_create("batadv_tt_change_cache",
++						   tt_change_size, 0,
++						   SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tt_change_cache)
++		goto err_tt_orig_destroy;
++
++	batadv_tt_req_cache = kmem_cache_create("batadv_tt_req_cache",
++						tt_req_size, 0,
++						SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tt_req_cache)
++		goto err_tt_change_destroy;
++
++	batadv_tt_roam_cache = kmem_cache_create("batadv_tt_roam_cache",
++						 tt_roam_size, 0,
++						 SLAB_HWCACHE_ALIGN, NULL);
++	if (!batadv_tt_roam_cache)
++		goto err_tt_req_destroy;
++
++	return 0;
++
++err_tt_req_destroy:
++	kmem_cache_destroy(batadv_tt_req_cache);
++	batadv_tt_req_cache = NULL;
++err_tt_change_destroy:
++	kmem_cache_destroy(batadv_tt_change_cache);
++	batadv_tt_change_cache = NULL;
++err_tt_orig_destroy:
++	kmem_cache_destroy(batadv_tt_orig_cache);
++	batadv_tt_orig_cache = NULL;
++err_tt_tg_destroy:
++	kmem_cache_destroy(batadv_tg_cache);
++	batadv_tg_cache = NULL;
++err_tt_tl_destroy:
++	kmem_cache_destroy(batadv_tl_cache);
++	batadv_tl_cache = NULL;
++
++	return -ENOMEM;
++}
++
++/**
++ * batadv_tt_cache_destroy - Destroy tt memory object cache
++ */
++void batadv_tt_cache_destroy(void)
++{
++	kmem_cache_destroy(batadv_tl_cache);
++	kmem_cache_destroy(batadv_tg_cache);
++	kmem_cache_destroy(batadv_tt_orig_cache);
++	kmem_cache_destroy(batadv_tt_change_cache);
++	kmem_cache_destroy(batadv_tt_req_cache);
++	kmem_cache_destroy(batadv_tt_roam_cache);
++}
+diff --git a/net/batman-adv/translation-table.h b/net/batman-adv/translation-table.h
+index 7c7e2c0..02b0f85 100644
+--- a/net/batman-adv/translation-table.h
++++ b/net/batman-adv/translation-table.h
+@@ -59,4 +59,7 @@ bool batadv_tt_add_temporary_global_entry(struct batadv_priv *bat_priv,
+ bool batadv_tt_global_is_isolated(struct batadv_priv *bat_priv,
+ 				  const u8 *addr, unsigned short vid);
+ 
++int batadv_tt_cache_init(void);
++void batadv_tt_cache_destroy(void);
++
+ #endif /* _NET_BATMAN_ADV_TRANSLATION_TABLE_H_ */
diff --git a/batman-adv/patches/0018-batman-adv-Remove-orig_node-reference-handling-from-.patch b/batman-adv/patches/0018-batman-adv-Remove-orig_node-reference-handling-from-.patch
new file mode 100644
index 0000000..b12f540
--- /dev/null
+++ b/batman-adv/patches/0018-batman-adv-Remove-orig_node-reference-handling-from-.patch
@@ -0,0 +1,106 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Mon, 27 Jun 2016 08:15:42 +0200
+Subject: [PATCH] batman-adv: Remove orig_node reference handling from send_skb_unicast
+
+The function batadv_send_skb_unicast is not acquiring a reference for an
+orig_node nor removing it from any datastructure. It still reduces the
+reference counter for an object which is still in the hands of the caller.
+
+This is confusing and can lead in the future to problems in the reference
+handling of the caller function.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Acked-by: Linus Lssing <linus.luessing@c0d3.blue>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/send.c           | 25 +++++++++++++++++--------
+ net/batman-adv/soft-interface.c |  3 +++
+ 2 files changed, 20 insertions(+), 8 deletions(-)
+
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 33d8bd1..8d4e1f5 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -315,8 +315,7 @@ out:
+  *
+  * Wrap the given skb into a batman-adv unicast or unicast-4addr header
+  * depending on whether BATADV_UNICAST or BATADV_UNICAST_4ADDR was supplied
+- * as packet_type. Then send this frame to the given orig_node and release a
+- * reference to this orig_node.
++ * as packet_type. Then send this frame to the given orig_node.
+  *
+  * Return: NET_XMIT_DROP in case of error or NET_XMIT_SUCCESS otherwise.
+  */
+@@ -370,8 +369,6 @@ int batadv_send_skb_unicast(struct batadv_priv *bat_priv,
+ 		ret = NET_XMIT_SUCCESS;
+ 
+ out:
+-	if (orig_node)
+-		batadv_orig_node_put(orig_node);
+ 	if (ret == NET_XMIT_DROP)
+ 		kfree_skb(skb);
+ 	return ret;
+@@ -403,6 +400,7 @@ int batadv_send_skb_via_tt_generic(struct batadv_priv *bat_priv,
+ 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+ 	struct batadv_orig_node *orig_node;
+ 	u8 *src, *dst;
++	int ret;
+ 
+ 	src = ethhdr->h_source;
+ 	dst = ethhdr->h_dest;
+@@ -414,8 +412,13 @@ int batadv_send_skb_via_tt_generic(struct batadv_priv *bat_priv,
+ 	}
+ 	orig_node = batadv_transtable_search(bat_priv, src, dst, vid);
+ 
+-	return batadv_send_skb_unicast(bat_priv, skb, packet_type,
+-				       packet_subtype, orig_node, vid);
++	ret = batadv_send_skb_unicast(bat_priv, skb, packet_type,
++				      packet_subtype, orig_node, vid);
++
++	if (orig_node)
++		batadv_orig_node_put(orig_node);
++
++	return ret;
+ }
+ 
+ /**
+@@ -433,10 +436,16 @@ int batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,
+ 			   unsigned short vid)
+ {
+ 	struct batadv_orig_node *orig_node;
++	int ret;
+ 
+ 	orig_node = batadv_gw_get_selected_orig(bat_priv);
+-	return batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST_4ADDR,
+-				       BATADV_P_DATA, orig_node, vid);
++	ret = batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST_4ADDR,
++				      BATADV_P_DATA, orig_node, vid);
++
++	if (orig_node)
++		batadv_orig_node_put(orig_node);
++
++	return ret;
+ }
+ 
+ /**
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index 216ac03..e508bf5 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -57,6 +57,7 @@
+ #include "hard-interface.h"
+ #include "multicast.h"
+ #include "network-coding.h"
++#include "originator.h"
+ #include "packet.h"
+ #include "send.h"
+ #include "sysfs.h"
+@@ -377,6 +378,8 @@ dropped:
+ dropped_freed:
+ 	batadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);
+ end:
++	if (mcast_single_orig)
++		batadv_orig_node_put(mcast_single_orig);
+ 	if (primary_if)
+ 		batadv_hardif_put(primary_if);
+ 	return NETDEV_TX_OK;
diff --git a/batman-adv/patches/0019-batman-adv-Use-bitwise-instead-of-arithmetic-operato.patch b/batman-adv/patches/0019-batman-adv-Use-bitwise-instead-of-arithmetic-operato.patch
new file mode 100644
index 0000000..71d64f2
--- /dev/null
+++ b/batman-adv/patches/0019-batman-adv-Use-bitwise-instead-of-arithmetic-operato.patch
@@ -0,0 +1,28 @@
+From: Linus Lssing <linus.luessing@c0d3.blue>
+Date: Mon, 11 Jul 2016 11:16:36 +0200
+Subject: [PATCH] batman-adv: Use bitwise instead of arithmetic operator for flags
+
+This silences the following coccinelle warning:
+
+"WARNING: sum of probable bitmasks, consider |"
+
+Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
+Reviewed-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/multicast.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/multicast.c b/net/batman-adv/multicast.c
+index cc91507..894df60 100644
+--- a/net/batman-adv/multicast.c
++++ b/net/batman-adv/multicast.c
+@@ -528,7 +528,7 @@ update:
+ 	}
+ 
+ 	return !(mcast_data.flags &
+-		 (BATADV_MCAST_WANT_ALL_IPV4 + BATADV_MCAST_WANT_ALL_IPV6));
++		 (BATADV_MCAST_WANT_ALL_IPV4 | BATADV_MCAST_WANT_ALL_IPV6));
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0020-batman-adv-Fix-consistency-of-update-route-messages.patch b/batman-adv/patches/0020-batman-adv-Fix-consistency-of-update-route-messages.patch
new file mode 100644
index 0000000..9edc626
--- /dev/null
+++ b/batman-adv/patches/0020-batman-adv-Fix-consistency-of-update-route-messages.patch
@@ -0,0 +1,79 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Wed, 29 Jun 2016 23:45:57 +0200
+Subject: [PATCH] batman-adv: Fix consistency of update route messages
+
+The debug messages of _batadv_update_route were printed before the actual
+route change is done. At this point it is not really known which
+curr_router will be replaced. Thus the messages could print the wrong
+operation.
+
+Printing the debug messages after the operation was done avoids this
+problem.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/routing.c | 43 +++++++++++++++++--------------------------
+ 1 file changed, 17 insertions(+), 26 deletions(-)
+
+diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
+index 3d19947..7e8dc64 100644
+--- a/net/batman-adv/routing.c
++++ b/net/batman-adv/routing.c
+@@ -74,11 +74,23 @@ static void _batadv_update_route(struct batadv_priv *bat_priv,
+ 	if (!orig_ifinfo)
+ 		return;
+ 
+-	rcu_read_lock();
+-	curr_router = rcu_dereference(orig_ifinfo->router);
+-	if (curr_router && !kref_get_unless_zero(&curr_router->refcount))
+-		curr_router = NULL;
+-	rcu_read_unlock();
++	spin_lock_bh(&orig_node->neigh_list_lock);
++	/* curr_router used earlier may not be the current orig_ifinfo->router
++	 * anymore because it was dereferenced outside of the neigh_list_lock
++	 * protected region. After the new best neighbor has replace the current
++	 * best neighbor the reference counter needs to decrease. Consequently,
++	 * the code needs to ensure the curr_router variable contains a pointer
++	 * to the replaced best neighbor.
++	 */
++	curr_router = rcu_dereference_protected(orig_ifinfo->router, true);
++
++	/* increase refcount of new best neighbor */
++	if (neigh_node)
++		kref_get(&neigh_node->refcount);
++
++	rcu_assign_pointer(orig_ifinfo->router, neigh_node);
++	spin_unlock_bh(&orig_node->neigh_list_lock);
++	batadv_orig_ifinfo_put(orig_ifinfo);
+ 
+ 	/* route deleted */
+ 	if ((curr_router) && (!neigh_node)) {
+@@ -100,27 +112,6 @@ static void _batadv_update_route(struct batadv_priv *bat_priv,
+ 			   curr_router->addr);
+ 	}
+ 
+-	if (curr_router)
+-		batadv_neigh_node_put(curr_router);
+-
+-	spin_lock_bh(&orig_node->neigh_list_lock);
+-	/* curr_router used earlier may not be the current orig_ifinfo->router
+-	 * anymore because it was dereferenced outside of the neigh_list_lock
+-	 * protected region. After the new best neighbor has replace the current
+-	 * best neighbor the reference counter needs to decrease. Consequently,
+-	 * the code needs to ensure the curr_router variable contains a pointer
+-	 * to the replaced best neighbor.
+-	 */
+-	curr_router = rcu_dereference_protected(orig_ifinfo->router, true);
+-
+-	/* increase refcount of new best neighbor */
+-	if (neigh_node)
+-		kref_get(&neigh_node->refcount);
+-
+-	rcu_assign_pointer(orig_ifinfo->router, neigh_node);
+-	spin_unlock_bh(&orig_node->neigh_list_lock);
+-	batadv_orig_ifinfo_put(orig_ifinfo);
+-
+ 	/* decrease refcount of previous best neighbor */
+ 	if (curr_router)
+ 		batadv_neigh_node_put(curr_router);
diff --git a/batman-adv/patches/0021-batman-adv-Handle-parent-interfaces-in-a-different-n.patch b/batman-adv/patches/0021-batman-adv-Handle-parent-interfaces-in-a-different-n.patch
new file mode 100644
index 0000000..6247253
--- /dev/null
+++ b/batman-adv/patches/0021-batman-adv-Handle-parent-interfaces-in-a-different-n.patch
@@ -0,0 +1,142 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:33 +0200
+Subject: [PATCH] batman-adv: Handle parent interfaces in a different netns
+
+batman-adv tries to prevent the user from placing a batX soft
+interface into another batman mesh as a hard interface. It does this
+by walking up the devices list of parents and ensures they are all
+none batX interfaces. iflink can point to an interface in a different
+namespace, so also retrieve the parents name space when finding the
+parent and use it when doing the comparison.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Fix alignments, simplify parent netns retrieval]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ compat.h                        |  7 ++++++
+ net/batman-adv/hard-interface.c | 50 +++++++++++++++++++++++++++++++++++------
+ 2 files changed, 50 insertions(+), 7 deletions(-)
+
+diff --git a/compat.h b/compat.h
+index 7d5c8b6..fc78948 100644
+--- a/compat.h
++++ b/compat.h
+@@ -146,6 +146,13 @@ static int __batadv_interface_kill_vid(struct net_device *dev, __be16 proto,\
+ 
+ #endif /* < KERNEL_VERSION(3, 15, 0) */
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
++
++/* WARNING for batadv_getlink_net */
++#define get_link_net get_xstats_size || 1 || netdev->rtnl_link_ops->get_xstats_size
++
++#endif /* < KERNEL_VERSION(4, 0, 0) */
++
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
+ 
+ #define IFF_NO_QUEUE	0; dev->tx_queue_len = 0
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 714af8e..43c9a3e 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -35,6 +35,8 @@
+ #include <linux/rtnetlink.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
++#include <net/net_namespace.h>
++#include <net/rtnetlink.h>
+ 
+ #include "bat_v.h"
+ #include "bridge_loop_avoidance.h"
+@@ -84,25 +86,55 @@ out:
+ }
+ 
+ /**
++ * batadv_getlink_net - return link net namespace (of use fallback)
++ * @netdev: net_device to check
++ * @fallback_net: return in case get_link_net is not available for @netdev
++ *
++ * Return: result of rtnl_link_ops->get_link_net or @fallback_net
++ */
++static const struct net *batadv_getlink_net(const struct net_device *netdev,
++					    const struct net *fallback_net)
++{
++	if (!netdev->rtnl_link_ops)
++		return fallback_net;
++
++	if (!netdev->rtnl_link_ops->get_link_net)
++		return fallback_net;
++
++	return netdev->rtnl_link_ops->get_link_net(netdev);
++}
++
++/**
+  * batadv_mutual_parents - check if two devices are each others parent
+- * @dev1: 1st net_device
+- * @dev2: 2nd net_device
++ * @dev1: 1st net dev
++ * @net1: 1st devices netns
++ * @dev2: 2nd net dev
++ * @net2: 2nd devices netns
+  *
+  * veth devices come in pairs and each is the parent of the other!
+  *
+  * Return: true if the devices are each others parent, otherwise false
+  */
+ static bool batadv_mutual_parents(const struct net_device *dev1,
+-				  const struct net_device *dev2)
++				  const struct net *net1,
++				  const struct net_device *dev2,
++				  const struct net *net2)
+ {
+ 	int dev1_parent_iflink = dev_get_iflink(dev1);
+ 	int dev2_parent_iflink = dev_get_iflink(dev2);
++	const struct net *dev1_parent_net;
++	const struct net *dev2_parent_net;
++
++	dev1_parent_net = batadv_getlink_net(dev1, net1);
++	dev2_parent_net = batadv_getlink_net(dev2, net2);
+ 
+ 	if (!dev1_parent_iflink || !dev2_parent_iflink)
+ 		return false;
+ 
+ 	return (dev1_parent_iflink == dev2->ifindex) &&
+-	       (dev2_parent_iflink == dev1->ifindex);
++	       (dev2_parent_iflink == dev1->ifindex) &&
++	       net_eq(dev1_parent_net, net2) &&
++	       net_eq(dev2_parent_net, net1);
+ }
+ 
+ /**
+@@ -120,8 +152,9 @@ static bool batadv_mutual_parents(const struct net_device *dev1,
+  */
+ static bool batadv_is_on_batman_iface(const struct net_device *net_dev)
+ {
+-	struct net_device *parent_dev;
+ 	struct net *net = dev_net(net_dev);
++	struct net_device *parent_dev;
++	const struct net *parent_net;
+ 	bool ret;
+ 
+ 	/* check if this is a batman-adv mesh interface */
+@@ -133,13 +166,16 @@ static bool batadv_is_on_batman_iface(const struct net_device *net_dev)
+ 	    dev_get_iflink(net_dev) == net_dev->ifindex)
+ 		return false;
+ 
++	parent_net = batadv_getlink_net(net_dev, net);
++
+ 	/* recurse over the parent device */
+-	parent_dev = __dev_get_by_index(net, dev_get_iflink(net_dev));
++	parent_dev = __dev_get_by_index((struct net *)parent_net,
++					dev_get_iflink(net_dev));
+ 	/* if we got a NULL parent_dev there is something broken.. */
+ 	if (WARN(!parent_dev, "Cannot find parent device"))
+ 		return false;
+ 
+-	if (batadv_mutual_parents(net_dev, parent_dev))
++	if (batadv_mutual_parents(net_dev, net, parent_dev, parent_net))
+ 		return false;
+ 
+ 	ret = batadv_is_on_batman_iface(parent_dev);
diff --git a/batman-adv/patches/0022-batman-adv-Suppress-debugfs-entries-for-netns-s.patch b/batman-adv/patches/0022-batman-adv-Suppress-debugfs-entries-for-netns-s.patch
new file mode 100644
index 0000000..cd0faef
--- /dev/null
+++ b/batman-adv/patches/0022-batman-adv-Suppress-debugfs-entries-for-netns-s.patch
@@ -0,0 +1,88 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:34 +0200
+Subject: [PATCH] batman-adv: Suppress debugfs entries for netns's
+
+Debugfs is not netns aware. It thus has problems when the same
+interface name exists in multiple network name spaces.
+
+Work around this by not creating entries for interfaces in name spaces
+other than the default name space. This means meshes in network
+namespaces cannot be managed via debugfs, but there will soon be a
+netlink interface which is netns aware.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/debugfs.c | 18 ++++++++++++++++++
+ 1 file changed, 18 insertions(+)
+
+diff --git a/net/batman-adv/debugfs.c b/net/batman-adv/debugfs.c
+index 1d68b6e..b4ffba7 100644
+--- a/net/batman-adv/debugfs.c
++++ b/net/batman-adv/debugfs.c
+@@ -31,6 +31,7 @@
+ #include <linux/stddef.h>
+ #include <linux/stringify.h>
+ #include <linux/sysfs.h>
++#include <net/net_namespace.h>
+ 
+ #include "bat_algo.h"
+ #include "bridge_loop_avoidance.h"
+@@ -305,12 +306,16 @@ void batadv_debugfs_destroy(void)
+  */
+ int batadv_debugfs_add_hardif(struct batadv_hard_iface *hard_iface)
+ {
++	struct net *net = dev_net(hard_iface->net_dev);
+ 	struct batadv_debuginfo **bat_debug;
+ 	struct dentry *file;
+ 
+ 	if (!batadv_debugfs)
+ 		goto out;
+ 
++	if (net != &init_net)
++		return 0;
++
+ 	hard_iface->debug_dir = debugfs_create_dir(hard_iface->net_dev->name,
+ 						   batadv_debugfs);
+ 	if (!hard_iface->debug_dir)
+@@ -341,6 +346,11 @@ out:
+  */
+ void batadv_debugfs_del_hardif(struct batadv_hard_iface *hard_iface)
+ {
++	struct net *net = dev_net(hard_iface->net_dev);
++
++	if (net != &init_net)
++		return;
++
+ 	if (batadv_debugfs) {
+ 		debugfs_remove_recursive(hard_iface->debug_dir);
+ 		hard_iface->debug_dir = NULL;
+@@ -351,11 +361,15 @@ int batadv_debugfs_add_meshif(struct net_device *dev)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(dev);
+ 	struct batadv_debuginfo **bat_debug;
++	struct net *net = dev_net(dev);
+ 	struct dentry *file;
+ 
+ 	if (!batadv_debugfs)
+ 		goto out;
+ 
++	if (net != &init_net)
++		return 0;
++
+ 	bat_priv->debug_dir = debugfs_create_dir(dev->name, batadv_debugfs);
+ 	if (!bat_priv->debug_dir)
+ 		goto out;
+@@ -392,6 +406,10 @@ out:
+ void batadv_debugfs_del_meshif(struct net_device *dev)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(dev);
++	struct net *net = dev_net(dev);
++
++	if (net != &init_net)
++		return;
+ 
+ 	batadv_debug_log_cleanup(bat_priv);
+ 
diff --git a/batman-adv/patches/0023-batman-adv-netlink-add-routing_algo-query.patch b/batman-adv/patches/0023-batman-adv-netlink-add-routing_algo-query.patch
new file mode 100644
index 0000000..ea42912
--- /dev/null
+++ b/batman-adv/patches/0023-batman-adv-netlink-add-routing_algo-query.patch
@@ -0,0 +1,234 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:35 +0200
+Subject: [PATCH] batman-adv: netlink: add routing_algo query
+
+BATADV_CMD_GET_ROUTING_ALGOS is used to get the list of supported routing
+algorithms.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Reduce the number of changes to
+BATADV_CMD_GET_ROUTING_ALGOS, fix includes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ compat-include/linux/netlink.h  | 18 +++++++++++
+ include/uapi/linux/batman_adv.h |  2 ++
+ net/batman-adv/bat_algo.c       | 68 +++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/bat_algo.h       |  3 ++
+ net/batman-adv/netlink.c        |  9 +++++-
+ net/batman-adv/netlink.h        |  3 ++
+ 6 files changed, 102 insertions(+), 1 deletion(-)
+
+diff --git a/compat-include/linux/netlink.h b/compat-include/linux/netlink.h
+index eb5b7f4..4f2185d 100644
+--- a/compat-include/linux/netlink.h
++++ b/compat-include/linux/netlink.h
+@@ -24,6 +24,24 @@
+ #include <linux/version.h>
+ #include_next <linux/netlink.h>
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)
++
++#include <net/scm.h>
++
++struct batadv_netlink_skb_parms {
++	struct ucred		creds;		/* Skb credentials	*/
++	union {
++		__u32		portid;
++		__u32		pid;
++	};
++	__u32			dst_group;
++};
++
++#undef NETLINK_CB
++#define NETLINK_CB(skb) (*(struct batadv_netlink_skb_parms *)&((skb)->cb))
++
++#endif /* < KERNEL_VERSION(3, 7, 0) */
++
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+ 
+ #include_next <net/netlink.h>
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 0fbf6fd..7afce44 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -73,6 +73,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_MESH_INFO: Query basic information about batman-adv device
+  * @BATADV_CMD_TP_METER: Start a tp meter session
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
++ * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -81,6 +82,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_MESH_INFO,
+ 	BATADV_CMD_TP_METER,
+ 	BATADV_CMD_TP_METER_CANCEL,
++	BATADV_CMD_GET_ROUTING_ALGOS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/bat_algo.c b/net/batman-adv/bat_algo.c
+index 81dbbf5..f2cc50d 100644
+--- a/net/batman-adv/bat_algo.c
++++ b/net/batman-adv/bat_algo.c
+@@ -20,12 +20,18 @@
+ #include <linux/errno.h>
+ #include <linux/list.h>
+ #include <linux/moduleparam.h>
++#include <linux/netlink.h>
+ #include <linux/printk.h>
+ #include <linux/seq_file.h>
++#include <linux/skbuff.h>
+ #include <linux/stddef.h>
+ #include <linux/string.h>
++#include <net/genetlink.h>
++#include <net/netlink.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
++#include "netlink.h"
+ 
+ char batadv_routing_algo[20] = "BATMAN_IV";
+ static struct hlist_head batadv_algo_list;
+@@ -138,3 +144,65 @@ static struct kparam_string batadv_param_string_ra = {
+ 
+ module_param_cb(routing_algo, &batadv_param_ops_ra, &batadv_param_string_ra,
+ 		0644);
++
++/**
++ * batadv_algo_dump_entry - fill in information about one supported routing
++ *  algorithm
++ * @msg: netlink message to be sent back
++ * @portid: Port to reply to
++ * @seq: Sequence number of message
++ * @bat_algo_ops: Algorithm to be dumped
++ *
++ * Return: Error number, or 0 on success
++ */
++static int batadv_algo_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++				  struct batadv_algo_ops *bat_algo_ops)
++{
++	void *hdr;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_ROUTING_ALGOS);
++	if (!hdr)
++		return -EMSGSIZE;
++
++	if (nla_put_string(msg, BATADV_ATTR_ALGO_NAME, bat_algo_ops->name))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_algo_dump - fill in information about supported routing
++ *  algorithms
++ * @msg: netlink message to be sent back
++ * @cb: Parameters to the netlink request
++ *
++ * Return: Length of reply message.
++ */
++int batadv_algo_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	int portid = NETLINK_CB(cb->skb).portid;
++	struct batadv_algo_ops *bat_algo_ops;
++	int skip = cb->args[0];
++	int i = 0;
++
++	hlist_for_each_entry(bat_algo_ops, &batadv_algo_list, list) {
++		if (i++ < skip)
++			continue;
++
++		if (batadv_algo_dump_entry(msg, portid, cb->nlh->nlmsg_seq,
++					   bat_algo_ops)) {
++			i--;
++			break;
++		}
++	}
++
++	cb->args[0] = i;
++
++	return msg->len;
++}
+diff --git a/net/batman-adv/bat_algo.h b/net/batman-adv/bat_algo.h
+index 860d773..3b5b69c 100644
+--- a/net/batman-adv/bat_algo.h
++++ b/net/batman-adv/bat_algo.h
+@@ -22,7 +22,9 @@
+ 
+ #include <linux/types.h>
+ 
++struct netlink_callback;
+ struct seq_file;
++struct sk_buff;
+ 
+ extern char batadv_routing_algo[];
+ extern struct list_head batadv_hardif_list;
+@@ -31,5 +33,6 @@ void batadv_algo_init(void);
+ int batadv_algo_register(struct batadv_algo_ops *bat_algo_ops);
+ int batadv_algo_select(struct batadv_priv *bat_priv, char *name);
+ int batadv_algo_seq_print_text(struct seq_file *seq, void *offset);
++int batadv_algo_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ 
+ #endif /* _NET_BATMAN_ADV_BAT_ALGO_H_ */
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 231f8ea..19fb265 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -32,13 +32,14 @@
+ #include <net/netlink.h>
+ #include <uapi/linux/batman_adv.h>
+ 
++#include "bat_algo.h"
+ #include "hard-interface.h"
+ #include "soft-interface.h"
+ #include "tp_meter.h"
+ 
+ struct sk_buff;
+ 
+-static struct genl_family batadv_netlink_family = {
++struct genl_family batadv_netlink_family = {
+ 	.id = GENL_ID_GENERATE,
+ 	.hdrsize = 0,
+ 	.name = BATADV_NL_NAME,
+@@ -399,6 +400,12 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.doit = batadv_netlink_tp_meter_cancel,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_ROUTING_ALGOS,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_algo_dump,
++	},
+ };
+ 
+ /**
+diff --git a/net/batman-adv/netlink.h b/net/batman-adv/netlink.h
+index 945653a..b399f49 100644
+--- a/net/batman-adv/netlink.h
++++ b/net/batman-adv/netlink.h
+@@ -21,6 +21,7 @@
+ #include "main.h"
+ 
+ #include <linux/types.h>
++#include <net/genetlink.h>
+ 
+ void batadv_netlink_register(void);
+ void batadv_netlink_unregister(void);
+@@ -29,4 +30,6 @@ int batadv_netlink_tpmeter_notify(struct batadv_priv *bat_priv, const u8 *dst,
+ 				  u8 result, u32 test_time, u64 total_bytes,
+ 				  u32 cookie);
+ 
++extern struct genl_family batadv_netlink_family;
++
+ #endif /* _NET_BATMAN_ADV_NETLINK_H_ */
diff --git a/batman-adv/patches/0024-batman-adv-netlink-hardif-query.patch b/batman-adv/patches/0024-batman-adv-netlink-hardif-query.patch
new file mode 100644
index 0000000..7271884
--- /dev/null
+++ b/batman-adv/patches/0024-batman-adv-netlink-hardif-query.patch
@@ -0,0 +1,229 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:36 +0200
+Subject: [PATCH] batman-adv: netlink: hardif query
+
+BATADV_CMD_GET_HARDIFS will return the list of hardifs (including index,
+name and MAC address) of all hardifs for a given softif.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Reduce the number of changes to
+BATADV_CMD_GET_HARDIFS, add policy for attributes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h |   4 ++
+ net/batman-adv/netlink.c        | 128 +++++++++++++++++++++++++++++++++++++++-
+ 2 files changed, 130 insertions(+), 2 deletions(-)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 7afce44..8abcbca 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -40,6 +40,7 @@
+  * @BATADV_ATTR_TPMETER_BYTES: amount of acked bytes during run
+  * @BATADV_ATTR_TPMETER_COOKIE: session cookie to match tp_meter session
+  * @BATADV_ATTR_PAD: attribute used for padding for 64-bit alignment
++ * @BATADV_ATTR_ACTIVE: Flag indicating if the hard interface is active
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -60,6 +61,7 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TPMETER_BYTES,
+ 	BATADV_ATTR_TPMETER_COOKIE,
+ 	BATADV_ATTR_PAD,
++	BATADV_ATTR_ACTIVE,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -74,6 +76,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_TP_METER: Start a tp meter session
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
+  * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
++ * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -83,6 +86,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_TP_METER,
+ 	BATADV_CMD_TP_METER_CANCEL,
+ 	BATADV_CMD_GET_ROUTING_ALGOS,
++	BATADV_CMD_GET_HARDIFS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 19fb265..3f872d6 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -26,10 +26,14 @@
+ #include <linux/netdevice.h>
+ #include <linux/netlink.h>
+ #include <linux/printk.h>
++#include <linux/rculist.h>
++#include <linux/rcupdate.h>
++#include <linux/skbuff.h>
+ #include <linux/stddef.h>
+ #include <linux/types.h>
+ #include <net/genetlink.h>
+ #include <net/netlink.h>
++#include <net/sock.h>
+ #include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
+@@ -37,8 +41,6 @@
+ #include "soft-interface.h"
+ #include "tp_meter.h"
+ 
+-struct sk_buff;
+-
+ struct genl_family batadv_netlink_family = {
+ 	.id = GENL_ID_GENERATE,
+ 	.hdrsize = 0,
+@@ -70,9 +72,25 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_TPMETER_TEST_TIME]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_TPMETER_BYTES]	= { .type = NLA_U64 },
+ 	[BATADV_ATTR_TPMETER_COOKIE]	= { .type = NLA_U32 },
++	[BATADV_ATTR_ACTIVE]		= { .type = NLA_FLAG },
+ };
+ 
+ /**
++ * batadv_netlink_get_ifindex - Extract an interface index from a message
++ * @nlh: Message header
++ * @attrtype: Attribute which holds an interface index
++ *
++ * Return: interface index, or 0.
++ */
++static int
++batadv_netlink_get_ifindex(const struct nlmsghdr *nlh, int attrtype)
++{
++	struct nlattr *attr = nlmsg_find_attr(nlh, GENL_HDRLEN, attrtype);
++
++	return attr ? nla_get_u32(attr) : 0;
++}
++
++/**
+  * batadv_netlink_mesh_info_put - fill in generic information about mesh
+  *  interface
+  * @msg: netlink message to be sent back
+@@ -381,6 +399,106 @@ out:
+ 	return ret;
+ }
+ 
++/**
++ * batadv_netlink_dump_hardif_entry - Dump one hard interface into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @hard_iface: Hard interface to dump
++ *
++ * Return: error code, or 0 on success
++ */
++static int
++batadv_netlink_dump_hardif_entry(struct sk_buff *msg, u32 portid, u32 seq,
++				 struct batadv_hard_iface *hard_iface)
++{
++	struct net_device *net_dev = hard_iface->net_dev;
++	void *hdr;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,
++			  BATADV_CMD_GET_HARDIFS);
++	if (!hdr)
++		return -EMSGSIZE;
++
++	if (nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++			net_dev->ifindex) ||
++	    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,
++			   net_dev->name) ||
++	    nla_put(msg, BATADV_ATTR_HARD_ADDRESS, ETH_ALEN,
++		    net_dev->dev_addr))
++		goto nla_put_failure;
++
++	if (hard_iface->if_status == BATADV_IF_ACTIVE) {
++		if (nla_put_flag(msg, BATADV_ATTR_ACTIVE))
++			goto nla_put_failure;
++	}
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_netlink_dump_hardifs - Dump all hard interface into a messages
++ * @msg: Netlink message to dump into
++ * @cb: Parameters from query
++ *
++ * Return: error code, or length of reply message on success
++ */
++static int
++batadv_netlink_dump_hardifs(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_hard_iface *hard_iface;
++	int ifindex;
++	int portid = NETLINK_CB(cb->skb).portid;
++	int seq = cb->nlh->nlmsg_seq;
++	int skip = cb->args[0];
++	int i = 0;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh,
++					     BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface)
++		return -ENODEV;
++
++	if (!batadv_softif_is_valid(soft_iface)) {
++		dev_put(soft_iface);
++		return -ENODEV;
++	}
++
++	rcu_read_lock();
++
++	list_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {
++		if (hard_iface->soft_iface != soft_iface)
++			continue;
++
++		if (i++ < skip)
++			continue;
++
++		if (batadv_netlink_dump_hardif_entry(msg, portid, seq,
++						     hard_iface)) {
++			i--;
++			break;
++		}
++	}
++
++	rcu_read_unlock();
++
++	dev_put(soft_iface);
++
++	cb->args[0] = i;
++
++	return msg->len;
++}
++
+ static struct genl_ops batadv_netlink_ops[] = {
+ 	{
+ 		.cmd = BATADV_CMD_GET_MESH_INFO,
+@@ -406,6 +524,12 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_algo_dump,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_HARDIFS,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_netlink_dump_hardifs,
++	},
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0025-batman-adv-netlink-add-translation-table-query.patch b/batman-adv/patches/0025-batman-adv-netlink-add-translation-table-query.patch
new file mode 100644
index 0000000..db04656
--- /dev/null
+++ b/batman-adv/patches/0025-batman-adv-netlink-add-translation-table-query.patch
@@ -0,0 +1,680 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:37 +0200
+Subject: [PATCH] batman-adv: netlink: add translation table query
+
+This adds the commands BATADV_CMD_GET_TRANSTABLE_LOCAL and
+BATADV_CMD_GET_TRANSTABLE_GLOBAL, which correspond to the transtable_local
+and transtable_global debugfs files.
+
+The batadv_tt_client_flags enum is moved to the UAPI to expose it as part
+of the netlink API.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: add policy for attributes, fix includes]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+[sw@simonwunderlich.de: fix VID attributes content]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h    |  56 ++++++
+ net/batman-adv/netlink.c           |  23 ++-
+ net/batman-adv/netlink.h           |   3 +
+ net/batman-adv/packet.h            |  36 ----
+ net/batman-adv/translation-table.c | 377 +++++++++++++++++++++++++++++++++++++
+ net/batman-adv/translation-table.h |   4 +
+ 6 files changed, 462 insertions(+), 37 deletions(-)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 8abcbca..1168d05 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -23,6 +23,42 @@
+ #define BATADV_NL_MCAST_GROUP_TPMETER	"tpmeter"
+ 
+ /**
++ * enum batadv_tt_client_flags - TT client specific flags
++ * @BATADV_TT_CLIENT_DEL: the client has to be deleted from the table
++ * @BATADV_TT_CLIENT_ROAM: the client roamed to/from another node and the new
++ *  update telling its new real location has not been received/sent yet
++ * @BATADV_TT_CLIENT_WIFI: this client is connected through a wifi interface.
++ *  This information is used by the "AP Isolation" feature
++ * @BATADV_TT_CLIENT_ISOLA: this client is considered "isolated". This
++ *  information is used by the Extended Isolation feature
++ * @BATADV_TT_CLIENT_NOPURGE: this client should never be removed from the table
++ * @BATADV_TT_CLIENT_NEW: this client has been added to the local table but has
++ *  not been announced yet
++ * @BATADV_TT_CLIENT_PENDING: this client is marked for removal but it is kept
++ *  in the table for one more originator interval for consistency purposes
++ * @BATADV_TT_CLIENT_TEMP: this global client has been detected to be part of
++ *  the network but no nnode has already announced it
++ *
++ * Bits from 0 to 7 are called _remote flags_ because they are sent on the wire.
++ * Bits from 8 to 15 are called _local flags_ because they are used for local
++ * computations only.
++ *
++ * Bits from 4 to 7 - a subset of remote flags - are ensured to be in sync with
++ * the other nodes in the network. To achieve this goal these flags are included
++ * in the TT CRC computation.
++ */
++enum batadv_tt_client_flags {
++	BATADV_TT_CLIENT_DEL     = (1 << 0),
++	BATADV_TT_CLIENT_ROAM    = (1 << 1),
++	BATADV_TT_CLIENT_WIFI    = (1 << 4),
++	BATADV_TT_CLIENT_ISOLA	 = (1 << 5),
++	BATADV_TT_CLIENT_NOPURGE = (1 << 8),
++	BATADV_TT_CLIENT_NEW     = (1 << 9),
++	BATADV_TT_CLIENT_PENDING = (1 << 10),
++	BATADV_TT_CLIENT_TEMP	 = (1 << 11),
++};
++
++/**
+  * enum batadv_nl_attrs - batman-adv netlink attributes
+  *
+  * @BATADV_ATTR_UNSPEC: unspecified attribute to catch errors
+@@ -41,6 +77,14 @@
+  * @BATADV_ATTR_TPMETER_COOKIE: session cookie to match tp_meter session
+  * @BATADV_ATTR_PAD: attribute used for padding for 64-bit alignment
+  * @BATADV_ATTR_ACTIVE: Flag indicating if the hard interface is active
++ * @BATADV_ATTR_TT_ADDRESS: Client MAC address
++ * @BATADV_ATTR_TT_TTVN: Translation table version
++ * @BATADV_ATTR_TT_LAST_TTVN: Previous translation table version
++ * @BATADV_ATTR_TT_CRC32: CRC32 over translation table
++ * @BATADV_ATTR_TT_VID: VLAN ID
++ * @BATADV_ATTR_TT_FLAGS: Translation table client flags
++ * @BATADV_ATTR_FLAG_BEST: Flags indicating entry is the best
++ * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -62,6 +106,14 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TPMETER_COOKIE,
+ 	BATADV_ATTR_PAD,
+ 	BATADV_ATTR_ACTIVE,
++	BATADV_ATTR_TT_ADDRESS,
++	BATADV_ATTR_TT_TTVN,
++	BATADV_ATTR_TT_LAST_TTVN,
++	BATADV_ATTR_TT_CRC32,
++	BATADV_ATTR_TT_VID,
++	BATADV_ATTR_TT_FLAGS,
++	BATADV_ATTR_FLAG_BEST,
++	BATADV_ATTR_LAST_SEEN_MSECS,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -77,6 +129,8 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_TP_METER_CANCEL: Cancel a tp meter session
+  * @BATADV_CMD_GET_ROUTING_ALGOS: Query the list of routing algorithms.
+  * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
++ * @BATADV_CMD_GET_TRANSTABLE_LOCAL: Query list of local translations
++ * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -87,6 +141,8 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_TP_METER_CANCEL,
+ 	BATADV_CMD_GET_ROUTING_ALGOS,
+ 	BATADV_CMD_GET_HARDIFS,
++	BATADV_CMD_GET_TRANSTABLE_LOCAL,
++	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 3f872d6..14360ec 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -40,6 +40,7 @@
+ #include "hard-interface.h"
+ #include "soft-interface.h"
+ #include "tp_meter.h"
++#include "translation-table.h"
+ 
+ struct genl_family batadv_netlink_family = {
+ 	.id = GENL_ID_GENERATE,
+@@ -73,6 +74,14 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_TPMETER_BYTES]	= { .type = NLA_U64 },
+ 	[BATADV_ATTR_TPMETER_COOKIE]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_ACTIVE]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_TT_ADDRESS]	= { .len = ETH_ALEN },
++	[BATADV_ATTR_TT_TTVN]		= { .type = NLA_U8 },
++	[BATADV_ATTR_TT_LAST_TTVN]	= { .type = NLA_U8 },
++	[BATADV_ATTR_TT_CRC32]		= { .type = NLA_U32 },
++	[BATADV_ATTR_TT_VID]		= { .type = NLA_U16 },
++	[BATADV_ATTR_TT_FLAGS]		= { .type = NLA_U32 },
++	[BATADV_ATTR_FLAG_BEST]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_LAST_SEEN_MSECS]	= { .type = NLA_U32 },
+ };
+ 
+ /**
+@@ -82,7 +91,7 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+  *
+  * Return: interface index, or 0.
+  */
+-static int
++int
+ batadv_netlink_get_ifindex(const struct nlmsghdr *nlh, int attrtype)
+ {
+ 	struct nlattr *attr = nlmsg_find_attr(nlh, GENL_HDRLEN, attrtype);
+@@ -530,6 +539,18 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_netlink_dump_hardifs,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_TRANSTABLE_LOCAL,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_tt_local_dump,
++	},
++	{
++		.cmd = BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_tt_global_dump,
++	},
+ };
+ 
+ /**
+diff --git a/net/batman-adv/netlink.h b/net/batman-adv/netlink.h
+index b399f49..52eb162 100644
+--- a/net/batman-adv/netlink.h
++++ b/net/batman-adv/netlink.h
+@@ -23,8 +23,11 @@
+ #include <linux/types.h>
+ #include <net/genetlink.h>
+ 
++struct nlmsghdr;
++
+ void batadv_netlink_register(void);
+ void batadv_netlink_unregister(void);
++int batadv_netlink_get_ifindex(const struct nlmsghdr *nlh, int attrtype);
+ 
+ int batadv_netlink_tpmeter_notify(struct batadv_priv *bat_priv, const u8 *dst,
+ 				  u8 result, u32 test_time, u64 total_bytes,
+diff --git a/net/batman-adv/packet.h b/net/batman-adv/packet.h
+index 6b011ff..6afc0b8 100644
+--- a/net/batman-adv/packet.h
++++ b/net/batman-adv/packet.h
+@@ -129,42 +129,6 @@ enum batadv_tt_data_flags {
+ };
+ 
+ /**
+- * enum batadv_tt_client_flags - TT client specific flags
+- * @BATADV_TT_CLIENT_DEL: the client has to be deleted from the table
+- * @BATADV_TT_CLIENT_ROAM: the client roamed to/from another node and the new
+- *  update telling its new real location has not been received/sent yet
+- * @BATADV_TT_CLIENT_WIFI: this client is connected through a wifi interface.
+- *  This information is used by the "AP Isolation" feature
+- * @BATADV_TT_CLIENT_ISOLA: this client is considered "isolated". This
+- *  information is used by the Extended Isolation feature
+- * @BATADV_TT_CLIENT_NOPURGE: this client should never be removed from the table
+- * @BATADV_TT_CLIENT_NEW: this client has been added to the local table but has
+- *  not been announced yet
+- * @BATADV_TT_CLIENT_PENDING: this client is marked for removal but it is kept
+- *  in the table for one more originator interval for consistency purposes
+- * @BATADV_TT_CLIENT_TEMP: this global client has been detected to be part of
+- *  the network but no nnode has already announced it
+- *
+- * Bits from 0 to 7 are called _remote flags_ because they are sent on the wire.
+- * Bits from 8 to 15 are called _local flags_ because they are used for local
+- * computations only.
+- *
+- * Bits from 4 to 7 - a subset of remote flags - are ensured to be in sync with
+- * the other nodes in the network. To achieve this goal these flags are included
+- * in the TT CRC computation.
+- */
+-enum batadv_tt_client_flags {
+-	BATADV_TT_CLIENT_DEL     = BIT(0),
+-	BATADV_TT_CLIENT_ROAM    = BIT(1),
+-	BATADV_TT_CLIENT_WIFI    = BIT(4),
+-	BATADV_TT_CLIENT_ISOLA	 = BIT(5),
+-	BATADV_TT_CLIENT_NOPURGE = BIT(8),
+-	BATADV_TT_CLIENT_NEW     = BIT(9),
+-	BATADV_TT_CLIENT_PENDING = BIT(10),
+-	BATADV_TT_CLIENT_TEMP	 = BIT(11),
+-};
+-
+-/**
+  * enum batadv_vlan_flags - flags for the four MSB of any vlan ID field
+  * @BATADV_VLAN_HAS_TAG: whether the field contains a valid vlan tag or not
+  */
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index af2bfef..2080407 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -37,20 +37,27 @@
+ #include <linux/list.h>
+ #include <linux/lockdep.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+ #include <linux/seq_file.h>
++#include <linux/skbuff.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+ #include <linux/stddef.h>
+ #include <linux/string.h>
+ #include <linux/workqueue.h>
++#include <net/genetlink.h>
++#include <net/netlink.h>
++#include <net/sock.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bridge_loop_avoidance.h"
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
+ #include "multicast.h"
++#include "netlink.h"
+ #include "originator.h"
+ #include "packet.h"
+ #include "soft-interface.h"
+@@ -1108,6 +1115,164 @@ out:
+ 	return 0;
+ }
+ 
++/**
++ * batadv_tt_local_dump_entry - Dump one TT local entry into a message
++ * @msg :Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @common: tt local & tt global common data
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_tt_local_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			   struct batadv_priv *bat_priv,
++			   struct batadv_tt_common_entry *common)
++{
++	void *hdr;
++	struct batadv_softif_vlan *vlan;
++	struct batadv_tt_local_entry *local;
++	unsigned int last_seen_msecs;
++	u32 crc;
++
++	local = container_of(common, struct batadv_tt_local_entry, common);
++	last_seen_msecs = jiffies_to_msecs(jiffies - local->last_seen);
++
++	vlan = batadv_softif_vlan_get(bat_priv, common->vid);
++	if (!vlan)
++		return 0;
++
++	crc = vlan->tt.crc;
++
++	batadv_softif_vlan_put(vlan);
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI,
++			  BATADV_CMD_GET_TRANSTABLE_LOCAL);
++	if (!hdr)
++		return -ENOBUFS;
++
++	if (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||
++	    nla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||
++	    nla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||
++	    nla_put_u32(msg, BATADV_ATTR_TT_FLAGS, common->flags))
++		goto nla_put_failure;
++
++	if (!(common->flags & BATADV_TT_CLIENT_NOPURGE) &&
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS, last_seen_msecs))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_tt_local_dump_bucket - Dump one TT local bucket into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @head: Pointer to the list containing the local tt entries
++ * @idx_s: Number of entries to skip
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_tt_local_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++			    struct batadv_priv *bat_priv,
++			    struct hlist_head *head, int *idx_s)
++{
++	struct batadv_tt_common_entry *common;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(common, head, hash_entry) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_tt_local_dump_entry(msg, portid, seq, bat_priv,
++					       common)) {
++			rcu_read_unlock();
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++	rcu_read_unlock();
++
++	*idx_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_tt_local_dump - Dump TT local entries into a message
++ * @msg: Netlink message to dump into
++ * @cb: Parameters from query
++ *
++ * Return: Error code, or 0 on success
++ */
++int batadv_tt_local_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_priv *bat_priv;
++	struct batadv_hard_iface *primary_if = NULL;
++	struct batadv_hashtable *hash;
++	struct hlist_head *head;
++	int ret;
++	int ifindex;
++	int bucket = cb->args[0];
++	int idx = cb->args[1];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	hash = bat_priv->tt.local_hash;
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_tt_local_dump_bucket(msg, portid, cb->nlh->nlmsg_seq,
++						bat_priv, head, &idx))
++			break;
++
++		bucket++;
++	}
++
++	ret = msg->len;
++
++ out:
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++
++	return ret;
++}
++
+ static void
+ batadv_tt_local_set_pending(struct batadv_priv *bat_priv,
+ 			    struct batadv_tt_local_entry *tt_local_entry,
+@@ -1756,6 +1921,218 @@ out:
+ }
+ 
+ /**
++ * batadv_tt_global_dump_subentry - Dump all TT local entries into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @common: tt local & tt global common data
++ * @orig: Originator node announcing a non-mesh client
++ * @best: Is the best originator for the TT entry
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_tt_global_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,
++			       struct batadv_tt_common_entry *common,
++			       struct batadv_tt_orig_list_entry *orig,
++			       bool best)
++{
++	void *hdr;
++	struct batadv_orig_node_vlan *vlan;
++	u8 last_ttvn;
++	u32 crc;
++
++	vlan = batadv_orig_node_vlan_get(orig->orig_node,
++					 common->vid);
++	if (!vlan)
++		return 0;
++
++	crc = vlan->tt.crc;
++
++	batadv_orig_node_vlan_put(vlan);
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI,
++			  BATADV_CMD_GET_TRANSTABLE_GLOBAL);
++	if (!hdr)
++		return -ENOBUFS;
++
++	last_ttvn = atomic_read(&orig->orig_node->last_ttvn);
++
++	if (nla_put(msg, BATADV_ATTR_TT_ADDRESS, ETH_ALEN, common->addr) ||
++	    nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,
++		    orig->orig_node->orig) ||
++	    nla_put_u8(msg, BATADV_ATTR_TT_TTVN, orig->ttvn) ||
++	    nla_put_u8(msg, BATADV_ATTR_TT_LAST_TTVN, last_ttvn) ||
++	    nla_put_u32(msg, BATADV_ATTR_TT_CRC32, crc) ||
++	    nla_put_u16(msg, BATADV_ATTR_TT_VID, common->vid) ||
++	    nla_put_u32(msg, BATADV_ATTR_TT_FLAGS, common->flags))
++		goto nla_put_failure;
++
++	if (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_tt_global_dump_entry - Dump one TT global entry into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @common: tt local & tt global common data
++ * @sub_s: Number of entries to skip
++ *
++ * This function assumes the caller holds rcu_read_lock().
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_tt_global_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			    struct batadv_priv *bat_priv,
++			    struct batadv_tt_common_entry *common, int *sub_s)
++{
++	struct batadv_tt_orig_list_entry *orig_entry, *best_entry;
++	struct batadv_tt_global_entry *global;
++	struct hlist_head *head;
++	int sub = 0;
++	bool best;
++
++	global = container_of(common, struct batadv_tt_global_entry, common);
++	best_entry = batadv_transtable_best_orig(bat_priv, global);
++	head = &global->orig_list;
++
++	hlist_for_each_entry_rcu(orig_entry, head, list) {
++		if (sub++ < *sub_s)
++			continue;
++
++		best = (orig_entry == best_entry);
++
++		if (batadv_tt_global_dump_subentry(msg, portid, seq, common,
++						   orig_entry, best)) {
++			*sub_s = sub - 1;
++			return -EMSGSIZE;
++		}
++	}
++
++	*sub_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_tt_global_dump_bucket - Dump one TT local bucket into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @head: Pointer to the list containing the global tt entries
++ * @idx_s: Number of entries to skip
++ * @sub: Number of entries to skip
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_tt_global_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++			     struct batadv_priv *bat_priv,
++			     struct hlist_head *head, int *idx_s, int *sub)
++{
++	struct batadv_tt_common_entry *common;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(common, head, hash_entry) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_tt_global_dump_entry(msg, portid, seq, bat_priv,
++						common, sub)) {
++			rcu_read_unlock();
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++	rcu_read_unlock();
++
++	*idx_s = 0;
++	*sub = 0;
++	return 0;
++}
++
++/**
++ * batadv_tt_global_dump -  Dump TT global entries into a message
++ * @msg: Netlink message to dump into
++ * @cb: Parameters from query
++ *
++ * Return: Error code, or length of message on success
++ */
++int batadv_tt_global_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_priv *bat_priv;
++	struct batadv_hard_iface *primary_if = NULL;
++	struct batadv_hashtable *hash;
++	struct hlist_head *head;
++	int ret;
++	int ifindex;
++	int bucket = cb->args[0];
++	int idx = cb->args[1];
++	int sub = cb->args[2];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	hash = bat_priv->tt.global_hash;
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_tt_global_dump_bucket(msg, portid,
++						 cb->nlh->nlmsg_seq, bat_priv,
++						 head, &idx, &sub))
++			break;
++
++		bucket++;
++	}
++
++	ret = msg->len;
++
++ out:
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++	cb->args[2] = sub;
++
++	return ret;
++}
++
++/**
+  * _batadv_tt_global_del_orig_entry - remove and free an orig_entry
+  * @tt_global_entry: the global entry to remove the orig_entry from
+  * @orig_entry: the orig entry to remove and free
+diff --git a/net/batman-adv/translation-table.h b/net/batman-adv/translation-table.h
+index 02b0f85..783fdba 100644
+--- a/net/batman-adv/translation-table.h
++++ b/net/batman-adv/translation-table.h
+@@ -22,8 +22,10 @@
+ 
+ #include <linux/types.h>
+ 
++struct netlink_callback;
+ struct net_device;
+ struct seq_file;
++struct sk_buff;
+ 
+ int batadv_tt_init(struct batadv_priv *bat_priv);
+ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+@@ -33,6 +35,8 @@ u16 batadv_tt_local_remove(struct batadv_priv *bat_priv,
+ 			   const char *message, bool roaming);
+ int batadv_tt_local_seq_print_text(struct seq_file *seq, void *offset);
+ int batadv_tt_global_seq_print_text(struct seq_file *seq, void *offset);
++int batadv_tt_local_dump(struct sk_buff *msg, struct netlink_callback *cb);
++int batadv_tt_global_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ void batadv_tt_global_del_orig(struct batadv_priv *bat_priv,
+ 			       struct batadv_orig_node *orig_node,
+ 			       s32 match_vid, const char *message);
diff --git a/batman-adv/patches/0026-batman-adv-Provide-TTVN-in-the-mesh_info-netlink-msg.patch b/batman-adv/patches/0026-batman-adv-Provide-TTVN-in-the-mesh_info-netlink-msg.patch
new file mode 100644
index 0000000..e3dfc3e
--- /dev/null
+++ b/batman-adv/patches/0026-batman-adv-Provide-TTVN-in-the-mesh_info-netlink-msg.patch
@@ -0,0 +1,38 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 3 Jul 2016 13:31:38 +0200
+Subject: [PATCH] batman-adv: Provide TTVN in the mesh_info netlink msg
+
+The TTVN is the main information for the debugging of translation table
+problems. It is therefore necessary when comparing the global translation
+tables.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/netlink.c | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 14360ec..0c0d20b 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -18,6 +18,7 @@
+ #include "netlink.h"
+ #include "main.h"
+ 
++#include <linux/atomic.h>
+ #include <linux/errno.h>
+ #include <linux/fs.h>
+ #include <linux/genetlink.h>
+@@ -121,7 +122,9 @@ batadv_netlink_mesh_info_put(struct sk_buff *msg, struct net_device *soft_iface)
+ 	    nla_put_u32(msg, BATADV_ATTR_MESH_IFINDEX, soft_iface->ifindex) ||
+ 	    nla_put_string(msg, BATADV_ATTR_MESH_IFNAME, soft_iface->name) ||
+ 	    nla_put(msg, BATADV_ATTR_MESH_ADDRESS, ETH_ALEN,
+-		    soft_iface->dev_addr))
++		    soft_iface->dev_addr) ||
++	    nla_put_u8(msg, BATADV_ATTR_TT_TTVN,
++		       (u8)atomic_read(&bat_priv->tt.vn)))
+ 		goto out;
+ 
+ 	primary_if = batadv_primary_if_get_selected(bat_priv);
diff --git a/batman-adv/patches/0027-batman-adv-netlink-add-originator-and-neighbor-table.patch b/batman-adv/patches/0027-batman-adv-netlink-add-originator-and-neighbor-table.patch
new file mode 100644
index 0000000..41a6c01
--- /dev/null
+++ b/batman-adv/patches/0027-batman-adv-netlink-add-originator-and-neighbor-table.patch
@@ -0,0 +1,352 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:39 +0200
+Subject: [PATCH] batman-adv: netlink: add originator and neighbor table queries
+
+Add BATADV_CMD_GET_ORIGINATORS and BATADV_CMD_GET_NEIGHBORS commands,
+using handlers bat_orig_dump and bat_neigh_dump in batadv_algo_ops. Will
+always return -EOPNOTSUPP for now, as no implementations exist yet.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Rewrite based on new algo_ops structures]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h |   4 +
+ net/batman-adv/netlink.c        |  13 ++++
+ net/batman-adv/originator.c     | 160 ++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/originator.h     |   4 +
+ net/batman-adv/types.h          |   9 +++
+ 5 files changed, 190 insertions(+)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 1168d05..3f7a415 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -131,6 +131,8 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_HARDIFS: Query list of hard interfaces
+  * @BATADV_CMD_GET_TRANSTABLE_LOCAL: Query list of local translations
+  * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
++ * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
++ * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -143,6 +145,8 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_HARDIFS,
+ 	BATADV_CMD_GET_TRANSTABLE_LOCAL,
+ 	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
++	BATADV_CMD_GET_ORIGINATORS,
++	BATADV_CMD_GET_NEIGHBORS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 0c0d20b..8469fc4 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -39,6 +39,7 @@
+ 
+ #include "bat_algo.h"
+ #include "hard-interface.h"
++#include "originator.h"
+ #include "soft-interface.h"
+ #include "tp_meter.h"
+ #include "translation-table.h"
+@@ -554,6 +555,18 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_tt_global_dump,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_ORIGINATORS,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_orig_dump,
++	},
++	{
++		.cmd = BATADV_CMD_GET_NEIGHBORS,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_hardif_neigh_dump,
++	},
+ };
+ 
+ /**
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 3940b5d..95c8555 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -28,11 +28,15 @@
+ #include <linux/list.h>
+ #include <linux/lockdep.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/rculist.h>
+ #include <linux/seq_file.h>
++#include <linux/skbuff.h>
+ #include <linux/slab.h>
+ #include <linux/spinlock.h>
+ #include <linux/workqueue.h>
++#include <net/sock.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
+ #include "distributed-arp-table.h"
+@@ -42,8 +46,10 @@
+ #include "hash.h"
+ #include "log.h"
+ #include "multicast.h"
++#include "netlink.h"
+ #include "network-coding.h"
+ #include "routing.h"
++#include "soft-interface.h"
+ #include "translation-table.h"
+ 
+ /* hash class keys */
+@@ -721,6 +727,83 @@ int batadv_hardif_neigh_seq_print_text(struct seq_file *seq, void *offset)
+ }
+ 
+ /**
++ * batadv_hardif_neigh_dump - Dump to netlink the neighbor infos for a specific
++ *  outgoing interface
++ * @msg: message to dump into
++ * @cb: parameters for the dump
++ *
++ * Return: 0 or error value
++ */
++int batadv_hardif_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct net_device *hard_iface = NULL;
++	struct batadv_hard_iface *hardif = BATADV_IF_DEFAULT;
++	struct batadv_priv *bat_priv;
++	struct batadv_hard_iface *primary_if = NULL;
++	int ret;
++	int ifindex, hard_ifindex;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	hard_ifindex = batadv_netlink_get_ifindex(cb->nlh,
++						  BATADV_ATTR_HARD_IFINDEX);
++	if (hard_ifindex) {
++		hard_iface = dev_get_by_index(net, hard_ifindex);
++		if (hard_iface)
++			hardif = batadv_hardif_get_by_netdev(hard_iface);
++
++		if (!hardif) {
++			ret = -ENODEV;
++			goto out;
++		}
++
++		if (hardif->soft_iface != soft_iface) {
++			ret = -ENOENT;
++			goto out;
++		}
++	}
++
++	if (!bat_priv->algo_ops->neigh.dump) {
++		ret = -EOPNOTSUPP;
++		goto out;
++	}
++
++	bat_priv->algo_ops->neigh.dump(msg, cb, bat_priv, hardif);
++
++	ret = msg->len;
++
++ out:
++	if (hardif)
++		batadv_hardif_put(hardif);
++	if (hard_iface)
++		dev_put(hard_iface);
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	return ret;
++}
++
++/**
+  * batadv_orig_ifinfo_release - release orig_ifinfo from lists and queue for
+  *  free after rcu grace period
+  * @ref: kref pointer of the orig_ifinfo
+@@ -1330,6 +1413,83 @@ out:
+ 	return 0;
+ }
+ 
++/**
++ * batadv_orig_dump - Dump to netlink the originator infos for a specific
++ *  outgoing interface
++ * @msg: message to dump into
++ * @cb: parameters for the dump
++ *
++ * Return: 0 or error value
++ */
++int batadv_orig_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct net_device *hard_iface = NULL;
++	struct batadv_hard_iface *hardif = BATADV_IF_DEFAULT;
++	struct batadv_priv *bat_priv;
++	struct batadv_hard_iface *primary_if = NULL;
++	int ret;
++	int ifindex, hard_ifindex;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh, BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	hard_ifindex = batadv_netlink_get_ifindex(cb->nlh,
++						  BATADV_ATTR_HARD_IFINDEX);
++	if (hard_ifindex) {
++		hard_iface = dev_get_by_index(net, hard_ifindex);
++		if (hard_iface)
++			hardif = batadv_hardif_get_by_netdev(hard_iface);
++
++		if (!hardif) {
++			ret = -ENODEV;
++			goto out;
++		}
++
++		if (hardif->soft_iface != soft_iface) {
++			ret = -ENOENT;
++			goto out;
++		}
++	}
++
++	if (!bat_priv->algo_ops->orig.dump) {
++		ret = -EOPNOTSUPP;
++		goto out;
++	}
++
++	bat_priv->algo_ops->orig.dump(msg, cb, bat_priv, hardif);
++
++	ret = msg->len;
++
++ out:
++	if (hardif)
++		batadv_hardif_put(hardif);
++	if (hard_iface)
++		dev_put(hard_iface);
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	return ret;
++}
++
+ int batadv_orig_hash_add_if(struct batadv_hard_iface *hard_iface,
+ 			    int max_if_num)
+ {
+diff --git a/net/batman-adv/originator.h b/net/batman-adv/originator.h
+index 566306b..ebc5618 100644
+--- a/net/batman-adv/originator.h
++++ b/net/batman-adv/originator.h
+@@ -31,7 +31,9 @@
+ 
+ #include "hash.h"
+ 
++struct netlink_callback;
+ struct seq_file;
++struct sk_buff;
+ 
+ bool batadv_compare_orig(const struct hlist_node *node, const void *data2);
+ int batadv_originator_init(struct batadv_priv *bat_priv);
+@@ -61,6 +63,7 @@ batadv_neigh_ifinfo_get(struct batadv_neigh_node *neigh,
+ 			struct batadv_hard_iface *if_outgoing);
+ void batadv_neigh_ifinfo_put(struct batadv_neigh_ifinfo *neigh_ifinfo);
+ 
++int batadv_hardif_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ int batadv_hardif_neigh_seq_print_text(struct seq_file *seq, void *offset);
+ 
+ struct batadv_orig_ifinfo *
+@@ -72,6 +75,7 @@ batadv_orig_ifinfo_new(struct batadv_orig_node *orig_node,
+ void batadv_orig_ifinfo_put(struct batadv_orig_ifinfo *orig_ifinfo);
+ 
+ int batadv_orig_seq_print_text(struct seq_file *seq, void *offset);
++int batadv_orig_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ int batadv_orig_hardif_seq_print_text(struct seq_file *seq, void *offset);
+ int batadv_orig_hash_add_if(struct batadv_hard_iface *hard_iface,
+ 			    int max_if_num);
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 72806a3..968023a 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -28,6 +28,7 @@
+ #include <linux/if_ether.h>
+ #include <linux/kref.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/sched.h> /* for linux/wait.h */
+ #include <linux/spinlock.h>
+ #include <linux/types.h>
+@@ -1418,6 +1419,7 @@ struct batadv_algo_iface_ops {
+  * @is_similar_or_better: check if neigh1 is equally similar or better than
+  *  neigh2 for their respective outgoing interface from the metric prospective
+  * @print: print the single hop neighbor list (optional)
++ * @dump: dump neighbors to a netlink socket (optional)
+  */
+ struct batadv_algo_neigh_ops {
+ 	void (*hardif_init)(struct batadv_hardif_neigh_node *neigh);
+@@ -1430,6 +1432,9 @@ struct batadv_algo_neigh_ops {
+ 				     struct batadv_neigh_node *neigh2,
+ 				     struct batadv_hard_iface *if_outgoing2);
+ 	void (*print)(struct batadv_priv *priv, struct seq_file *seq);
++	void (*dump)(struct sk_buff *msg, struct netlink_callback *cb,
++		     struct batadv_priv *priv,
++		     struct batadv_hard_iface *hard_iface);
+ };
+ 
+ /**
+@@ -1441,6 +1446,7 @@ struct batadv_algo_neigh_ops {
+  * @del_if: ask the routing algorithm to apply the needed changes to the
+  *  orig_node due to an hard-interface being removed from the mesh (optional)
+  * @print: print the originator table (optional)
++ * @dump: dump originators to a netlink socket (optional)
+  */
+ struct batadv_algo_orig_ops {
+ 	void (*free)(struct batadv_orig_node *orig_node);
+@@ -1449,6 +1455,9 @@ struct batadv_algo_orig_ops {
+ 		      int del_if_num);
+ 	void (*print)(struct batadv_priv *priv, struct seq_file *seq,
+ 		      struct batadv_hard_iface *hard_iface);
++	void (*dump)(struct sk_buff *msg, struct netlink_callback *cb,
++		     struct batadv_priv *priv,
++		     struct batadv_hard_iface *hard_iface);
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0028-batman-adv-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump.patch b/batman-adv/patches/0028-batman-adv-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump.patch
new file mode 100644
index 0000000..0f11dcd
--- /dev/null
+++ b/batman-adv/patches/0028-batman-adv-add-B.A.T.M.A.N.-IV-bat_-orig-neigh-_dump.patch
@@ -0,0 +1,467 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:40 +0200
+Subject: [PATCH] batman-adv: add B.A.T.M.A.N. IV bat_{orig, neigh}_dump implementations
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: Fix function parameter alignments,
+add policy for attributes, fix includes, fix algo_ops integration]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h |   4 +
+ net/batman-adv/bat_iv_ogm.c     | 366 ++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/netlink.c        |   2 +
+ 3 files changed, 372 insertions(+)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 3f7a415..ba2359a 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -85,6 +85,8 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_TT_FLAGS: Translation table client flags
+  * @BATADV_ATTR_FLAG_BEST: Flags indicating entry is the best
+  * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
++ * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
++ * @BATADV_ATTR_TQ: TQ to neighbour
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -114,6 +116,8 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_TT_FLAGS,
+ 	BATADV_ATTR_FLAG_BEST,
+ 	BATADV_ATTR_LAST_SEEN_MSECS,
++	BATADV_ATTR_NEIGH_ADDRESS,
++	BATADV_ATTR_TQ,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index a40cdf2..7a8c0f6 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -35,6 +35,7 @@
+ #include <linux/list.h>
+ #include <linux/lockdep.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/pkt_sched.h>
+ #include <linux/printk.h>
+ #include <linux/random.h>
+@@ -48,6 +49,9 @@
+ #include <linux/string.h>
+ #include <linux/types.h>
+ #include <linux/workqueue.h>
++#include <net/genetlink.h>
++#include <net/netlink.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
+ #include "bitarray.h"
+@@ -55,6 +59,7 @@
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
++#include "netlink.h"
+ #include "network-coding.h"
+ #include "originator.h"
+ #include "packet.h"
+@@ -1948,6 +1953,235 @@ next:
+ }
+ 
+ /**
++ * batadv_iv_ogm_neigh_get_tq_avg - Get the TQ average for a neighbour on a
++ *  given outgoing interface.
++ * @neigh_node: Neighbour of interest
++ * @if_outgoing: Outgoing interface of interest
++ * @tq_avg: Pointer of where to store the TQ average
++ *
++ * Return: False if no average TQ available, otherwise true.
++ */
++static bool
++batadv_iv_ogm_neigh_get_tq_avg(struct batadv_neigh_node *neigh_node,
++			       struct batadv_hard_iface *if_outgoing,
++			       u8 *tq_avg)
++{
++	struct batadv_neigh_ifinfo *n_ifinfo;
++
++	n_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);
++	if (!n_ifinfo)
++		return false;
++
++	*tq_avg = n_ifinfo->bat_iv.tq_avg;
++	batadv_neigh_ifinfo_put(n_ifinfo);
++
++	return true;
++}
++
++/**
++ * batadv_iv_ogm_orig_dump_subentry - Dump an originator subentry into a
++ *  message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @orig_node: Originator to dump
++ * @neigh_node: Single hops neighbour
++ * @best: Is the best originator
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_iv_ogm_orig_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,
++				 struct batadv_priv *bat_priv,
++				 struct batadv_hard_iface *if_outgoing,
++				 struct batadv_orig_node *orig_node,
++				 struct batadv_neigh_node *neigh_node,
++				 bool best)
++{
++	void *hdr;
++	u8 tq_avg;
++	unsigned int last_seen_msecs;
++
++	last_seen_msecs = jiffies_to_msecs(jiffies - orig_node->last_seen);
++
++	if (!batadv_iv_ogm_neigh_get_tq_avg(neigh_node, if_outgoing, &tq_avg))
++		return 0;
++
++	if (if_outgoing != BATADV_IF_DEFAULT &&
++	    if_outgoing != neigh_node->if_incoming)
++		return 0;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_ORIGINATORS);
++	if (!hdr)
++		return -ENOBUFS;
++
++	if (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,
++		    orig_node->orig) ||
++	    nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,
++		    neigh_node->addr) ||
++	    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++			neigh_node->if_incoming->net_dev->ifindex) ||
++	    nla_put_u8(msg, BATADV_ATTR_TQ, tq_avg) ||
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,
++			last_seen_msecs))
++		goto nla_put_failure;
++
++	if (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_iv_ogm_orig_dump_entry - Dump an originator entry into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @orig_node: Originator to dump
++ * @sub_s: Number of sub entries to skip
++ *
++ * This function assumes the caller holds rcu_read_lock().
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_iv_ogm_orig_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			      struct batadv_priv *bat_priv,
++			      struct batadv_hard_iface *if_outgoing,
++			      struct batadv_orig_node *orig_node, int *sub_s)
++{
++	struct batadv_neigh_node *neigh_node_best;
++	struct batadv_neigh_node *neigh_node;
++	int sub = 0;
++	bool best;
++	u8 tq_avg_best;
++
++	neigh_node_best = batadv_orig_router_get(orig_node, if_outgoing);
++	if (!neigh_node_best)
++		goto out;
++
++	if (!batadv_iv_ogm_neigh_get_tq_avg(neigh_node_best, if_outgoing,
++					    &tq_avg_best))
++		goto out;
++
++	if (tq_avg_best == 0)
++		goto out;
++
++	hlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {
++		if (sub++ < *sub_s)
++			continue;
++
++		best = (neigh_node == neigh_node_best);
++
++		if (batadv_iv_ogm_orig_dump_subentry(msg, portid, seq,
++						     bat_priv, if_outgoing,
++						     orig_node, neigh_node,
++						     best)) {
++			batadv_neigh_node_put(neigh_node_best);
++
++			*sub_s = sub - 1;
++			return -EMSGSIZE;
++		}
++	}
++
++ out:
++	if (neigh_node_best)
++		batadv_neigh_node_put(neigh_node_best);
++
++	*sub_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_iv_ogm_orig_dump_bucket - Dump an originator bucket into a
++ *  message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @head: Bucket to be dumped
++ * @idx_s: Number of entries to be skipped
++ * @sub: Number of sub entries to be skipped
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_iv_ogm_orig_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++			       struct batadv_priv *bat_priv,
++			       struct batadv_hard_iface *if_outgoing,
++			       struct hlist_head *head, int *idx_s, int *sub)
++{
++	struct batadv_orig_node *orig_node;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(orig_node, head, hash_entry) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_iv_ogm_orig_dump_entry(msg, portid, seq, bat_priv,
++						  if_outgoing, orig_node,
++						  sub)) {
++			rcu_read_unlock();
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++	rcu_read_unlock();
++
++	*idx_s = 0;
++	*sub = 0;
++	return 0;
++}
++
++/**
++ * batadv_iv_ogm_orig_dump - Dump the originators into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ */
++static void
++batadv_iv_ogm_orig_dump(struct sk_buff *msg, struct netlink_callback *cb,
++			struct batadv_priv *bat_priv,
++			struct batadv_hard_iface *if_outgoing)
++{
++	struct batadv_hashtable *hash = bat_priv->orig_hash;
++	struct hlist_head *head;
++	int bucket = cb->args[0];
++	int idx = cb->args[1];
++	int sub = cb->args[2];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_iv_ogm_orig_dump_bucket(msg, portid,
++						   cb->nlh->nlmsg_seq,
++						   bat_priv, if_outgoing, head,
++						   &idx, &sub))
++			break;
++
++		bucket++;
++	}
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++	cb->args[2] = sub;
++}
++
++/**
+  * batadv_iv_hardif_neigh_print - print a single hop neighbour node
+  * @seq: neighbour table seq_file struct
+  * @hardif_neigh: hardif neighbour information
+@@ -2044,6 +2278,136 @@ out:
+ }
+ 
+ /**
++ * batadv_iv_ogm_neigh_dump_neigh - Dump a neighbour into a netlink message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @hardif_neigh: Neighbour to be dumped
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_iv_ogm_neigh_dump_neigh(struct sk_buff *msg, u32 portid, u32 seq,
++			       struct batadv_hardif_neigh_node *hardif_neigh)
++{
++	void *hdr;
++	unsigned int last_seen_msecs;
++
++	last_seen_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen);
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_NEIGHBORS);
++	if (!hdr)
++		return -ENOBUFS;
++
++	if (nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,
++		    hardif_neigh->addr) ||
++	    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++			hardif_neigh->if_incoming->net_dev->ifindex) ||
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,
++			last_seen_msecs))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_iv_ogm_neigh_dump_hardif - Dump the neighbours of a hard interface
++ *  into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @hard_iface: Hard interface to dump the neighbours for
++ * @idx_s: Number of entries to skip
++ *
++ * This function assumes the caller holds rcu_read_lock().
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_iv_ogm_neigh_dump_hardif(struct sk_buff *msg, u32 portid, u32 seq,
++				struct batadv_priv *bat_priv,
++				struct batadv_hard_iface *hard_iface,
++				int *idx_s)
++{
++	struct batadv_hardif_neigh_node *hardif_neigh;
++	int idx = 0;
++
++	hlist_for_each_entry_rcu(hardif_neigh,
++				 &hard_iface->neigh_list, list) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_iv_ogm_neigh_dump_neigh(msg, portid, seq,
++						   hardif_neigh)) {
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++
++	*idx_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_iv_ogm_neigh_dump - Dump the neighbours into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ * @single_hardif: Limit dump to this hard interfaace
++ */
++static void
++batadv_iv_ogm_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb,
++			 struct batadv_priv *bat_priv,
++			 struct batadv_hard_iface *single_hardif)
++{
++	struct batadv_hard_iface *hard_iface;
++	int i_hardif = 0;
++	int i_hardif_s = cb->args[0];
++	int idx = cb->args[1];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	rcu_read_lock();
++	if (single_hardif) {
++		if (i_hardif_s == 0) {
++			if (batadv_iv_ogm_neigh_dump_hardif(msg, portid,
++							    cb->nlh->nlmsg_seq,
++							    bat_priv,
++							    single_hardif,
++							    &idx) == 0)
++				i_hardif++;
++		}
++	} else {
++		list_for_each_entry_rcu(hard_iface, &batadv_hardif_list,
++					list) {
++			if (hard_iface->soft_iface != bat_priv->soft_iface)
++				continue;
++
++			if (i_hardif++ < i_hardif_s)
++				continue;
++
++			if (batadv_iv_ogm_neigh_dump_hardif(msg, portid,
++							    cb->nlh->nlmsg_seq,
++							    bat_priv,
++							    hard_iface, &idx)) {
++				i_hardif--;
++				break;
++			}
++		}
++	}
++	rcu_read_unlock();
++
++	cb->args[0] = i_hardif;
++	cb->args[1] = idx;
++}
++
++/**
+  * batadv_iv_ogm_neigh_cmp - compare the metrics of two neighbors
+  * @neigh1: the first neighbor object of the comparison
+  * @if_outgoing1: outgoing interface for the first neighbor
+@@ -2330,9 +2694,11 @@ static struct batadv_algo_ops batadv_batman_iv __read_mostly = {
+ 		.cmp = batadv_iv_ogm_neigh_cmp,
+ 		.is_similar_or_better = batadv_iv_ogm_neigh_is_sob,
+ 		.print = batadv_iv_neigh_print,
++		.dump = batadv_iv_ogm_neigh_dump,
+ 	},
+ 	.orig = {
+ 		.print = batadv_iv_ogm_orig_print,
++		.dump = batadv_iv_ogm_orig_dump,
+ 		.free = batadv_iv_ogm_orig_free,
+ 		.add_if = batadv_iv_ogm_orig_add_if,
+ 		.del_if = batadv_iv_ogm_orig_del_if,
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 8469fc4..0c7940c 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -84,6 +84,8 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_TT_FLAGS]		= { .type = NLA_U32 },
+ 	[BATADV_ATTR_FLAG_BEST]		= { .type = NLA_FLAG },
+ 	[BATADV_ATTR_LAST_SEEN_MSECS]	= { .type = NLA_U32 },
++	[BATADV_ATTR_NEIGH_ADDRESS]	= { .len = ETH_ALEN },
++	[BATADV_ATTR_TQ]		= { .type = NLA_U8 },
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0029-batman-adv-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-.patch b/batman-adv/patches/0029-batman-adv-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-.patch
new file mode 100644
index 0000000..b733a94
--- /dev/null
+++ b/batman-adv/patches/0029-batman-adv-add-B.A.T.M.A.N.-V-bat_-orig-neigh-_dump-.patch
@@ -0,0 +1,446 @@
+From: Matthias Schiffer <mschiffer@universe-factory.net>
+Date: Sun, 3 Jul 2016 13:31:41 +0200
+Subject: [PATCH] batman-adv: add B.A.T.M.A.N. V bat_{orig, neigh}_dump implementations
+
+Dump the algo V originators and neighbours.
+
+Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven@narfation.org: Fix includes, fix algo_ops integration]
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h |   2 +
+ net/batman-adv/bat_v.c          | 340 ++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/netlink.c        |   1 +
+ 3 files changed, 343 insertions(+)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index ba2359a..2e2747f 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -87,6 +87,7 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_LAST_SEEN_MSECS: Time in milliseconds since last seen
+  * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
+  * @BATADV_ATTR_TQ: TQ to neighbour
++ * @BATADV_ATTR_THROUGHPUT: Estimated throughput to Neighbour
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -118,6 +119,7 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_LAST_SEEN_MSECS,
+ 	BATADV_ATTR_NEIGH_ADDRESS,
+ 	BATADV_ATTR_TQ,
++	BATADV_ATTR_THROUGHPUT,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index 1d777b1..9dccfaf 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -22,17 +22,22 @@
+ #include <linux/bug.h>
+ #include <linux/cache.h>
+ #include <linux/errno.h>
++#include <linux/if_ether.h>
+ #include <linux/init.h>
+ #include <linux/jiffies.h>
+ #include <linux/kernel.h>
+ #include <linux/kref.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+ #include <linux/seq_file.h>
+ #include <linux/stddef.h>
+ #include <linux/types.h>
+ #include <linux/workqueue.h>
++#include <net/genetlink.h>
++#include <net/netlink.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
+ #include "bat_v_elp.h"
+@@ -42,9 +47,12 @@
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
++#include "netlink.h"
+ #include "originator.h"
+ #include "packet.h"
+ 
++struct sk_buff;
++
+ static void batadv_v_iface_activate(struct batadv_hard_iface *hard_iface)
+ {
+ 	struct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);
+@@ -206,6 +214,138 @@ static void batadv_v_neigh_print(struct batadv_priv *bat_priv,
+ }
+ 
+ /**
++ * batadv_v_neigh_dump_neigh - Dump a neighbour into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @hardif_neigh: Neighbour to dump
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_v_neigh_dump_neigh(struct sk_buff *msg, u32 portid, u32 seq,
++			  struct batadv_hardif_neigh_node *hardif_neigh)
++{
++	void *hdr;
++	unsigned int last_seen_msecs;
++	u32 throughput;
++
++	last_seen_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen);
++	throughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);
++	throughput = throughput * 100;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,
++			  BATADV_CMD_GET_NEIGHBORS);
++	if (!hdr)
++		return -ENOBUFS;
++
++	if (nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,
++		    hardif_neigh->addr) ||
++	    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++			hardif_neigh->if_incoming->net_dev->ifindex) ||
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,
++			last_seen_msecs) ||
++	    nla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_v_neigh_dump_hardif - Dump the  neighbours of a hard interface  into
++ *  a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @hard_iface: The hard interface to be dumped
++ * @idx_s: Entries to be skipped
++ *
++ * This function assumes the caller holds rcu_read_lock().
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_v_neigh_dump_hardif(struct sk_buff *msg, u32 portid, u32 seq,
++			   struct batadv_priv *bat_priv,
++			   struct batadv_hard_iface *hard_iface,
++			   int *idx_s)
++{
++	struct batadv_hardif_neigh_node *hardif_neigh;
++	int idx = 0;
++
++	hlist_for_each_entry_rcu(hardif_neigh,
++				 &hard_iface->neigh_list, list) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_v_neigh_dump_neigh(msg, portid, seq, hardif_neigh)) {
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++
++	*idx_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_v_neigh_dump - Dump the neighbours of a hard interface  into a
++ *  message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ * @single_hardif: Limit dumping to this hard interface
++ */
++static void
++batadv_v_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb,
++		    struct batadv_priv *bat_priv,
++		    struct batadv_hard_iface *single_hardif)
++{
++	struct batadv_hard_iface *hard_iface;
++	int i_hardif = 0;
++	int i_hardif_s = cb->args[0];
++	int idx = cb->args[1];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	rcu_read_lock();
++	if (single_hardif) {
++		if (i_hardif_s == 0) {
++			if (batadv_v_neigh_dump_hardif(msg, portid,
++						       cb->nlh->nlmsg_seq,
++						       bat_priv, single_hardif,
++						       &idx) == 0)
++				i_hardif++;
++		}
++	} else {
++		list_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {
++			if (hard_iface->soft_iface != bat_priv->soft_iface)
++				continue;
++
++			if (i_hardif++ < i_hardif_s)
++				continue;
++
++			if (batadv_v_neigh_dump_hardif(msg, portid,
++						       cb->nlh->nlmsg_seq,
++						       bat_priv, hard_iface,
++						       &idx)) {
++				i_hardif--;
++				break;
++			}
++		}
++	}
++	rcu_read_unlock();
++
++	cb->args[0] = i_hardif;
++	cb->args[1] = idx;
++}
++
++/**
+  * batadv_v_orig_print - print the originator table
+  * @bat_priv: the bat priv with all the soft interface information
+  * @seq: debugfs table seq_file struct
+@@ -272,6 +412,204 @@ next:
+ 		seq_puts(seq, "No batman nodes in range ...\n");
+ }
+ 
++/**
++ * batadv_v_orig_dump_subentry - Dump an originator subentry into a
++ *  message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @orig_node: Originator to dump
++ * @neigh_node: Single hops neighbour
++ * @best: Is the best originator
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_v_orig_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,
++			    struct batadv_priv *bat_priv,
++			    struct batadv_hard_iface *if_outgoing,
++			    struct batadv_orig_node *orig_node,
++			    struct batadv_neigh_node *neigh_node,
++			    bool best)
++{
++	struct batadv_neigh_ifinfo *n_ifinfo;
++	unsigned int last_seen_msecs;
++	u32 throughput;
++	void *hdr;
++
++	n_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);
++	if (!n_ifinfo)
++		return 0;
++
++	throughput = n_ifinfo->bat_v.throughput * 100;
++
++	batadv_neigh_ifinfo_put(n_ifinfo);
++
++	last_seen_msecs = jiffies_to_msecs(jiffies - orig_node->last_seen);
++
++	if (if_outgoing != BATADV_IF_DEFAULT &&
++	    if_outgoing != neigh_node->if_incoming)
++		return 0;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,
++			  BATADV_CMD_GET_ORIGINATORS);
++	if (!hdr)
++		return -ENOBUFS;
++
++	if (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN, orig_node->orig) ||
++	    nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,
++		    neigh_node->addr) ||
++	    nla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,
++			neigh_node->if_incoming->net_dev->ifindex) ||
++	    nla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput) ||
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,
++			last_seen_msecs))
++		goto nla_put_failure;
++
++	if (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))
++		goto nla_put_failure;
++
++	genlmsg_end(msg, hdr);
++	return 0;
++
++ nla_put_failure:
++	genlmsg_cancel(msg, hdr);
++	return -EMSGSIZE;
++}
++
++/**
++ * batadv_v_orig_dump_entry - Dump an originator entry into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @orig_node: Originator to dump
++ * @sub_s: Number of sub entries to skip
++ *
++ * This function assumes the caller holds rcu_read_lock().
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_v_orig_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			 struct batadv_priv *bat_priv,
++			 struct batadv_hard_iface *if_outgoing,
++			 struct batadv_orig_node *orig_node, int *sub_s)
++{
++	struct batadv_neigh_node *neigh_node_best;
++	struct batadv_neigh_node *neigh_node;
++	int sub = 0;
++	bool best;
++
++	neigh_node_best = batadv_orig_router_get(orig_node, if_outgoing);
++	if (!neigh_node_best)
++		goto out;
++
++	hlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {
++		if (sub++ < *sub_s)
++			continue;
++
++		best = (neigh_node == neigh_node_best);
++
++		if (batadv_v_orig_dump_subentry(msg, portid, seq, bat_priv,
++						if_outgoing, orig_node,
++						neigh_node, best)) {
++			batadv_neigh_node_put(neigh_node_best);
++
++			*sub_s = sub - 1;
++			return -EMSGSIZE;
++		}
++	}
++
++ out:
++	if (neigh_node_best)
++		batadv_neigh_node_put(neigh_node_best);
++
++	*sub_s = 0;
++	return 0;
++}
++
++/**
++ * batadv_v_orig_dump_bucket - Dump an originator bucket into a
++ *  message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ * @head: Bucket to be dumped
++ * @idx_s: Number of entries to be skipped
++ * @sub: Number of sub entries to be skipped
++ *
++ * Return: Error code, or 0 on success
++ */
++static int
++batadv_v_orig_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++			  struct batadv_priv *bat_priv,
++			  struct batadv_hard_iface *if_outgoing,
++			  struct hlist_head *head, int *idx_s, int *sub)
++{
++	struct batadv_orig_node *orig_node;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(orig_node, head, hash_entry) {
++		if (idx++ < *idx_s)
++			continue;
++
++		if (batadv_v_orig_dump_entry(msg, portid, seq, bat_priv,
++					     if_outgoing, orig_node, sub)) {
++			rcu_read_unlock();
++			*idx_s = idx - 1;
++			return -EMSGSIZE;
++		}
++	}
++	rcu_read_unlock();
++
++	*idx_s = 0;
++	*sub = 0;
++	return 0;
++}
++
++/**
++ * batadv_v_orig_dump - Dump the originators into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ * @if_outgoing: Limit dump to entries with this outgoing interface
++ */
++static void
++batadv_v_orig_dump(struct sk_buff *msg, struct netlink_callback *cb,
++		   struct batadv_priv *bat_priv,
++		   struct batadv_hard_iface *if_outgoing)
++{
++	struct batadv_hashtable *hash = bat_priv->orig_hash;
++	struct hlist_head *head;
++	int bucket = cb->args[0];
++	int idx = cb->args[1];
++	int sub = cb->args[2];
++	int portid = NETLINK_CB(cb->skb).portid;
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_v_orig_dump_bucket(msg, portid,
++					      cb->nlh->nlmsg_seq,
++					      bat_priv, if_outgoing, head, &idx,
++					      &sub))
++			break;
++
++		bucket++;
++	}
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++	cb->args[2] = sub;
++}
++
+ static int batadv_v_neigh_cmp(struct batadv_neigh_node *neigh1,
+ 			      struct batadv_hard_iface *if_outgoing1,
+ 			      struct batadv_neigh_node *neigh2,
+@@ -573,9 +911,11 @@ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 		.cmp = batadv_v_neigh_cmp,
+ 		.is_similar_or_better = batadv_v_neigh_is_sob,
+ 		.print = batadv_v_neigh_print,
++		.dump = batadv_v_neigh_dump,
+ 	},
+ 	.orig = {
+ 		.print = batadv_v_orig_print,
++		.dump = batadv_v_orig_dump,
+ 	},
+ 	.gw = {
+ 		.store_sel_class = batadv_v_store_sel_class,
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 0c7940c..025f2ec 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -86,6 +86,7 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_LAST_SEEN_MSECS]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_NEIGH_ADDRESS]	= { .len = ETH_ALEN },
+ 	[BATADV_ATTR_TQ]		= { .type = NLA_U8 },
++	[BATADV_ATTR_THROUGHPUT]	= { .type = NLA_U32 },
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0030-batman-adv-netlink-add-gateway-table-queries.patch b/batman-adv/patches/0030-batman-adv-netlink-add-gateway-table-queries.patch
new file mode 100644
index 0000000..ae5a345
--- /dev/null
+++ b/batman-adv/patches/0030-batman-adv-netlink-add-gateway-table-queries.patch
@@ -0,0 +1,232 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 3 Jul 2016 13:31:42 +0200
+Subject: [PATCH] batman-adv: netlink: add gateway table queries
+
+Add BATADV_CMD_GET_GATEWAYS commands, using handlers bat_gw_dump in
+batadv_algo_ops. Will always return -EOPNOTSUPP for now, as no
+implementations exist yet.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h |  8 ++++++
+ net/batman-adv/gateway_client.c | 59 +++++++++++++++++++++++++++++++++++++++++
+ net/batman-adv/gateway_client.h |  2 ++
+ net/batman-adv/netlink.c        | 10 +++++++
+ net/batman-adv/types.h          |  3 +++
+ 5 files changed, 82 insertions(+)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 2e2747f..a13fc09 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -88,6 +88,9 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_NEIGH_ADDRESS: Neighbour MAC address
+  * @BATADV_ATTR_TQ: TQ to neighbour
+  * @BATADV_ATTR_THROUGHPUT: Estimated throughput to Neighbour
++ * @BATADV_ATTR_BANDWIDTH_UP: Reported uplink bandwidth
++ * @BATADV_ATTR_BANDWIDTH_DOWN: Reported downlink bandwidth
++ * @BATADV_ATTR_ROUTER: Gateway router MAC address
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -120,6 +123,9 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_NEIGH_ADDRESS,
+ 	BATADV_ATTR_TQ,
+ 	BATADV_ATTR_THROUGHPUT,
++	BATADV_ATTR_BANDWIDTH_UP,
++	BATADV_ATTR_BANDWIDTH_DOWN,
++	BATADV_ATTR_ROUTER,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -139,6 +145,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_TRANSTABLE_GLOBAL Query list of global translations
+  * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
++ * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -153,6 +160,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_TRANSTABLE_GLOBAL,
+ 	BATADV_CMD_GET_ORIGINATORS,
+ 	BATADV_CMD_GET_NEIGHBORS,
++	BATADV_CMD_GET_GATEWAYS,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index a77a179..c2928c2 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -20,6 +20,7 @@
+ 
+ #include <linux/atomic.h>
+ #include <linux/byteorder/generic.h>
++#include <linux/errno.h>
+ #include <linux/etherdevice.h>
+ #include <linux/fs.h>
+ #include <linux/if_ether.h>
+@@ -31,6 +32,7 @@
+ #include <linux/kref.h>
+ #include <linux/list.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+ #include <linux/seq_file.h>
+@@ -39,13 +41,17 @@
+ #include <linux/spinlock.h>
+ #include <linux/stddef.h>
+ #include <linux/udp.h>
++#include <net/sock.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "gateway_common.h"
+ #include "hard-interface.h"
+ #include "log.h"
++#include "netlink.h"
+ #include "originator.h"
+ #include "packet.h"
+ #include "routing.h"
++#include "soft-interface.h"
+ #include "sysfs.h"
+ #include "translation-table.h"
+ 
+@@ -501,6 +507,59 @@ int batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset)
+ }
+ 
+ /**
++ * batadv_gw_dump - Dump gateways into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ *
++ * Return: Error code, or length of message
++ */
++int batadv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct batadv_hard_iface *primary_if = NULL;
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_priv *bat_priv;
++	int ifindex;
++	int ret;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh,
++					     BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	if (!bat_priv->algo_ops->gw.dump) {
++		ret = -EOPNOTSUPP;
++		goto out;
++	}
++
++	bat_priv->algo_ops->gw.dump(msg, cb, bat_priv);
++
++	ret = msg->len;
++
++out:
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	return ret;
++}
++
++/**
+  * batadv_gw_dhcp_recipient_get - check if a packet is a DHCP message
+  * @skb: the packet to check
+  * @header_len: a pointer to the batman-adv header size
+diff --git a/net/batman-adv/gateway_client.h b/net/batman-adv/gateway_client.h
+index 6b40432..859166d 100644
+--- a/net/batman-adv/gateway_client.h
++++ b/net/batman-adv/gateway_client.h
+@@ -23,6 +23,7 @@
+ #include <linux/types.h>
+ 
+ struct batadv_tvlv_gateway_data;
++struct netlink_callback;
+ struct seq_file;
+ struct sk_buff;
+ 
+@@ -43,6 +44,7 @@ void batadv_gw_node_put(struct batadv_gw_node *gw_node);
+ struct batadv_gw_node *
+ batadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv);
+ int batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset);
++int batadv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ bool batadv_gw_out_of_range(struct batadv_priv *bat_priv, struct sk_buff *skb);
+ enum batadv_dhcp_recipient
+ batadv_gw_dhcp_recipient_get(struct sk_buff *skb, unsigned int *header_len,
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 025f2ec..c68ccb0 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -38,6 +38,7 @@
+ #include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
++#include "gateway_client.h"
+ #include "hard-interface.h"
+ #include "originator.h"
+ #include "soft-interface.h"
+@@ -87,6 +88,9 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_NEIGH_ADDRESS]	= { .len = ETH_ALEN },
+ 	[BATADV_ATTR_TQ]		= { .type = NLA_U8 },
+ 	[BATADV_ATTR_THROUGHPUT]	= { .type = NLA_U32 },
++	[BATADV_ATTR_BANDWIDTH_UP]	= { .type = NLA_U32 },
++	[BATADV_ATTR_BANDWIDTH_DOWN]	= { .type = NLA_U32 },
++	[BATADV_ATTR_ROUTER]		= { .len = ETH_ALEN },
+ };
+ 
+ /**
+@@ -570,6 +574,12 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_hardif_neigh_dump,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_GATEWAYS,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_gw_dump,
++	},
+ };
+ 
+ /**
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index 968023a..b5f01a3 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -1469,6 +1469,7 @@ struct batadv_algo_orig_ops {
+  * @is_eligible: check if a newly discovered GW is a potential candidate for
+  *  the election as best GW (optional)
+  * @print: print the gateway table (optional)
++ * @dump: dump gateways to a netlink socket (optional)
+  */
+ struct batadv_algo_gw_ops {
+ 	ssize_t (*store_sel_class)(struct batadv_priv *bat_priv, char *buff,
+@@ -1480,6 +1481,8 @@ struct batadv_algo_gw_ops {
+ 			    struct batadv_orig_node *curr_gw_orig,
+ 			    struct batadv_orig_node *orig_node);
+ 	void (*print)(struct batadv_priv *bat_priv, struct seq_file *seq);
++	void (*dump)(struct sk_buff *msg, struct netlink_callback *cb,
++		     struct batadv_priv *priv);
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0031-batman-adv-add-B.A.T.M.A.N.-IV-bat_gw_dump-implement.patch b/batman-adv/patches/0031-batman-adv-add-B.A.T.M.A.N.-IV-bat_gw_dump-implement.patch
new file mode 100644
index 0000000..6599219
--- /dev/null
+++ b/batman-adv/patches/0031-batman-adv-add-B.A.T.M.A.N.-IV-bat_gw_dump-implement.patch
@@ -0,0 +1,138 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:43 +0200
+Subject: [PATCH] batman-adv: add B.A.T.M.A.N. IV bat_gw_dump implementations
+
+Dump the list of gateways via the netlink socket.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: integrate in batadv_algo_ops]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c | 105 ++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 105 insertions(+)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 7a8c0f6..9ed4f1f 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -2681,6 +2681,110 @@ static void batadv_iv_gw_print(struct batadv_priv *bat_priv,
+ 		seq_puts(seq, "No gateways in range ...\n");
+ }
+ 
++/**
++ * batadv_iv_gw_dump_entry - Dump a gateway into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @gw_node: Gateway to be dumped
++ *
++ * Return: Error code, or 0 on success
++ */
++static int batadv_iv_gw_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++				   struct batadv_priv *bat_priv,
++				   struct batadv_gw_node *gw_node)
++{
++	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
++	struct batadv_neigh_node *router;
++	struct batadv_gw_node *curr_gw;
++	int ret = -EINVAL;
++	void *hdr;
++
++	router = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);
++	if (!router)
++		goto out;
++
++	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
++	if (!router_ifinfo)
++		goto out;
++
++	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_GATEWAYS);
++	if (!hdr) {
++		ret = -ENOBUFS;
++		goto out;
++	}
++
++	ret = -EMSGSIZE;
++
++	if (curr_gw == gw_node)
++		if (nla_put_flag(msg, BATADV_ATTR_FLAG_BEST)) {
++			genlmsg_cancel(msg, hdr);
++			goto out;
++		}
++
++	if (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,
++		    gw_node->orig_node->orig) ||
++	    nla_put_u8(msg, BATADV_ATTR_TQ, router_ifinfo->bat_iv.tq_avg) ||
++	    nla_put(msg, BATADV_ATTR_ROUTER, ETH_ALEN,
++		    router->addr) ||
++	    nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,
++			   router->if_incoming->net_dev->name) ||
++	    nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_DOWN,
++			gw_node->bandwidth_down) ||
++	    nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_UP,
++			gw_node->bandwidth_up)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	genlmsg_end(msg, hdr);
++	ret = 0;
++
++out:
++	if (router_ifinfo)
++		batadv_neigh_ifinfo_put(router_ifinfo);
++	if (router)
++		batadv_neigh_node_put(router);
++	return ret;
++}
++
++/**
++ * batadv_iv_gw_dump - Dump gateways into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ */
++static void batadv_iv_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,
++			      struct batadv_priv *bat_priv)
++{
++	int portid = NETLINK_CB(cb->skb).portid;
++	struct batadv_gw_node *gw_node;
++	int idx_skip = cb->args[0];
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		if (idx++ < idx_skip)
++			continue;
++
++		if (batadv_iv_gw_dump_entry(msg, portid, cb->nlh->nlmsg_seq,
++					    bat_priv, gw_node)) {
++			idx_skip = idx - 1;
++			goto unlock;
++		}
++	}
++
++	idx_skip = idx;
++unlock:
++	rcu_read_unlock();
++
++	cb->args[0] = idx_skip;
++}
++
+ static struct batadv_algo_ops batadv_batman_iv __read_mostly = {
+ 	.name = "BATMAN_IV",
+ 	.iface = {
+@@ -2707,6 +2811,7 @@ static struct batadv_algo_ops batadv_batman_iv __read_mostly = {
+ 		.get_best_gw_node = batadv_iv_gw_get_best_gw_node,
+ 		.is_eligible = batadv_iv_gw_is_eligible,
+ 		.print = batadv_iv_gw_print,
++		.dump = batadv_iv_gw_dump,
+ 	},
+ };
+ 
diff --git a/batman-adv/patches/0032-batman-adv-add-B.A.T.M.A.N.-V-bat_gw_dump-implementa.patch b/batman-adv/patches/0032-batman-adv-add-B.A.T.M.A.N.-V-bat_gw_dump-implementa.patch
new file mode 100644
index 0000000..4fc8908
--- /dev/null
+++ b/batman-adv/patches/0032-batman-adv-add-B.A.T.M.A.N.-V-bat_gw_dump-implementa.patch
@@ -0,0 +1,153 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 3 Jul 2016 13:31:44 +0200
+Subject: [PATCH] batman-adv: add B.A.T.M.A.N. V bat_gw_dump implementations
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_v.c | 125 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 125 insertions(+)
+
+diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
+index 9dccfaf..9e872dc 100644
+--- a/net/batman-adv/bat_v.c
++++ b/net/batman-adv/bat_v.c
+@@ -897,6 +897,130 @@ static void batadv_v_gw_print(struct batadv_priv *bat_priv,
+ 		seq_puts(seq, "No gateways in range ...\n");
+ }
+ 
++/**
++ * batadv_v_gw_dump_entry - Dump a gateway into a message
++ * @msg: Netlink message to dump into
++ * @portid: Port making netlink request
++ * @seq: Sequence number of netlink message
++ * @bat_priv: The bat priv with all the soft interface information
++ * @gw_node: Gateway to be dumped
++ *
++ * Return: Error code, or 0 on success
++ */
++static int batadv_v_gw_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++				  struct batadv_priv *bat_priv,
++				  struct batadv_gw_node *gw_node)
++{
++	struct batadv_neigh_ifinfo *router_ifinfo = NULL;
++	struct batadv_neigh_node *router;
++	struct batadv_gw_node *curr_gw;
++	int ret = -EINVAL;
++	void *hdr;
++
++	router = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);
++	if (!router)
++		goto out;
++
++	router_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);
++	if (!router_ifinfo)
++		goto out;
++
++	curr_gw = batadv_gw_get_selected_gw_node(bat_priv);
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_GATEWAYS);
++	if (!hdr) {
++		ret = -ENOBUFS;
++		goto out;
++	}
++
++	ret = -EMSGSIZE;
++
++	if (curr_gw == gw_node) {
++		if (nla_put_flag(msg, BATADV_ATTR_FLAG_BEST)) {
++			genlmsg_cancel(msg, hdr);
++			goto out;
++		}
++	}
++
++	if (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,
++		    gw_node->orig_node->orig)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	if (nla_put_u32(msg, BATADV_ATTR_THROUGHPUT,
++			router_ifinfo->bat_v.throughput)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	if (nla_put(msg, BATADV_ATTR_ROUTER, ETH_ALEN, router->addr)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	if (nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,
++			   router->if_incoming->net_dev->name)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	if (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_DOWN,
++			gw_node->bandwidth_down)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	if (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_UP, gw_node->bandwidth_up)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	genlmsg_end(msg, hdr);
++	ret = 0;
++
++out:
++	if (router_ifinfo)
++		batadv_neigh_ifinfo_put(router_ifinfo);
++	if (router)
++		batadv_neigh_node_put(router);
++	return ret;
++}
++
++/**
++ * batadv_v_gw_dump - Dump gateways into a message
++ * @msg: Netlink message to dump into
++ * @cb: Control block containing additional options
++ * @bat_priv: The bat priv with all the soft interface information
++ */
++static void batadv_v_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,
++			     struct batadv_priv *bat_priv)
++{
++	int portid = NETLINK_CB(cb->skb).portid;
++	struct batadv_gw_node *gw_node;
++	int idx_skip = cb->args[0];
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {
++		if (idx++ < idx_skip)
++			continue;
++
++		if (batadv_v_gw_dump_entry(msg, portid, cb->nlh->nlmsg_seq,
++					   bat_priv, gw_node)) {
++			idx_skip = idx - 1;
++			goto unlock;
++		}
++	}
++
++	idx_skip = idx;
++unlock:
++	rcu_read_unlock();
++
++	cb->args[0] = idx_skip;
++}
++
+ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 	.name = "BATMAN_V",
+ 	.iface = {
+@@ -923,6 +1047,7 @@ static struct batadv_algo_ops batadv_batman_v __read_mostly = {
+ 		.get_best_gw_node = batadv_v_gw_get_best_gw_node,
+ 		.is_eligible = batadv_v_gw_is_eligible,
+ 		.print = batadv_v_gw_print,
++		.dump = batadv_v_gw_dump,
+ 	},
+ };
+ 
diff --git a/batman-adv/patches/0033-batman-adv-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netl.patch b/batman-adv/patches/0033-batman-adv-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netl.patch
new file mode 100644
index 0000000..fc7e70e
--- /dev/null
+++ b/batman-adv/patches/0033-batman-adv-add-B.A.T.M.A.N.-Dump-BLA-claims-via-netl.patch
@@ -0,0 +1,343 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:45 +0200
+Subject: [PATCH] batman-adv: add B.A.T.M.A.N. Dump BLA claims via netlink
+
+Dump the list of bridge loop avoidance claims via the netlink socket.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[sven.eckelmann@open-mesh.com: add policy for attributes, fix includes, fix
+soft_iface reference leak]
+Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
+[sw@simonwunderlich.de: fix kerneldoc, fix error reporting]
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h        |  12 +++
+ net/batman-adv/bridge_loop_avoidance.c | 169 +++++++++++++++++++++++++++++++++
+ net/batman-adv/bridge_loop_avoidance.h |  10 +-
+ net/batman-adv/netlink.c               |  12 +++
+ 4 files changed, 202 insertions(+), 1 deletion(-)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index a13fc09..96b37ab 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -91,6 +91,11 @@ enum batadv_tt_client_flags {
+  * @BATADV_ATTR_BANDWIDTH_UP: Reported uplink bandwidth
+  * @BATADV_ATTR_BANDWIDTH_DOWN: Reported downlink bandwidth
+  * @BATADV_ATTR_ROUTER: Gateway router MAC address
++ * @BATADV_ATTR_BLA_OWN: Flag indicating own originator
++ * @BATADV_ATTR_BLA_ADDRESS: Bridge loop avoidance claim MAC address
++ * @BATADV_ATTR_BLA_VID: BLA VLAN ID
++ * @BATADV_ATTR_BLA_BACKBONE: BLA gateway originator MAC address
++ * @BATADV_ATTR_BLA_CRC: BLA CRC
+  * @__BATADV_ATTR_AFTER_LAST: internal use
+  * @NUM_BATADV_ATTR: total number of batadv_nl_attrs available
+  * @BATADV_ATTR_MAX: highest attribute number currently defined
+@@ -126,6 +131,11 @@ enum batadv_nl_attrs {
+ 	BATADV_ATTR_BANDWIDTH_UP,
+ 	BATADV_ATTR_BANDWIDTH_DOWN,
+ 	BATADV_ATTR_ROUTER,
++	BATADV_ATTR_BLA_OWN,
++	BATADV_ATTR_BLA_ADDRESS,
++	BATADV_ATTR_BLA_VID,
++	BATADV_ATTR_BLA_BACKBONE,
++	BATADV_ATTR_BLA_CRC,
+ 	/* add attributes above here, update the policy in netlink.c */
+ 	__BATADV_ATTR_AFTER_LAST,
+ 	NUM_BATADV_ATTR = __BATADV_ATTR_AFTER_LAST,
+@@ -146,6 +156,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_ORIGINATORS: Query list of originators
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
++ * @BATADV_CMD_GET_BLA_CLAIM: Query list of bridge loop avoidance claims
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -161,6 +172,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_ORIGINATORS,
+ 	BATADV_CMD_GET_NEIGHBORS,
+ 	BATADV_CMD_GET_GATEWAYS,
++	BATADV_CMD_GET_BLA_CLAIM,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
+index c75ef64..aafa88f 100644
+--- a/net/batman-adv/bridge_loop_avoidance.c
++++ b/net/batman-adv/bridge_loop_avoidance.c
+@@ -35,6 +35,7 @@
+ #include <linux/list.h>
+ #include <linux/lockdep.h>
+ #include <linux/netdevice.h>
++#include <linux/netlink.h>
+ #include <linux/rculist.h>
+ #include <linux/rcupdate.h>
+ #include <linux/seq_file.h>
+@@ -45,12 +46,18 @@
+ #include <linux/string.h>
+ #include <linux/workqueue.h>
+ #include <net/arp.h>
++#include <net/genetlink.h>
++#include <net/netlink.h>
++#include <net/sock.h>
++#include <uapi/linux/batman_adv.h>
+ 
+ #include "hard-interface.h"
+ #include "hash.h"
+ #include "log.h"
++#include "netlink.h"
+ #include "originator.h"
+ #include "packet.h"
++#include "soft-interface.h"
+ #include "sysfs.h"
+ #include "translation-table.h"
+ 
+@@ -2052,6 +2059,168 @@ out:
+ }
+ 
+ /**
++ * batadv_bla_claim_dump_entry - dump one entry of the claim table
++ * to a netlink socket
++ * @msg: buffer for the message
++ * @portid: netlink port
++ * @seq: Sequence number of netlink message
++ * @primary_if: primary interface
++ * @claim: entry to dump
++ *
++ * Return: 0 or error code.
++ */
++static int
++batadv_bla_claim_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			    struct batadv_hard_iface *primary_if,
++			    struct batadv_bla_claim *claim)
++{
++	u8 *primary_addr = primary_if->net_dev->dev_addr;
++	u16 backbone_crc;
++	bool is_own;
++	void *hdr;
++	int ret = -EINVAL;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_BLA_CLAIM);
++	if (!hdr) {
++		ret = -ENOBUFS;
++		goto out;
++	}
++
++	is_own = batadv_compare_eth(claim->backbone_gw->orig,
++				    primary_addr);
++
++	spin_lock_bh(&claim->backbone_gw->crc_lock);
++	backbone_crc = claim->backbone_gw->crc;
++	spin_unlock_bh(&claim->backbone_gw->crc_lock);
++
++	if (is_own)
++		if (nla_put_flag(msg, BATADV_ATTR_BLA_OWN)) {
++			genlmsg_cancel(msg, hdr);
++			goto out;
++		}
++
++	if (nla_put(msg, BATADV_ATTR_BLA_ADDRESS, ETH_ALEN, claim->addr) ||
++	    nla_put_u16(msg, BATADV_ATTR_BLA_VID, claim->vid) ||
++	    nla_put(msg, BATADV_ATTR_BLA_BACKBONE, ETH_ALEN,
++		    claim->backbone_gw->orig) ||
++	    nla_put_u16(msg, BATADV_ATTR_BLA_CRC,
++			backbone_crc)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	genlmsg_end(msg, hdr);
++	ret = 0;
++
++out:
++	return ret;
++}
++
++/**
++ * batadv_bla_claim_dump_bucket - dump one bucket of the claim table
++ * to a netlink socket
++ * @msg: buffer for the message
++ * @portid: netlink port
++ * @seq: Sequence number of netlink message
++ * @primary_if: primary interface
++ * @head: bucket to dump
++ * @idx_skip: How many entries to skip
++ *
++ * Return: always 0.
++ */
++static int
++batadv_bla_claim_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++			     struct batadv_hard_iface *primary_if,
++			     struct hlist_head *head, int *idx_skip)
++{
++	struct batadv_bla_claim *claim;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(claim, head, hash_entry) {
++		if (idx++ < *idx_skip)
++			continue;
++		if (batadv_bla_claim_dump_entry(msg, portid, seq,
++						primary_if, claim)) {
++			*idx_skip = idx - 1;
++			goto unlock;
++		}
++	}
++
++	*idx_skip = idx;
++unlock:
++	rcu_read_unlock();
++	return 0;
++}
++
++/**
++ * batadv_bla_claim_dump - dump claim table to a netlink socket
++ * @msg: buffer for the message
++ * @cb: callback structure containing arguments
++ *
++ * Return: message length.
++ */
++int batadv_bla_claim_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct batadv_hard_iface *primary_if = NULL;
++	int portid = NETLINK_CB(cb->skb).portid;
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_hashtable *hash;
++	struct batadv_priv *bat_priv;
++	int bucket = cb->args[0];
++	struct hlist_head *head;
++	int idx = cb->args[1];
++	int ifindex;
++	int ret = 0;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh,
++					     BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++	hash = bat_priv->bla.claim_hash;
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_bla_claim_dump_bucket(msg, portid,
++						 cb->nlh->nlmsg_seq,
++						 primary_if, head, &idx))
++			break;
++		bucket++;
++	}
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++
++	ret = msg->len;
++
++out:
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	return ret;
++}
++
++/**
+  * batadv_bla_backbone_table_seq_print_text - print the backbone table in a seq
+  *  file
+  * @seq: seq file to print on
+diff --git a/net/batman-adv/bridge_loop_avoidance.h b/net/batman-adv/bridge_loop_avoidance.h
+index 0f01dae..a80b9e9 100644
+--- a/net/batman-adv/bridge_loop_avoidance.h
++++ b/net/batman-adv/bridge_loop_avoidance.h
+@@ -23,6 +23,7 @@
+ #include <linux/types.h>
+ 
+ struct net_device;
++struct netlink_callback;
+ struct seq_file;
+ struct sk_buff;
+ 
+@@ -35,6 +36,7 @@ bool batadv_bla_is_backbone_gw(struct sk_buff *skb,
+ 			       struct batadv_orig_node *orig_node,
+ 			       int hdr_size);
+ int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset);
++int batadv_bla_claim_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ int batadv_bla_backbone_table_seq_print_text(struct seq_file *seq,
+ 					     void *offset);
+ bool batadv_bla_is_backbone_gw_orig(struct batadv_priv *bat_priv, u8 *orig,
+@@ -47,7 +49,7 @@ void batadv_bla_update_orig_address(struct batadv_priv *bat_priv,
+ void batadv_bla_status_update(struct net_device *net_dev);
+ int batadv_bla_init(struct batadv_priv *bat_priv);
+ void batadv_bla_free(struct batadv_priv *bat_priv);
+-
++int batadv_bla_claim_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ #define BATADV_BLA_CRC_INIT	0
+ #else /* ifdef CONFIG_BATMAN_ADV_BLA */
+ 
+@@ -112,6 +114,12 @@ static inline void batadv_bla_free(struct batadv_priv *bat_priv)
+ {
+ }
+ 
++static inline int batadv_bla_claim_dump(struct sk_buff *msg,
++					struct netlink_callback *cb)
++{
++	return -EOPNOTSUPP;
++}
++
+ #endif /* ifdef CONFIG_BATMAN_ADV_BLA */
+ 
+ #endif /* ifndef _NET_BATMAN_ADV_BLA_H_ */
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index c68ccb0..b33675c 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -38,6 +38,7 @@
+ #include <uapi/linux/batman_adv.h>
+ 
+ #include "bat_algo.h"
++#include "bridge_loop_avoidance.h"
+ #include "gateway_client.h"
+ #include "hard-interface.h"
+ #include "originator.h"
+@@ -91,6 +92,11 @@ static struct nla_policy batadv_netlink_policy[NUM_BATADV_ATTR] = {
+ 	[BATADV_ATTR_BANDWIDTH_UP]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_BANDWIDTH_DOWN]	= { .type = NLA_U32 },
+ 	[BATADV_ATTR_ROUTER]		= { .len = ETH_ALEN },
++	[BATADV_ATTR_BLA_OWN]		= { .type = NLA_FLAG },
++	[BATADV_ATTR_BLA_ADDRESS]	= { .len = ETH_ALEN },
++	[BATADV_ATTR_BLA_VID]		= { .type = NLA_U16 },
++	[BATADV_ATTR_BLA_BACKBONE]	= { .len = ETH_ALEN },
++	[BATADV_ATTR_BLA_CRC]		= { .type = NLA_U16 },
+ };
+ 
+ /**
+@@ -580,6 +586,12 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_gw_dump,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_BLA_CLAIM,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_bla_claim_dump,
++	},
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0034-batman-adv-Provide-bla-group-in-the-mesh_info-netlin.patch b/batman-adv/patches/0034-batman-adv-Provide-bla-group-in-the-mesh_info-netlin.patch
new file mode 100644
index 0000000..e8074d4
--- /dev/null
+++ b/batman-adv/patches/0034-batman-adv-Provide-bla-group-in-the-mesh_info-netlin.patch
@@ -0,0 +1,48 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 3 Jul 2016 13:31:46 +0200
+Subject: [PATCH] batman-adv: Provide bla group in the mesh_info netlink msg
+
+The bridge loop avoidange is the main information for the debugging of of
+bridge loop detection problems. It is therefore necessary when comparing
+the bla claim tables.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/netlink.c | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index b33675c..464de9d 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -19,6 +19,7 @@
+ #include "main.h"
+ 
+ #include <linux/atomic.h>
++#include <linux/byteorder/generic.h>
+ #include <linux/errno.h>
+ #include <linux/fs.h>
+ #include <linux/genetlink.h>
+@@ -42,6 +43,7 @@
+ #include "gateway_client.h"
+ #include "hard-interface.h"
+ #include "originator.h"
++#include "packet.h"
+ #include "soft-interface.h"
+ #include "tp_meter.h"
+ #include "translation-table.h"
+@@ -141,6 +143,12 @@ batadv_netlink_mesh_info_put(struct sk_buff *msg, struct net_device *soft_iface)
+ 		       (u8)atomic_read(&bat_priv->tt.vn)))
+ 		goto out;
+ 
++#ifdef CONFIG_BATMAN_ADV_BLA
++	if (nla_put_u16(msg, BATADV_ATTR_BLA_CRC,
++			ntohs(bat_priv->bla.claim_dest.group)))
++		goto out;
++#endif
++
+ 	primary_if = batadv_primary_if_get_selected(bat_priv);
+ 	if (primary_if && primary_if->if_status == BATADV_IF_ACTIVE) {
+ 		hard_iface = primary_if->net_dev;
diff --git a/batman-adv/patches/0035-batman-adv-add-backbone-table-netlink-support.patch b/batman-adv/patches/0035-batman-adv-add-backbone-table-netlink-support.patch
new file mode 100644
index 0000000..c110d07
--- /dev/null
+++ b/batman-adv/patches/0035-batman-adv-add-backbone-table-netlink-support.patch
@@ -0,0 +1,251 @@
+From: Simon Wunderlich <sw@simonwunderlich.de>
+Date: Sun, 3 Jul 2016 13:31:47 +0200
+Subject: [PATCH] batman-adv: add backbone table netlink support
+
+Dump the list of bridge loop avoidance backbones via the netlink socket.
+
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ include/uapi/linux/batman_adv.h        |   2 +
+ net/batman-adv/bridge_loop_avoidance.c | 164 +++++++++++++++++++++++++++++++++
+ net/batman-adv/bridge_loop_avoidance.h |   7 ++
+ net/batman-adv/netlink.c               |   7 ++
+ 4 files changed, 180 insertions(+)
+
+diff --git a/include/uapi/linux/batman_adv.h b/include/uapi/linux/batman_adv.h
+index 96b37ab..734fe83 100644
+--- a/include/uapi/linux/batman_adv.h
++++ b/include/uapi/linux/batman_adv.h
+@@ -157,6 +157,7 @@ enum batadv_nl_attrs {
+  * @BATADV_CMD_GET_NEIGHBORS: Query list of neighbours
+  * @BATADV_CMD_GET_GATEWAYS: Query list of gateways
+  * @BATADV_CMD_GET_BLA_CLAIM: Query list of bridge loop avoidance claims
++ * @BATADV_CMD_GET_BLA_BACKBONE: Query list of bridge loop avoidance backbones
+  * @__BATADV_CMD_AFTER_LAST: internal use
+  * @BATADV_CMD_MAX: highest used command number
+  */
+@@ -173,6 +174,7 @@ enum batadv_nl_commands {
+ 	BATADV_CMD_GET_NEIGHBORS,
+ 	BATADV_CMD_GET_GATEWAYS,
+ 	BATADV_CMD_GET_BLA_CLAIM,
++	BATADV_CMD_GET_BLA_BACKBONE,
+ 	/* add new commands above here */
+ 	__BATADV_CMD_AFTER_LAST,
+ 	BATADV_CMD_MAX = __BATADV_CMD_AFTER_LAST - 1
+diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
+index aafa88f..35ed1d3 100644
+--- a/net/batman-adv/bridge_loop_avoidance.c
++++ b/net/batman-adv/bridge_loop_avoidance.c
+@@ -2283,3 +2283,167 @@ out:
+ 		batadv_hardif_put(primary_if);
+ 	return 0;
+ }
++
++/**
++ * batadv_bla_backbone_dump_entry - dump one entry of the backbone table
++ * to a netlink socket
++ * @msg: buffer for the message
++ * @portid: netlink port
++ * @seq: Sequence number of netlink message
++ * @primary_if: primary interface
++ * @backbone_gw: entry to dump
++ *
++ * Return: 0 or error code.
++ */
++static int
++batadv_bla_backbone_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,
++			       struct batadv_hard_iface *primary_if,
++			       struct batadv_bla_backbone_gw *backbone_gw)
++{
++	u8 *primary_addr = primary_if->net_dev->dev_addr;
++	u16 backbone_crc;
++	bool is_own;
++	int msecs;
++	void *hdr;
++	int ret = -EINVAL;
++
++	hdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,
++			  NLM_F_MULTI, BATADV_CMD_GET_BLA_BACKBONE);
++	if (!hdr) {
++		ret = -ENOBUFS;
++		goto out;
++	}
++
++	is_own = batadv_compare_eth(backbone_gw->orig, primary_addr);
++
++	spin_lock_bh(&backbone_gw->crc_lock);
++	backbone_crc = backbone_gw->crc;
++	spin_unlock_bh(&backbone_gw->crc_lock);
++
++	msecs = jiffies_to_msecs(jiffies - backbone_gw->lasttime);
++
++	if (is_own)
++		if (nla_put_flag(msg, BATADV_ATTR_BLA_OWN)) {
++			genlmsg_cancel(msg, hdr);
++			goto out;
++		}
++
++	if (nla_put(msg, BATADV_ATTR_BLA_BACKBONE, ETH_ALEN,
++		    backbone_gw->orig) ||
++	    nla_put_u16(msg, BATADV_ATTR_BLA_VID, backbone_gw->vid) ||
++	    nla_put_u16(msg, BATADV_ATTR_BLA_CRC,
++			backbone_crc) ||
++	    nla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS, msecs)) {
++		genlmsg_cancel(msg, hdr);
++		goto out;
++	}
++
++	genlmsg_end(msg, hdr);
++	ret = 0;
++
++out:
++	return ret;
++}
++
++/**
++ * batadv_bla_backbone_dump_bucket - dump one bucket of the backbone table
++ * to a netlink socket
++ * @msg: buffer for the message
++ * @portid: netlink port
++ * @seq: Sequence number of netlink message
++ * @primary_if: primary interface
++ * @head: bucket to dump
++ * @idx_skip: How many entries to skip
++ *
++ * Return: always 0.
++ */
++static int
++batadv_bla_backbone_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,
++				struct batadv_hard_iface *primary_if,
++				struct hlist_head *head, int *idx_skip)
++{
++	struct batadv_bla_backbone_gw *backbone_gw;
++	int idx = 0;
++
++	rcu_read_lock();
++	hlist_for_each_entry_rcu(backbone_gw, head, hash_entry) {
++		if (idx++ < *idx_skip)
++			continue;
++		if (batadv_bla_backbone_dump_entry(msg, portid, seq,
++						   primary_if, backbone_gw)) {
++			*idx_skip = idx - 1;
++			goto unlock;
++		}
++	}
++
++	*idx_skip = idx;
++unlock:
++	rcu_read_unlock();
++	return 0;
++}
++
++/**
++ * batadv_bla_backbone_dump - dump backbone table to a netlink socket
++ * @msg: buffer for the message
++ * @cb: callback structure containing arguments
++ *
++ * Return: message length.
++ */
++int batadv_bla_backbone_dump(struct sk_buff *msg, struct netlink_callback *cb)
++{
++	struct batadv_hard_iface *primary_if = NULL;
++	int portid = NETLINK_CB(cb->skb).portid;
++	struct net *net = sock_net(cb->skb->sk);
++	struct net_device *soft_iface;
++	struct batadv_hashtable *hash;
++	struct batadv_priv *bat_priv;
++	int bucket = cb->args[0];
++	struct hlist_head *head;
++	int idx = cb->args[1];
++	int ifindex;
++	int ret = 0;
++
++	ifindex = batadv_netlink_get_ifindex(cb->nlh,
++					     BATADV_ATTR_MESH_IFINDEX);
++	if (!ifindex)
++		return -EINVAL;
++
++	soft_iface = dev_get_by_index(net, ifindex);
++	if (!soft_iface || !batadv_softif_is_valid(soft_iface)) {
++		ret = -ENODEV;
++		goto out;
++	}
++
++	bat_priv = netdev_priv(soft_iface);
++	hash = bat_priv->bla.backbone_hash;
++
++	primary_if = batadv_primary_if_get_selected(bat_priv);
++	if (!primary_if || primary_if->if_status != BATADV_IF_ACTIVE) {
++		ret = -ENOENT;
++		goto out;
++	}
++
++	while (bucket < hash->size) {
++		head = &hash->table[bucket];
++
++		if (batadv_bla_backbone_dump_bucket(msg, portid,
++						    cb->nlh->nlmsg_seq,
++						    primary_if, head, &idx))
++			break;
++		bucket++;
++	}
++
++	cb->args[0] = bucket;
++	cb->args[1] = idx;
++
++	ret = msg->len;
++
++out:
++	if (primary_if)
++		batadv_hardif_put(primary_if);
++
++	if (soft_iface)
++		dev_put(soft_iface);
++
++	return ret;
++}
+diff --git a/net/batman-adv/bridge_loop_avoidance.h b/net/batman-adv/bridge_loop_avoidance.h
+index a80b9e9..1ae93e4 100644
+--- a/net/batman-adv/bridge_loop_avoidance.h
++++ b/net/batman-adv/bridge_loop_avoidance.h
+@@ -39,6 +39,7 @@ int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset);
+ int batadv_bla_claim_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ int batadv_bla_backbone_table_seq_print_text(struct seq_file *seq,
+ 					     void *offset);
++int batadv_bla_backbone_dump(struct sk_buff *msg, struct netlink_callback *cb);
+ bool batadv_bla_is_backbone_gw_orig(struct batadv_priv *bat_priv, u8 *orig,
+ 				    unsigned short vid);
+ bool batadv_bla_check_bcast_duplist(struct batadv_priv *bat_priv,
+@@ -120,6 +121,12 @@ static inline int batadv_bla_claim_dump(struct sk_buff *msg,
+ 	return -EOPNOTSUPP;
+ }
+ 
++static inline int batadv_bla_backbone_dump(struct sk_buff *msg,
++					   struct netlink_callback *cb)
++{
++	return -EOPNOTSUPP;
++}
++
+ #endif /* ifdef CONFIG_BATMAN_ADV_BLA */
+ 
+ #endif /* ifndef _NET_BATMAN_ADV_BLA_H_ */
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index 464de9d..c3f6816 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -600,6 +600,13 @@ static struct genl_ops batadv_netlink_ops[] = {
+ 		.policy = batadv_netlink_policy,
+ 		.dumpit = batadv_bla_claim_dump,
+ 	},
++	{
++		.cmd = BATADV_CMD_GET_BLA_BACKBONE,
++		.flags = GENL_ADMIN_PERM,
++		.policy = batadv_netlink_policy,
++		.dumpit = batadv_bla_backbone_dump,
++	},
++
+ };
+ 
+ /**
diff --git a/batman-adv/patches/0036-batman-adv-Indicate-netlink-socket-can-be-used-with-.patch b/batman-adv/patches/0036-batman-adv-Indicate-netlink-socket-can-be-used-with-.patch
new file mode 100644
index 0000000..7e56957
--- /dev/null
+++ b/batman-adv/patches/0036-batman-adv-Indicate-netlink-socket-can-be-used-with-.patch
@@ -0,0 +1,27 @@
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 3 Jul 2016 13:31:48 +0200
+Subject: [PATCH] batman-adv: Indicate netlink socket can be used with netns.
+
+Set the netnsof flag on the family structure, indicating it can
+be used with different network name spaces.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/netlink.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/net/batman-adv/netlink.c b/net/batman-adv/netlink.c
+index c3f6816..18831e7 100644
+--- a/net/batman-adv/netlink.c
++++ b/net/batman-adv/netlink.c
+@@ -54,6 +54,7 @@ struct genl_family batadv_netlink_family = {
+ 	.name = BATADV_NL_NAME,
+ 	.version = 1,
+ 	.maxattr = BATADV_ATTR_MAX,
++	.netnsok = true,
+ };
+ 
+ /* multicast groups */
diff --git a/batman-adv/patches/0037-batman-adv-Place-kref_get-for-orig_node_vlan-near-us.patch b/batman-adv/patches/0037-batman-adv-Place-kref_get-for-orig_node_vlan-near-us.patch
new file mode 100644
index 0000000..22d8434
--- /dev/null
+++ b/batman-adv/patches/0037-batman-adv-Place-kref_get-for-orig_node_vlan-near-us.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:16 +0200
+Subject: [PATCH] batman-adv: Place kref_get for orig_node_vlan near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/originator.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 95c8555..5108af1 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -133,9 +133,9 @@ batadv_orig_node_vlan_new(struct batadv_orig_node *orig_node,
+ 		goto out;
+ 
+ 	kref_init(&vlan->refcount);
+-	kref_get(&vlan->refcount);
+ 	vlan->vid = vid;
+ 
++	kref_get(&vlan->refcount);
+ 	hlist_add_head_rcu(&vlan->list, &orig_node->vlan_list);
+ 
+ out:
diff --git a/batman-adv/patches/0038-batman-adv-Place-kref_get-for-orig_ifinfo-near-use.patch b/batman-adv/patches/0038-batman-adv-Place-kref_get-for-orig_ifinfo-near-use.patch
new file mode 100644
index 0000000..30db41c
--- /dev/null
+++ b/batman-adv/patches/0038-batman-adv-Place-kref_get-for-orig_ifinfo-near-use.patch
@@ -0,0 +1,27 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:17 +0200
+Subject: [PATCH] batman-adv: Place kref_get for orig_ifinfo near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/originator.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 5108af1..8828964 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -386,6 +386,7 @@ batadv_orig_ifinfo_new(struct batadv_orig_node *orig_node,
+ 	orig_ifinfo->if_outgoing = if_outgoing;
+ 	INIT_HLIST_NODE(&orig_ifinfo->list);
+ 	kref_init(&orig_ifinfo->refcount);
++
+ 	kref_get(&orig_ifinfo->refcount);
+ 	hlist_add_head_rcu(&orig_ifinfo->list,
+ 			   &orig_node->ifinfo_list);
diff --git a/batman-adv/patches/0039-batman-adv-Place-kref_get-for-tt_orig_list_entry-nea.patch b/batman-adv/patches/0039-batman-adv-Place-kref_get-for-tt_orig_list_entry-nea.patch
new file mode 100644
index 0000000..afa25ed
--- /dev/null
+++ b/batman-adv/patches/0039-batman-adv-Place-kref_get-for-tt_orig_list_entry-nea.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:18 +0200
+Subject: [PATCH] batman-adv: Place kref_get for tt_orig_list_entry near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/translation-table.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 2080407..5cc500f 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -1567,9 +1567,9 @@ batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,
+ 	orig_entry->orig_node = orig_node;
+ 	orig_entry->ttvn = ttvn;
+ 	kref_init(&orig_entry->refcount);
+-	kref_get(&orig_entry->refcount);
+ 
+ 	spin_lock_bh(&tt_global->list_lock);
++	kref_get(&orig_entry->refcount);
+ 	hlist_add_head_rcu(&orig_entry->list,
+ 			   &tt_global->orig_list);
+ 	spin_unlock_bh(&tt_global->list_lock);
diff --git a/batman-adv/patches/0040-batman-adv-Place-kref_get-for-neigh_ifinfo-near-use.patch b/batman-adv/patches/0040-batman-adv-Place-kref_get-for-neigh_ifinfo-near-use.patch
new file mode 100644
index 0000000..49a8761
--- /dev/null
+++ b/batman-adv/patches/0040-batman-adv-Place-kref_get-for-neigh_ifinfo-near-use.patch
@@ -0,0 +1,30 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:19 +0200
+Subject: [PATCH] batman-adv: Place kref_get for neigh_ifinfo near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/originator.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 8828964..5e99a6e 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -460,9 +460,9 @@ batadv_neigh_ifinfo_new(struct batadv_neigh_node *neigh,
+ 
+ 	INIT_HLIST_NODE(&neigh_ifinfo->list);
+ 	kref_init(&neigh_ifinfo->refcount);
+-	kref_get(&neigh_ifinfo->refcount);
+ 	neigh_ifinfo->if_outgoing = if_outgoing;
+ 
++	kref_get(&neigh_ifinfo->refcount);
+ 	hlist_add_head_rcu(&neigh_ifinfo->list, &neigh->ifinfo_list);
+ 
+ out:
diff --git a/batman-adv/patches/0041-batman-adv-Place-kref_get-for-neigh_node-near-use.patch b/batman-adv/patches/0041-batman-adv-Place-kref_get-for-neigh_node-near-use.patch
new file mode 100644
index 0000000..f4c3f13
--- /dev/null
+++ b/batman-adv/patches/0041-batman-adv-Place-kref_get-for-neigh_node-near-use.patch
@@ -0,0 +1,29 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:20 +0200
+Subject: [PATCH] batman-adv: Place kref_get for neigh_node near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/originator.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 5e99a6e..0792de8 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -654,8 +654,8 @@ batadv_neigh_node_create(struct batadv_orig_node *orig_node,
+ 
+ 	/* extra reference for return */
+ 	kref_init(&neigh_node->refcount);
+-	kref_get(&neigh_node->refcount);
+ 
++	kref_get(&neigh_node->refcount);
+ 	hlist_add_head_rcu(&neigh_node->list, &orig_node->neigh_list);
+ 
+ 	batadv_dbg(BATADV_DBG_BATMAN, orig_node->bat_priv,
diff --git a/batman-adv/patches/0042-batman-adv-Place-kref_get-for-orig_node-near-use.patch b/batman-adv/patches/0042-batman-adv-Place-kref_get-for-orig_node-near-use.patch
new file mode 100644
index 0000000..5560f39
--- /dev/null
+++ b/batman-adv/patches/0042-batman-adv-Place-kref_get-for-orig_node-near-use.patch
@@ -0,0 +1,113 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:21 +0200
+Subject: [PATCH] batman-adv: Place kref_get for orig_node near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bat_iv_ogm.c     | 7 ++++---
+ net/batman-adv/bat_v_ogm.c      | 5 ++---
+ net/batman-adv/gateway_client.c | 2 +-
+ net/batman-adv/network-coding.c | 7 +++----
+ net/batman-adv/originator.c     | 1 -
+ 5 files changed, 10 insertions(+), 12 deletions(-)
+
+diff --git a/net/batman-adv/bat_iv_ogm.c b/net/batman-adv/bat_iv_ogm.c
+index 9ed4f1f..3c7900d 100644
+--- a/net/batman-adv/bat_iv_ogm.c
++++ b/net/batman-adv/bat_iv_ogm.c
+@@ -324,17 +324,18 @@ batadv_iv_ogm_orig_get(struct batadv_priv *bat_priv, const u8 *addr)
+ 	if (!orig_node->bat_iv.bcast_own_sum)
+ 		goto free_orig_node;
+ 
++	kref_get(&orig_node->refcount);
+ 	hash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,
+ 				     batadv_choose_orig, orig_node,
+ 				     &orig_node->hash_entry);
+ 	if (hash_added != 0)
+-		goto free_orig_node;
++		goto free_orig_node_hash;
+ 
+ 	return orig_node;
+ 
+-free_orig_node:
+-	/* free twice, as batadv_orig_node_new sets refcount to 2 */
++free_orig_node_hash:
+ 	batadv_orig_node_put(orig_node);
++free_orig_node:
+ 	batadv_orig_node_put(orig_node);
+ 
+ 	return NULL;
+diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
+index 6fbba4e..1aeeadc 100644
+--- a/net/batman-adv/bat_v_ogm.c
++++ b/net/batman-adv/bat_v_ogm.c
+@@ -73,13 +73,12 @@ struct batadv_orig_node *batadv_v_ogm_orig_get(struct batadv_priv *bat_priv,
+ 	if (!orig_node)
+ 		return NULL;
+ 
++	kref_get(&orig_node->refcount);
+ 	hash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,
+ 				     batadv_choose_orig, orig_node,
+ 				     &orig_node->hash_entry);
+ 	if (hash_added != 0) {
+-		/* orig_node->refcounter is initialised to 2 by
+-		 * batadv_orig_node_new()
+-		 */
++		/* remove refcnt for newly created orig_node and hash entry */
+ 		batadv_orig_node_put(orig_node);
+ 		batadv_orig_node_put(orig_node);
+ 		orig_node = NULL;
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index c2928c2..b889e1f 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -339,8 +339,8 @@ static void batadv_gw_node_add(struct batadv_priv *bat_priv,
+ 	if (!gw_node)
+ 		return;
+ 
+-	kref_get(&orig_node->refcount);
+ 	INIT_HLIST_NODE(&gw_node->list);
++	kref_get(&orig_node->refcount);
+ 	gw_node->orig_node = orig_node;
+ 	gw_node->bandwidth_down = ntohl(gateway->bandwidth_down);
+ 	gw_node->bandwidth_up = ntohl(gateway->bandwidth_up);
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index 293ef4f..3814cfb 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -856,14 +856,13 @@ batadv_nc_get_nc_node(struct batadv_priv *bat_priv,
+ 	if (!nc_node)
+ 		return NULL;
+ 
+-	kref_get(&orig_neigh_node->refcount);
+-
+ 	/* Initialize nc_node */
+ 	INIT_LIST_HEAD(&nc_node->list);
+-	ether_addr_copy(nc_node->addr, orig_node->orig);
+-	nc_node->orig_node = orig_neigh_node;
+ 	kref_init(&nc_node->refcount);
+ 	kref_get(&nc_node->refcount);
++	ether_addr_copy(nc_node->addr, orig_node->orig);
++	kref_get(&orig_neigh_node->refcount);
++	nc_node->orig_node = orig_neigh_node;
+ 
+ 	/* Select ingoing or outgoing coding node */
+ 	if (in_coding) {
+diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
+index 0792de8..0b7d57a 100644
+--- a/net/batman-adv/originator.c
++++ b/net/batman-adv/originator.c
+@@ -989,7 +989,6 @@ struct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,
+ 
+ 	/* extra reference for return */
+ 	kref_init(&orig_node->refcount);
+-	kref_get(&orig_node->refcount);
+ 
+ 	orig_node->bat_priv = bat_priv;
+ 	ether_addr_copy(orig_node->orig, addr);
diff --git a/batman-adv/patches/0043-batman-adv-Place-kref_get-for-tt_local_entry-near-us.patch b/batman-adv/patches/0043-batman-adv-Place-kref_get-for-tt_local_entry-near-us.patch
new file mode 100644
index 0000000..4c88c53
--- /dev/null
+++ b/batman-adv/patches/0043-batman-adv-Place-kref_get-for-tt_local_entry-near-us.patch
@@ -0,0 +1,35 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:22 +0200
+Subject: [PATCH] batman-adv: Place kref_get for tt_local_entry near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/translation-table.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 5cc500f..094da1a 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -734,7 +734,6 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 	if (batadv_is_wifi_netdev(in_dev))
+ 		tt_local->common.flags |= BATADV_TT_CLIENT_WIFI;
+ 	kref_init(&tt_local->common.refcount);
+-	kref_get(&tt_local->common.refcount);
+ 	tt_local->last_seen = jiffies;
+ 	tt_local->common.added_at = tt_local->last_seen;
+ 	tt_local->vlan = vlan;
+@@ -746,6 +745,7 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
+ 	    is_multicast_ether_addr(addr))
+ 		tt_local->common.flags |= BATADV_TT_CLIENT_NOPURGE;
+ 
++	kref_get(&tt_local->common.refcount);
+ 	hash_added = batadv_hash_add(bat_priv->tt.local_hash, batadv_compare_tt,
+ 				     batadv_choose_tt, &tt_local->common,
+ 				     &tt_local->common.hash_entry);
diff --git a/batman-adv/patches/0044-batman-adv-Place-kref_get-for-tt_common-near-use.patch b/batman-adv/patches/0044-batman-adv-Place-kref_get-for-tt_common-near-use.patch
new file mode 100644
index 0000000..b06039e
--- /dev/null
+++ b/batman-adv/patches/0044-batman-adv-Place-kref_get-for-tt_common-near-use.patch
@@ -0,0 +1,34 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:23 +0200
+Subject: [PATCH] batman-adv: Place kref_get for tt_common near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/translation-table.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
+index 094da1a..d94e298 100644
+--- a/net/batman-adv/translation-table.c
++++ b/net/batman-adv/translation-table.c
+@@ -1645,13 +1645,13 @@ static bool batadv_tt_global_add(struct batadv_priv *bat_priv,
+ 		if (flags & BATADV_TT_CLIENT_ROAM)
+ 			tt_global_entry->roam_at = jiffies;
+ 		kref_init(&common->refcount);
+-		kref_get(&common->refcount);
+ 		common->added_at = jiffies;
+ 
+ 		INIT_HLIST_HEAD(&tt_global_entry->orig_list);
+ 		atomic_set(&tt_global_entry->orig_list_count, 0);
+ 		spin_lock_init(&tt_global_entry->list_lock);
+ 
++		kref_get(&common->refcount);
+ 		hash_added = batadv_hash_add(bat_priv->tt.global_hash,
+ 					     batadv_compare_tt,
+ 					     batadv_choose_tt, common,
diff --git a/batman-adv/patches/0045-batman-adv-Place-kref_get-for-bla_claim-near-use.patch b/batman-adv/patches/0045-batman-adv-Place-kref_get-for-bla_claim-near-use.patch
new file mode 100644
index 0000000..23372ef
--- /dev/null
+++ b/batman-adv/patches/0045-batman-adv-Place-kref_get-for-bla_claim-near-use.patch
@@ -0,0 +1,35 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:24 +0200
+Subject: [PATCH] batman-adv: Place kref_get for bla_claim near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bridge_loop_avoidance.c | 5 +++--
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
+index 35ed1d3..b0517a0 100644
+--- a/net/batman-adv/bridge_loop_avoidance.c
++++ b/net/batman-adv/bridge_loop_avoidance.c
+@@ -718,12 +718,13 @@ static void batadv_bla_add_claim(struct batadv_priv *bat_priv,
+ 		claim->lasttime = jiffies;
+ 		kref_get(&backbone_gw->refcount);
+ 		claim->backbone_gw = backbone_gw;
+-
+ 		kref_init(&claim->refcount);
+-		kref_get(&claim->refcount);
++
+ 		batadv_dbg(BATADV_DBG_BLA, bat_priv,
+ 			   "bla_add_claim(): adding new entry %pM, vid %d to hash ...\n",
+ 			   mac, BATADV_PRINT_VID(vid));
++
++		kref_get(&claim->refcount);
+ 		hash_added = batadv_hash_add(bat_priv->bla.claim_hash,
+ 					     batadv_compare_claim,
+ 					     batadv_choose_claim, claim,
diff --git a/batman-adv/patches/0046-batman-adv-Place-kref_get-for-bla_backbone_gw-near-u.patch b/batman-adv/patches/0046-batman-adv-Place-kref_get-for-bla_backbone_gw-near-u.patch
new file mode 100644
index 0000000..b84c2d3
--- /dev/null
+++ b/batman-adv/patches/0046-batman-adv-Place-kref_get-for-bla_backbone_gw-near-u.patch
@@ -0,0 +1,32 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:25 +0200
+Subject: [PATCH] batman-adv: Place kref_get for bla_backbone_gw near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/bridge_loop_avoidance.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
+index b0517a0..1db3c12 100644
+--- a/net/batman-adv/bridge_loop_avoidance.c
++++ b/net/batman-adv/bridge_loop_avoidance.c
+@@ -526,11 +526,9 @@ batadv_bla_get_backbone_gw(struct batadv_priv *bat_priv, u8 *orig,
+ 	atomic_set(&entry->wait_periods, 0);
+ 	ether_addr_copy(entry->orig, orig);
+ 	INIT_WORK(&entry->report_work, batadv_bla_loopdetect_report);
+-
+-	/* one for the hash, one for returning */
+ 	kref_init(&entry->refcount);
+-	kref_get(&entry->refcount);
+ 
++	kref_get(&entry->refcount);
+ 	hash_added = batadv_hash_add(bat_priv->bla.backbone_hash,
+ 				     batadv_compare_backbone_gw,
+ 				     batadv_choose_backbone_gw, entry,
diff --git a/batman-adv/patches/0047-batman-adv-Place-kref_get-for-dat_entry-near-use.patch b/batman-adv/patches/0047-batman-adv-Place-kref_get-for-dat_entry-near-use.patch
new file mode 100644
index 0000000..ee0fe02
--- /dev/null
+++ b/batman-adv/patches/0047-batman-adv-Place-kref_get-for-dat_entry-near-use.patch
@@ -0,0 +1,29 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:26 +0200
+Subject: [PATCH] batman-adv: Place kref_get for dat_entry near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/distributed-arp-table.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c
+index b1cc8bf..059bc23 100644
+--- a/net/batman-adv/distributed-arp-table.c
++++ b/net/batman-adv/distributed-arp-table.c
+@@ -343,8 +343,8 @@ static void batadv_dat_entry_add(struct batadv_priv *bat_priv, __be32 ip,
+ 	ether_addr_copy(dat_entry->mac_addr, mac_addr);
+ 	dat_entry->last_update = jiffies;
+ 	kref_init(&dat_entry->refcount);
+-	kref_get(&dat_entry->refcount);
+ 
++	kref_get(&dat_entry->refcount);
+ 	hash_added = batadv_hash_add(bat_priv->dat.hash, batadv_compare_dat,
+ 				     batadv_hash_dat, dat_entry,
+ 				     &dat_entry->hash_entry);
diff --git a/batman-adv/patches/0048-batman-adv-Place-kref_get-for-gw_node-near-use.patch b/batman-adv/patches/0048-batman-adv-Place-kref_get-for-gw_node-near-use.patch
new file mode 100644
index 0000000..7faa6f9
--- /dev/null
+++ b/batman-adv/patches/0048-batman-adv-Place-kref_get-for-gw_node-near-use.patch
@@ -0,0 +1,46 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:27 +0200
+Subject: [PATCH] batman-adv: Place kref_get for gw_node near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/gateway_client.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/gateway_client.c b/net/batman-adv/gateway_client.c
+index b889e1f..4b51b1c 100644
+--- a/net/batman-adv/gateway_client.c
++++ b/net/batman-adv/gateway_client.c
+@@ -339,14 +339,15 @@ static void batadv_gw_node_add(struct batadv_priv *bat_priv,
+ 	if (!gw_node)
+ 		return;
+ 
++	kref_init(&gw_node->refcount);
+ 	INIT_HLIST_NODE(&gw_node->list);
+ 	kref_get(&orig_node->refcount);
+ 	gw_node->orig_node = orig_node;
+ 	gw_node->bandwidth_down = ntohl(gateway->bandwidth_down);
+ 	gw_node->bandwidth_up = ntohl(gateway->bandwidth_up);
+-	kref_init(&gw_node->refcount);
+ 
+ 	spin_lock_bh(&bat_priv->gw.list_lock);
++	kref_get(&gw_node->refcount);
+ 	hlist_add_head_rcu(&gw_node->list, &bat_priv->gw.list);
+ 	spin_unlock_bh(&bat_priv->gw.list_lock);
+ 
+@@ -357,6 +358,9 @@ static void batadv_gw_node_add(struct batadv_priv *bat_priv,
+ 		   ntohl(gateway->bandwidth_down) % 10,
+ 		   ntohl(gateway->bandwidth_up) / 10,
+ 		   ntohl(gateway->bandwidth_up) % 10);
++
++	/* don't return reference to new gw_node */
++	batadv_gw_node_put(gw_node);
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0049-batman-adv-Place-kref_get-for-hard_iface-near-use.patch b/batman-adv/patches/0049-batman-adv-Place-kref_get-for-hard_iface-near-use.patch
new file mode 100644
index 0000000..5be0e12
--- /dev/null
+++ b/batman-adv/patches/0049-batman-adv-Place-kref_get-for-hard_iface-near-use.patch
@@ -0,0 +1,40 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:28 +0200
+Subject: [PATCH] batman-adv: Place kref_get for hard_iface near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/hard-interface.c | 6 ++----
+ 1 file changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 43c9a3e..9284c73 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -694,6 +694,7 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+ 	INIT_HLIST_HEAD(&hard_iface->neigh_list);
+ 
+ 	spin_lock_init(&hard_iface->neigh_list_lock);
++	kref_init(&hard_iface->refcount);
+ 
+ 	hard_iface->num_bcasts = BATADV_NUM_BCASTS_DEFAULT;
+ 	if (batadv_is_wifi_netdev(net_dev))
+@@ -701,11 +702,8 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+ 
+ 	batadv_v_hardif_init(hard_iface);
+ 
+-	/* extra reference for return */
+-	kref_init(&hard_iface->refcount);
+-	kref_get(&hard_iface->refcount);
+-
+ 	batadv_check_known_mac_addr(hard_iface->net_dev);
++	kref_get(&hard_iface->refcount);
+ 	list_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);
+ 
+ 	return hard_iface;
diff --git a/batman-adv/patches/0050-batman-adv-Place-kref_get-for-softif_vlan-near-use.patch b/batman-adv/patches/0050-batman-adv-Place-kref_get-for-softif_vlan-near-use.patch
new file mode 100644
index 0000000..9c668b3
--- /dev/null
+++ b/batman-adv/patches/0050-batman-adv-Place-kref_get-for-softif_vlan-near-use.patch
@@ -0,0 +1,37 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:29 +0200
+Subject: [PATCH] batman-adv: Place kref_get for softif_vlan near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/soft-interface.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
+index e508bf5..49e16b6 100644
+--- a/net/batman-adv/soft-interface.c
++++ b/net/batman-adv/soft-interface.c
+@@ -594,6 +594,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
+ 	}
+ 
+ 	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
++	kref_get(&vlan->refcount);
+ 	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
+ 	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
+ 
+@@ -604,6 +605,9 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
+ 			    bat_priv->soft_iface->dev_addr, vid,
+ 			    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
+ 
++	/* don't return reference to new softif_vlan */
++	batadv_softif_vlan_put(vlan);
++
+ 	return 0;
+ }
+ 
diff --git a/batman-adv/patches/0051-batman-adv-Place-kref_get-for-nc_node-near-use.patch b/batman-adv/patches/0051-batman-adv-Place-kref_get-for-nc_node-near-use.patch
new file mode 100644
index 0000000..ebdf9fb
--- /dev/null
+++ b/batman-adv/patches/0051-batman-adv-Place-kref_get-for-nc_node-near-use.patch
@@ -0,0 +1,35 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:30 +0200
+Subject: [PATCH] batman-adv: Place kref_get for nc_node near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/network-coding.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index 3814cfb..4f4cfe5 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -859,7 +859,6 @@ batadv_nc_get_nc_node(struct batadv_priv *bat_priv,
+ 	/* Initialize nc_node */
+ 	INIT_LIST_HEAD(&nc_node->list);
+ 	kref_init(&nc_node->refcount);
+-	kref_get(&nc_node->refcount);
+ 	ether_addr_copy(nc_node->addr, orig_node->orig);
+ 	kref_get(&orig_neigh_node->refcount);
+ 	nc_node->orig_node = orig_neigh_node;
+@@ -878,6 +877,7 @@ batadv_nc_get_nc_node(struct batadv_priv *bat_priv,
+ 
+ 	/* Add nc_node to orig_node */
+ 	spin_lock_bh(lock);
++	kref_get(&nc_node->refcount);
+ 	list_add_tail_rcu(&nc_node->list, list);
+ 	spin_unlock_bh(lock);
+ 
diff --git a/batman-adv/patches/0052-batman-adv-Place-kref_get-for-nc_path-near-use.patch b/batman-adv/patches/0052-batman-adv-Place-kref_get-for-nc_path-near-use.patch
new file mode 100644
index 0000000..5a2077a
--- /dev/null
+++ b/batman-adv/patches/0052-batman-adv-Place-kref_get-for-nc_path-near-use.patch
@@ -0,0 +1,35 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:31 +0200
+Subject: [PATCH] batman-adv: Place kref_get for nc_path near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/network-coding.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c
+index 4f4cfe5..165cd27 100644
+--- a/net/batman-adv/network-coding.c
++++ b/net/batman-adv/network-coding.c
+@@ -978,7 +978,6 @@ static struct batadv_nc_path *batadv_nc_get_path(struct batadv_priv *bat_priv,
+ 	INIT_LIST_HEAD(&nc_path->packet_list);
+ 	spin_lock_init(&nc_path->packet_list_lock);
+ 	kref_init(&nc_path->refcount);
+-	kref_get(&nc_path->refcount);
+ 	nc_path->last_valid = jiffies;
+ 	ether_addr_copy(nc_path->next_hop, dst);
+ 	ether_addr_copy(nc_path->prev_hop, src);
+@@ -988,6 +987,7 @@ static struct batadv_nc_path *batadv_nc_get_path(struct batadv_priv *bat_priv,
+ 		   nc_path->next_hop);
+ 
+ 	/* Add nc_path to hash table */
++	kref_get(&nc_path->refcount);
+ 	hash_added = batadv_hash_add(hash, batadv_nc_hash_compare,
+ 				     batadv_nc_hash_choose, &nc_path_key,
+ 				     &nc_path->hash_entry);
diff --git a/batman-adv/patches/0053-batman-adv-Place-kref_get-for-tvlv_container-near-us.patch b/batman-adv/patches/0053-batman-adv-Place-kref_get-for-tvlv_container-near-us.patch
new file mode 100644
index 0000000..fd26cdb
--- /dev/null
+++ b/batman-adv/patches/0053-batman-adv-Place-kref_get-for-tvlv_container-near-us.patch
@@ -0,0 +1,33 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:32 +0200
+Subject: [PATCH] batman-adv: Place kref_get for tvlv_container near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/tvlv.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/net/batman-adv/tvlv.c b/net/batman-adv/tvlv.c
+index 3d1cf0f..3533867 100644
+--- a/net/batman-adv/tvlv.c
++++ b/net/batman-adv/tvlv.c
+@@ -257,8 +257,13 @@ void batadv_tvlv_container_register(struct batadv_priv *bat_priv,
+ 	spin_lock_bh(&bat_priv->tvlv.container_list_lock);
+ 	tvlv_old = batadv_tvlv_container_get(bat_priv, type, version);
+ 	batadv_tvlv_container_remove(bat_priv, tvlv_old);
++
++	kref_get(&tvlv_new->refcount);
+ 	hlist_add_head(&tvlv_new->list, &bat_priv->tvlv.container_list);
+ 	spin_unlock_bh(&bat_priv->tvlv.container_list_lock);
++
++	/* don't return reference to new tvlv_container */
++	batadv_tvlv_container_put(tvlv_new);
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0054-batman-adv-Place-kref_get-for-tvlv_handler-near-use.patch b/batman-adv/patches/0054-batman-adv-Place-kref_get-for-tvlv_handler-near-use.patch
new file mode 100644
index 0000000..161f3bb
--- /dev/null
+++ b/batman-adv/patches/0054-batman-adv-Place-kref_get-for-tvlv_handler-near-use.patch
@@ -0,0 +1,32 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 15 Jul 2016 17:39:33 +0200
+Subject: [PATCH] batman-adv: Place kref_get for tvlv_handler near use
+
+It is hard to understand why the refcnt is increased when it isn't done
+near the actual place the new reference is used. So using kref_get right
+before the place which requires the reference and in the same function
+helps to avoid accidental problems causedy incorrect reference counting.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/tvlv.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/net/batman-adv/tvlv.c b/net/batman-adv/tvlv.c
+index 3533867..77654f0 100644
+--- a/net/batman-adv/tvlv.c
++++ b/net/batman-adv/tvlv.c
+@@ -547,8 +547,12 @@ void batadv_tvlv_handler_register(struct batadv_priv *bat_priv,
+ 	INIT_HLIST_NODE(&tvlv_handler->list);
+ 
+ 	spin_lock_bh(&bat_priv->tvlv.handler_list_lock);
++	kref_get(&tvlv_handler->refcount);
+ 	hlist_add_head_rcu(&tvlv_handler->list, &bat_priv->tvlv.handler_list);
+ 	spin_unlock_bh(&bat_priv->tvlv.handler_list_lock);
++
++	/* don't return reference to new tvlv_handler */
++	batadv_tvlv_handler_put(tvlv_handler);
+ }
+ 
+ /**
diff --git a/batman-adv/patches/0055-batman-adv-Keep-batadv-netdev-when-hardif-disappears.patch b/batman-adv/patches/0055-batman-adv-Keep-batadv-netdev-when-hardif-disappears.patch
new file mode 100644
index 0000000..5b0e353
--- /dev/null
+++ b/batman-adv/patches/0055-batman-adv-Keep-batadv-netdev-when-hardif-disappears.patch
@@ -0,0 +1,37 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Sun, 10 Jul 2016 15:47:57 +0200
+Subject: [PATCH] batman-adv: Keep batadv netdev when hardif disappears
+
+Switch-like virtual interfaces like bridge or openvswitch don't destroy
+itself when all their attached netdevices dissappear. Instead they only
+remove the link to the unregistered device and keep working until they get
+removed manually.
+
+This has the benefit that all configurations for this interfaces are kept
+and daemons reacting to rtnl events can just add new slave interfaces
+without going through the complete configuration of the switch-like
+netdevice.
+
+Handling unregister events of client devices similar in batman-adv allows
+users to drop their current workaround of dummy netdevices attached to
+batman-adv soft-interfaces.
+
+Signed-off-by: Sven Eckelmann <sven@narfation.org>
+Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
+---
+ net/batman-adv/hard-interface.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 9284c73..08ce361 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -725,7 +725,7 @@ static void batadv_hardif_remove_interface(struct batadv_hard_iface *hard_iface)
+ 	/* first deactivate interface */
+ 	if (hard_iface->if_status != BATADV_IF_NOT_IN_USE)
+ 		batadv_hardif_disable_interface(hard_iface,
+-						BATADV_IF_CLEANUP_AUTO);
++						BATADV_IF_CLEANUP_KEEP);
+ 
+ 	if (hard_iface->if_status != BATADV_IF_NOT_IN_USE)
+ 		return;
diff --git a/batman-adv/patches/0056-Add-compat-fallback-for-batadv_getlink_net.patch b/batman-adv/patches/0056-Add-compat-fallback-for-batadv_getlink_net.patch
new file mode 100644
index 0000000..23592e8
--- /dev/null
+++ b/batman-adv/patches/0056-Add-compat-fallback-for-batadv_getlink_net.patch
@@ -0,0 +1,29 @@
+From: Sven Eckelmann <sven@narfation.org>
+Date: Fri, 23 Sep 2016 14:55:38 +0200
+Subject: [PATCH] Add compat fallback for batadv_getlink_net
+---
+ net/batman-adv/hard-interface.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 08ce361..e6ea2f9 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -95,6 +95,9 @@ out:
+ static const struct net *batadv_getlink_net(const struct net_device *netdev,
+ 					    const struct net *fallback_net)
+ {
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
++	return fallback_net;
++#else
+ 	if (!netdev->rtnl_link_ops)
+ 		return fallback_net;
+ 
+@@ -102,6 +105,7 @@ static const struct net *batadv_getlink_net(const struct net_device *netdev,
+ 		return fallback_net;
+ 
+ 	return netdev->rtnl_link_ops->get_link_net(netdev);
++#endif
+ }
+ 
+ /**
